

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="DingJiayu">
  <meta name="keywords" content="">
  
    <meta name="description" content="malloc源码解析首先看下没有tcache 的glibc， 接着看下加入tcache的版本 基础结构体glibc是从系统中map一块内存，然后利用自己的结构体进行管理 malloc_chunk在glibc中申请的块结构体如下： 123456789101112struct malloc_chunk &#123;  INTERNAL_SIZE_T      prev_size;  &#x2F;* Size o">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc源码分析">
<meta property="og:url" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="binpwn&#39;s blog">
<meta property="og:description" content="malloc源码解析首先看下没有tcache 的glibc， 接着看下加入tcache的版本 基础结构体glibc是从系统中map一块内存，然后利用自己的结构体进行管理 malloc_chunk在glibc中申请的块结构体如下： 123456789101112struct malloc_chunk &#123;  INTERNAL_SIZE_T      prev_size;  &#x2F;* Size o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826095121807.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826110327985.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826105607517.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111658067.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111749279.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113226836.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113819020.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113830825.png">
<meta property="og:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113904645.png">
<meta property="article:published_time" content="2023-11-26T15:27:03.000Z">
<meta property="article:modified_time" content="2024-08-26T15:56:05.871Z">
<meta property="article:author" content="DingJiayu">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://binpwn.github.io/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826095121807.png">
  
  
  
  <title>malloc源码分析 - binpwn&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binpwn.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>binpwn&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="malloc源码分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-26 23:27" pubdate>
          2023年11月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          61 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">malloc源码分析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="malloc源码解析"><a href="#malloc源码解析" class="headerlink" title="malloc源码解析"></a>malloc源码解析</h1><p>首先看下没有tcache 的glibc， 接着看下加入tcache的版本</p>
<h2 id="基础结构体"><a href="#基础结构体" class="headerlink" title="基础结构体"></a>基础结构体</h2><p>glibc是从系统中map一块内存，然后利用自己的结构体进行管理</p>
<h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>在glibc中申请的块结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>下面是各字段的位置以及含义<br><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826095121807.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>我们在了解glibc的堆分配时可能会听到arena，其实就是下面的结构体，可以用来记录top、fastbin和bins的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>glibc中堆分配时遇到的heap结构即下面的结构体：包含了前一个heap和当前heap的大小，还有就是当前heap的arena</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure>

<h2 id="do-check的一些函数"><a href="#do-check的一些函数" class="headerlink" title="do_check的一些函数"></a>do_check的一些函数</h2><p>这部分主要就是在glibc开启debug模式下才会调用的函数，这里单独拿出来看下</p>
<h3 id="do-check-remalloced-chunk"><a href="#do-check-remalloced-chunk" class="headerlink" title="do_check_remalloced_chunk"></a>do_check_remalloced_chunk</h3><p>下面这部分主要判断：</p>
<p>该chunk要对应上其arena，以及其arena是否为main_arena要和其size中的标志位能对应上；</p>
<p>对该chunk进行使用状态检查；</p>
<p>该chunk的size要对齐，大小符合规范；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_remalloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//这部分主要检查chunk是否能对应上其arena，还有是否为main_arena这个问题</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      assert (av == arena_for_chunk (p));<br>      <span class="hljs-keyword">if</span> (chunk_non_main_arena (p))<br>        assert (av != &amp;main_arena);<br>      <span class="hljs-keyword">else</span><br>        assert (av == &amp;main_arena);<br>    &#125;<br><br>  do_check_inuse_chunk (av, p);<br><br>  <span class="hljs-comment">/* Legal size ... */</span><br>  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>  <span class="hljs-comment">/* ... and alignment */</span><br>  assert (aligned_OK (chunk2mem (p)));<br>  <span class="hljs-comment">/* chunk is less than MINSIZE more than request */</span><br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s) &gt;= <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s + MINSIZE) &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="do-check-inuse-chunk"><a href="#do-check-inuse-chunk" class="headerlink" title="do_check_inuse_chunk"></a>do_check_inuse_chunk</h3><p>下面判断了：</p>
<p>该chunk要处于使用状态；</p>
<p>如果该chunk的物理相邻的前一个chunk处于未使用状态：</p>
<p>则用来判断前一个chunk的后一个chunk是该chunk；</p>
<p>判断前一个空闲chunk符合释放规范</p>
<p>如果该chunk物理相邻的下一个chunk是topchunk：</p>
<p>就检查一下topchunk的大小以及</p>
<p>通过top chunk来判断该chunk处于使用状态</p>
<p>如果该chunk物理相邻的下一个chunk不是topchunk，并且处于未使用状态：</p>
<p>确保下一个chunk符合释放规范</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_inuse_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  mchunkptr next;<br><br>  do_check_chunk (av, p);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* mmapped chunks have no next/prev */</span><br><br>  <span class="hljs-comment">/* Check whether it claims to be in use ... */</span><br>  <span class="hljs-comment">//该chunk处于使用状态，判断方式是通过物理相邻的下一个chunk来判断</span><br>  assert (inuse (p));<br><br>  next = next_chunk (p);<br><br>  <span class="hljs-comment">/* ... and is surrounded by OK chunks.</span><br><span class="hljs-comment">     Since more things can be checked with free chunks than inuse ones,</span><br><span class="hljs-comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (!prev_inuse (p))<br>    &#123;<br>      <span class="hljs-comment">/* Note that we cannot even look at prev unless it is not inuse */</span><br>      mchunkptr prv = prev_chunk (p);<br>      assert (next_chunk (prv) == p);<br>      do_check_free_chunk (av, prv);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (next == av-&gt;top)<br>    &#123;<br>      assert (prev_inuse (next));<br>      assert (chunksize (next) &gt;= MINSIZE);<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inuse (next))<br>    do_check_free_chunk (av, next);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="do-check-free-chunk"><a href="#do-check-free-chunk" class="headerlink" title="do_check_free_chunk"></a>do_check_free_chunk</h3><p>下面检查已释放的chunk，检查以下几个方面：</p>
<p>基本的chunk规范检查；</p>
<p>该chunk处于未使用状态；</p>
<p>该chunk不是mapped；</p>
<p>该chunk的大小对齐；</p>
<p>该chunk的size和下一个物理相邻chunk所记录的一致；</p>
<p>该chunk与其物理相邻的chunk该合并的已合并，通过判断前一个或后一个chunk的使用状态；</p>
<p>该chunk与其物理相邻chunk的链接确保规范；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_free_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br>  mchunkptr next = chunk_at_offset (p, sz);<br><br>  do_check_chunk (av, p);<br><br>  <span class="hljs-comment">/* Chunk must claim to be free ... */</span><br>  assert (!inuse (p));<br>  assert (!chunk_is_mmapped (p));<br><br>  <span class="hljs-comment">/* Unless a special marker, must have OK fields */</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE)<br>    &#123;<br>      assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>      assert (aligned_OK (chunk2mem (p)));<br>      <span class="hljs-comment">/* ... matching footer field */</span><br>      assert (next-&gt;prev_size == sz);<br>      <span class="hljs-comment">/* ... and is fully consolidated */</span><br>      assert (prev_inuse (p));<br>      assert (next == av-&gt;top || inuse (next));<br><br>      <span class="hljs-comment">/* ... and has minimally sane links */</span><br>      assert (p-&gt;fd-&gt;bk == p);<br>      assert (p-&gt;bk-&gt;fd == p);<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">/* markers are always of size SIZE_SZ */</span><br>    assert (sz == SIZE_SZ);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="do-check-chunk"><a href="#do-check-chunk" class="headerlink" title="do_check_chunk"></a>do_check_chunk</h3><p>下面的判断是检查chunk的地址在其应在的范围内</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz = chunksize (p);<br>  <span class="hljs-comment">/* min and max possible addresses assuming contiguous allocation */</span><br>  <span class="hljs-type">char</span> *max_address = (<span class="hljs-type">char</span> *) (av-&gt;top) + chunksize (av-&gt;top);<br>  <span class="hljs-type">char</span> *min_address = max_address - av-&gt;system_mem;<br><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      <span class="hljs-comment">/* Has legal address ... */</span><br>      <span class="hljs-keyword">if</span> (p != av-&gt;top)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            &#123;<br>              assert (((<span class="hljs-type">char</span> *) p) &gt;= min_address);<br>              assert (((<span class="hljs-type">char</span> *) p + sz) &lt;= ((<span class="hljs-type">char</span> *) (av-&gt;top)));<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/* top size is always at least MINSIZE */</span><br>          assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>          <span class="hljs-comment">/* top predecessor always marked inuse */</span><br>          assert (prev_inuse (p));<br>        &#125;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">/* address is outside main heap  */</span><br>      <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; av-&gt;top != initial_top (av))<br>        &#123;<br>          assert (((<span class="hljs-type">char</span> *) p) &lt; min_address || ((<span class="hljs-type">char</span> *) p) &gt;= max_address);<br>        &#125;<br>      <span class="hljs-comment">/* chunk is page-aligned */</span><br>      assert (((p-&gt;prev_size + sz) &amp; (GLRO (dl_pagesize) - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">/* mem is aligned */</span><br>      assert (aligned_OK (chunk2mem (p)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="do-check-malloced-chunk"><a href="#do-check-malloced-chunk" class="headerlink" title="do_check_malloced_chunk"></a>do_check_malloced_chunk</h3><p>这个检查其实还是调用上面的代码，就是注意除了上面的检查外，它还额外检查了该chunk p的上一个chunk是使用状态的；</p>
<p>因为这是在smallbin范围内，如果上一个chunk未处于使用状态，并且在该chunk p未分配之前它也是空闲的，会可能发生合并，而不应该出现两个空闲的chunk并存(fast chunk除外)：</p>
<p>如果上一个chunk 是fast chunk，prev_inuse标志位生效；</p>
<p>如果上一个chunk是非fast chunk而且非空闲，则prev_inuse生效；如果上一个是空闲chunk则会发生合并，而不会出现两个空闲的chunk并存；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Properties of nonrecycled chunks at the point they are malloced</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_malloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  <span class="hljs-comment">/* same as recycled case ... */</span><br>  do_check_remalloced_chunk (av, p, s);<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     ... plus,  must obey implementation invariant that prev_inuse is</span><br><span class="hljs-comment">     always true of any allocated chunk; i.e., that each allocated</span><br><span class="hljs-comment">     chunk borders either a previously allocated and still in-use</span><br><span class="hljs-comment">     chunk, or the base of its memory arena. This is ensured</span><br><span class="hljs-comment">     by making all allocations from the `lowest&#x27; part of any found</span><br><span class="hljs-comment">     chunk.  This does not necessarily hold however for chunks</span><br><span class="hljs-comment">     recycled via fastbins.</span><br><span class="hljs-comment">   */</span><br><br>  assert (prev_inuse (p));<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="do-check函数之间的调用关系"><a href="#do-check函数之间的调用关系" class="headerlink" title="do_check函数之间的调用关系"></a>do_check函数之间的调用关系</h3><p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826110327985.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="malloc的过程"><a href="#malloc的过程" class="headerlink" title="malloc的过程"></a>malloc的过程</h2><p>当我们在C语言中使用malloc函数时会在ptmalloc中调用下面的lib_malloc函数</p>
<h3 id="lib-malloc"><a href="#lib-malloc" class="headerlink" title="lib_malloc"></a>lib_malloc</h3><p>该函数进行初步的处理，比如获取arena，接着会调用int_malloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><span class="hljs-comment">//1.获取malloc_hook</span><br><span class="hljs-comment">//用来判断是否有hook函数，如果有hook函数就调用，否则向下继续进行</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><span class="hljs-comment">//2.获取arena</span><br><span class="hljs-comment">//获取arena后用int_malloc来分配</span><br><span class="hljs-comment">//</span><br>  arena_get (ar_ptr, bytes);<br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span>                                                                                                      <br>  <span class="hljs-comment">//3.换个arena重试</span><br>  <span class="hljs-comment">//如果上一个arena没有分配成功就换一个重试一下</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h4><p>这个宏是用来获取arena的，方便后面用arena来进行内存分配，主要就是上锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> arena_get(ptr, size) do &#123; \</span><br><span class="hljs-meta">      ptr = thread_arena;                              \</span><br><span class="hljs-meta">      arena_lock (ptr, size);                              \</span><br><span class="hljs-meta">  &#125; while (0)</span><br></code></pre></td></tr></table></figure>



<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="int_malloc"></a>int_malloc</h3><h4 id="定义和一些预操作"><a href="#定义和一些预操作" class="headerlink" title="定义和一些预操作"></a>定义和一些预操作</h4><p>这里主要是一些变量的定义和一些初步操作，比如将用户申请的大小转为chunk的大小，还有就是arena的判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">//1.将用户申请的大小转为chunk大小</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br><span class="hljs-comment">//2.如果arena为空，那就调用sysmalloc来分配</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><p>根据转换后的chunk的大小依次判断是那种类型的chunk，首先就是fastbin，这里先给出代码和注释部分然后看下分配流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>  &#123;<br>    idx = fastbin_index (nb);<span class="hljs-comment">//获取chunk大小对应的fastbin索引</span><br>    <br>    <span class="hljs-comment">//#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br>    <span class="hljs-comment">//注意这里是个二级指针</span><br>    <span class="hljs-comment">//fb指向对应的fastbin，pp指向fastbin所指向的chunk</span><br>    mfastbinptr *fb = &amp;fastbin (av, idx);<br>    mchunkptr pp = *fb;<br>    <span class="hljs-comment">//catomic_compare_and_exchange_val_acq(a,b,c)意思是如果*a==c,就将 *a = b;否则不变；返回值一直是 *a</span><br>    <span class="hljs-comment">//所以下面是比较 *fb 与 victim，如果相等就 *fb = victim-&gt;fd，相当于移动一个chunk从而空出一个用来分配</span><br>    <span class="hljs-comment">//外层的pp = .. != victim  其实表达的意思一样，相当于又比较一边</span><br>    <span class="hljs-comment">//下面循环的效果就是从fastbin中摘出一个chunk</span><br>    <span class="hljs-keyword">do</span><br>      &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>           != victim);             <br>    <span class="hljs-comment">//如果victim不为空说明分配了一个chunk</span><br>    <span class="hljs-comment">//下面主要用来检查分配的chunk对应的fastbin索引和最初用来定位该fastchunk的idx是否一致</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>          &#123;<br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>          errout:<br>            malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>          &#125;<br>        check_remalloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>每次从fast bin中分配chunk时，会先获取所申请大小对应fast bin中的索引，然后根据这个索引找到合适的fast bin头部</p>
<p>每次分配都是先分配其对应fast bin的fd所指向的chunk，我们称为victim，下图为chunk1，分配走后，fast bin的fd指向victim-&gt;fd，下图为chunk2;</p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826105607517.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small_bin"></a>small_bin</h4><p>在看这段代码之前，介绍下前面malloc_state的结构体的bins成员。这是一个数组，但是将其抽象成了bin的数组，每个bin由两个单位组成，分别表示fd和bk；</p>
<p>如下图bin1和bin2，如果将bin2向前移动两个单位，此时bin1和bin2所占的4个单位可以看成一个chunk；</p>
<p>chunk-&gt;fd和chunk-&gt;bk分别访问的是bin2的fd和bk；</p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111658067.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">    hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">    processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">    anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>   &#123;        <br>     <span class="hljs-comment">//1.获取大小对应的smallbin索引，然后获取对应的bin，这里是将对应的bin当成一个chunk用</span><br>     <span class="hljs-comment">//</span><br>     <span class="hljs-comment">//</span><br>     idx = smallbin_index (nb);<br>     bin = bin_at (av, idx);<br><br>     <span class="hljs-comment">//2.last(bin)就是bin-&gt;bk，这里取victim = bin-&gt;bk</span><br>     <span class="hljs-comment">//如果victim != bin 说明此small bin不空</span><br>     <span class="hljs-comment">//</span><br>     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>       &#123;        <br>         <span class="hljs-comment">//3.</span><br>         <span class="hljs-comment">//如果victim == NULL 说明还未初始化</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>           malloc_consolidate (av);<br>         <span class="hljs-keyword">else</span><br>           &#123;<br>             <span class="hljs-comment">//4.下面就是从smallbin中分配chunk，每次分配是将bin-&gt;bk分配走；</span><br>             <span class="hljs-comment">//下面检查的是victim-&gt;bk-&gt;fd == victim</span><br>             <span class="hljs-comment">//</span><br>             bck = victim-&gt;bk;<br>           <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>               victim-&gt;size |= NON_MAIN_ARENA;                                                <br>             #下面这一句是仅MALLOCDEBUG模式下有效<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>每次从small bin中分配chunk，都是分配bin -&gt; bk ，对应下图的chunk1，然后bin -&gt; bk 指向 chunk2，chunk2 -&gt; fd指向bin</p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826111749279.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large_bin"></a>large_bin</h4><p>这部分代码比较少，后面会逐步介绍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">     While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">     even seeing if there is space available, this avoids</span><br><span class="hljs-comment">     fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">     Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">     large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">     invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">     it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      idx = largebin_index (nb);<br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h5 id="关于flag"><a href="#关于flag" class="headerlink" title="关于flag"></a>关于flag</h5><p>用malloc_state中的flags标志位来判断fast bin中是否有chunk：</p>
<p>相关宏定义如下，flags的bit0为0表示fast bin中有fast chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FASTCHUNKS_BIT        (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br></code></pre></td></tr></table></figure>

<h5 id="关于max-fast"><a href="#关于max-fast" class="headerlink" title="关于max_fast"></a>关于max_fast</h5><p>在malloc_init_state中通过调用set_max_fast宏来初始化fast chunk的最大大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">malloc_init_state</span> <span class="hljs-params">(mstate av)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  mbinptr bin;<br><br>  <span class="hljs-comment">/* Establish circular links for normal bins */</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i)<br>    &#123;<br>      bin = bin_at (av, i);<br>      bin-&gt;fd = bin-&gt;bk = bin;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CONTIGUOUS</span><br>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  set_noncontiguous (av);<br>  <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br>    set_max_fast (DEFAULT_MXFAST);<br>  av-&gt;flags |= FASTCHUNKS_BIT;<br><br>  av-&gt;top = initial_top (av);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>default_maxfast 定义了默认fast chunk的最大大小，比如64位程序中，默认最大大小就是128 即 0x80</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEFAULT_MXFAST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                              \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_max_fast() global_max_fast</span><br><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br></code></pre></td></tr></table></figure>

<p>下面是操作global_max_fast的流程，可以通过global_max_fast来判断是否进行初始化</p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113226836.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="关于malloc-consolidate"><a href="#关于malloc-consolidate" class="headerlink" title="关于malloc_consolidate"></a>关于malloc_consolidate</h5><p>先给出两个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span><br><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span><br><br></code></pre></td></tr></table></figure>

<p>下面这段程序主要做的事情有：</p>
<p>首先遍历fast bins，并且遍历各个fast bin，对其中的每一个fast chunk进行如下操作：</p>
<p>假定被遍历的fast chunk为p</p>
<p>1.检查p的前一个chunk是否为空闲，如果为空闲二者进行合并，并且对前一个chunk进行unlink操作，将它从原来的链中取下来；</p>
<p>2.检查p的后一个chunk：</p>
<p>-如果是topchunk，则直接和topchunk合并；</p>
<p>-如果不是topchunk，进一步检查其是否空闲</p>
<p>–如果空闲则进行合并，并且对后一个chunk进行unlink操作</p>
<p>–如果非空闲则在后一个chunk中消除p的使用状态位，表示p是空闲的；</p>
<p>–最后将合并后的chunk放进unsorted bin中，每次放的位置是unsorted bin-&gt;fd的位置，这里如果合并后的chunk在large chunk范围内就将其fd_nextsize和bk_nextsize清空；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-type">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If max_fast is 0, we know that av hasn&#x27;t</span><br><span class="hljs-comment">    yet been initialized, in which case do so below</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br>    clear_fastchunks(av);<br><br>    unsorted_bin = unsorted_chunks(av);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">      then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">      placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">      reused anyway.</span><br><span class="hljs-comment">    */</span><br><br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;    <br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//将p = *fb，然后 *fb = 0，p是该fast bin的第一个fast chunk，随后根据p遍历整个fast bin</span><br>        <span class="hljs-comment">//</span><br>        p = atomic_exchange_acq (fb, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">do</span> &#123;<br>                    check_inuse_chunk(av, p);<br>                    nextp = p-&gt;fd;<br><br>                    <span class="hljs-comment">/* Slightly streamlined version of consolidation code in free() */</span><br>                    size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);<br>                    nextchunk = chunk_at_offset(p, size);<br>                    nextsize = chunksize(nextchunk);<br><br>                    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>                      prevsize = p-&gt;prev_size;<br>                      size += prevsize;<br>                      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>                      unlink(av, p, bck, fwd);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>                      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>                      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                        size += nextsize;<br>                        unlink(av, nextchunk, bck, fwd);<br>                      &#125; <span class="hljs-keyword">else</span><br>                        clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>                      first_unsorted = unsorted_bin-&gt;fd;<br>                      unsorted_bin-&gt;fd = p;<br>                      first_unsorted-&gt;bk = p;<br><br>                      <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>                        p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      &#125;<br><br>                      set_head(p, size | PREV_INUSE);<br>                      p-&gt;bk = unsorted_bin;<br>                      p-&gt;fd = first_unsorted;<br>                      set_foot(p, size);<br>                    &#125;<br><br>                    <span class="hljs-keyword">else</span> &#123;<br>                      size += nextsize;<br>                      set_head(p, size | PREV_INUSE);<br>                      av-&gt;top = p;<br>                    &#125;<br><br>              &#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br><br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="关于unlink"><a href="#关于unlink" class="headerlink" title="关于unlink"></a>关于unlink</h5><p>下面的unlink操作主要分large chunk和非large chunk</p>
<p>1.非large chunk统一的操作就是仅操作fd和bk，将其从双链中摘下即可；</p>
<p>2.如果是large chunk，就是多一个操作fd_nextsize和bk_nextsize：</p>
<p>-如果fd_nextsize非空，首先检查fd_nextsize和bk_nextsize组成的双链是正确的；因为如果为空，它就没有这一步；</p>
<p>-p-&gt;fd-&gt;fd_nextsize如果为空，则p-&gt;fd是它的成员，而且说明P是它的头部：</p>
<p>–如果P是large bin仅存的一种大小的头部，那么fd会成为新的头部，fd_nextsize指向自己；</p>
<p>–如果P是非仅存的一种大小的头部，那么就让p-&gt;fd接管即可；</p>
<p>-p-&gt;fd-&gt;fd_nextsize如果非空，说明p-&gt;fd要么也是一个头部，要么就是large bin的头；</p>
<p>–就按照fd_nextsize所在的一条双向链表进行接管</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    FD = P-&gt;fd;                                      \</span><br><span class="hljs-meta">    BK = P-&gt;bk;                                      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))              \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span> &#123;                                      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;                                  \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;                                  \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)                      \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;              \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)          \</span><br><span class="hljs-meta">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">          malloc_printerr (check_action,                      \</span><br><span class="hljs-meta">                   <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="hljs-meta">                   P, AV);                          \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;<span class="hljs-comment">//判断FD是否为成员                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                if (P-&gt;fd_nextsize == P)                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                else &#123;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                  &#125;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">              &#125; else &#123;                                  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">              &#125;                                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">          &#125;                                      \</span></span><br><span class="hljs-comment"><span class="hljs-meta">      &#125;                                          \</span></span><br><span class="hljs-comment"><span class="hljs-meta">&#125;</span></span><br></code></pre></td></tr></table></figure>

<h5 id="关于large-bin中的组织关系"><a href="#关于large-bin中的组织关系" class="headerlink" title="关于large bin中的组织关系"></a>关于large bin中的组织关系</h5><p>当large bin只有一个large chunk时，这个large chunk作为头部，通过fd和bk和large bin组成双向循环链表；fd_nextsize和bk_nextsize由于没有其他大小的large chunk，暂时都指向自己；</p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113819020.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113830825.png" srcset="/img/loading.gif" lazyload></p>
<p>关于large bin 中的large chunk组织如下：黑色是fd和bk指针；绿色是fd_nextsize和bk_nextsize指针；</p>
<p>其中的large chunk之间还是通过fd和bk指针来相互连接，和bin共同构成双向循环链表；</p>
<p>–large bin的fd指向本bin中最大的large chunk的头部；large bin的bk指向本bin中最小的large chunk的头部；</p>
<p>然后在此基础上通过fd_nextsize和bk_nextsize两个指针进而抽象出第二条双向循环链表：</p>
<p>–large bin中的large chunk只有头部chunk的fd_nextsize和bk_nextsize非空，用于连接各个大小chunk的头部；【下面所讲的头部其实还是chunk，只是它的*_nextsize非空我们称其为头部】</p>
<p>–如果有多个同等大小的chunk，只有头部的*_nextsize非空，其它是NULL；</p>
<p>–fd_nextsize指向比当前小且大小最接近的chunk，bk_nextsize指向比当前大且最接近的chunk。</p>
<p>–由于是双向循环链表，最大chunk头部的bk_nextsize指向最小chunk的头部；最小chunk头部的fd_nextsize指向最大chunk的头部；</p>
<p>还有就是插入时的操作：</p>
<p>假定要插入的chunk为p，如果large  bin中已经存在同等大小chunk，那么头部已经存在，此时p是插到头部前面，也就是头部-&gt;fd这个位置；</p>
<p>如果large bin中不存在该大小的chunk，那么该chunk就作为头部；插入的位置是根据其大小通过fd和bk放到双向链表中的，如下面所示，总体上是由大小顺序的；</p>
<p><img src="/2023/11/26/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20240826113904645.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>下面会依次进入while循环(处理unsorted_bin)、if判断是否为large chunk、for循环使用更大的chunk来分配、usetop等几部分</p>
<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>1.Line2取Victim &#x3D; unsorted_bin-&gt;bk，并判断unsorted是否为空</p>
<p>2.Line5-8是检查Victim的大小符合规范，av-&gt;system_mem表示当前分配区已经分配内存的大小</p>
<p>下面的while循环基本上是做以下几个事情：</p>
<p>在一定的迭代次数内：</p>
<p>遍历unsorted bin中的chunk，如果既不是unsorted中仅存的last_remainder，也不是和需要的大小恰好一致，就将其放到对应的bin中去</p>
<p>对应last_remainder或者大小一致的情况：</p>
<p>如果符合last_remainder相关要求，就可以进行分配；或者大小正好符合所需的，就可以直接返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs C">      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<h5 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h5><p>到此处，先说明一下：</p>
<p>fast chunk的情况如果有就已经在开头返回了；</p>
<p>small chunk在开头就尝试从small bin中进行分配，如果没成功，上面在处理unsorted时又进行了一遍，如果还没有分配，说明大小没有一致的，只能后面尝试用更大的进行分配；</p>
<p>large chunk经过unsorted简单大小比较分配后，如果没有一致的chunk就进入下面large bin中尝试分配</p>
<p>这部分就是处理large chunk这种情况：</p>
<p>1.首先找到对应大小对应的large bin</p>
<p>2.然后判断，该large bin中是否有合适的chunk可分配（细节地处理是否为一种大小chunk的头chunk）</p>
<p>3.将victim从large bin中摘除，并且进行切割操作，如果太小就一起给了，如果还能剩下，那么剩下的部分就放到unsorted中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>  &#123;<br>    bin = bin_at (av, idx);<br><br>    <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>    <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>      &#123;<br>            victim = victim-&gt;bk_nextsize;<br>            <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>              victim = victim-&gt;bk_nextsize;<br><br>            <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">              list does not have to be rerouted.  */</span><br>            <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>              victim = victim-&gt;fd;<br><br>            remainder_size = size - nb;<br>            unlink (av, victim, bck, fwd);<br><br>            <span class="hljs-comment">/* Exhaust */</span><br>            <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>              &#123;<br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  victim-&gt;size |= NON_MAIN_ARENA;<br>              &#125;<br>            <span class="hljs-comment">/* Split */</span><br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                    remainder = chunk_at_offset (victim, nb);<br>                    <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                      have to perform a complete insert here.  */</span><br>                    bck = unsorted_chunks (av);<br>                    fwd = bck-&gt;fd;<br>                      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                      &#123;<br>                        errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                        <span class="hljs-keyword">goto</span> errout;<br>                      &#125;<br>                    remainder-&gt;bk = bck;<br>                    remainder-&gt;fd = fwd;<br>                    bck-&gt;fd = remainder;<br>                    fwd-&gt;bk = remainder;<br>                    <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                      &#123;<br>                        remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                        remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                      &#125;<br>                    set_head (victim, nb | PREV_INUSE |<br>                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                    set_head (remainder, remainder_size | PREV_INUSE);<br>                    set_foot (remainder, remainder_size);<br>              &#125;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h5><p>到这里，说明前面都没有分配成功，对于small chunk和large chunk只能先尝试使用更大的chunk进行分配；</p>
<p>下面就是用更大的chunk来进行分配，从bin的角度去搜索</p>
<p>下面首先就是取相邻的bin，获取对应的block、map然后进入for循环</p>
<p>其实值得注意的是“bit &gt; map || bit &#x3D;&#x3D; 0”这个判断条件：</p>
<p>bit是当前bin对应bitmap中的位置，map是当前block的真实map值，这种情况好理解，bit&gt;map说明当前block中还有bin中存在chunk</p>
<p>bit &#x3D;&#x3D; 0 这个条件为了应对，下面那种误报情况，如果误报的bin恰好对应block中的31位(2^31的指数)，然后消除误报后，bit&lt;&lt;1此时会溢出为0</p>
<p>就是找到一个最接近的非空的bin，取其中bin-&gt;bk，进行尝试切割；这边还有主要就是如果申请的small chunk，切割剩下的chunk如果大小还能独自存在，那就将其设置为last_remainder</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C">++idx;<br>bin = bin_at (av, idx);<br>block = idx2block (idx);<br><span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>bit = idx2bit (idx);<br><br><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>        <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>        <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>          &#123;<br>            <span class="hljs-keyword">do</span><br>              &#123;<br>                <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                  <span class="hljs-keyword">goto</span> use_top;<br>              &#125;<br>            <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>            bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>            bit = <span class="hljs-number">1</span>;<br>          &#125;<br><br>        <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>        <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>          &#123;<br>            bin = next_bin (bin);<br>            bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            assert (bit != <span class="hljs-number">0</span>);<br>          &#125;<br><br>        <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>        victim = last (bin);<br><br>        <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>        <span class="hljs-comment">//下面这种误报情况是有可能将bit置为0的，这种情况是bit已经到31位了，31位误报，bit&lt;&lt;1就会溢出变为0【这里31是指2^31】</span><br>        <span class="hljs-keyword">if</span> (victim == bin)<br>          &#123;<br>            av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><span class="hljs-comment">//清除该位</span><br>            bin = next_bin (bin);<span class="hljs-comment">//下一个bin，有可能一个block有多个bin可用</span><br>            bit &lt;&lt;= <span class="hljs-number">1</span>;<br>          &#125;<br><br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            size = chunksize (victim);<br><br>            <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>            assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>            remainder_size = size - nb;<br><br>            <span class="hljs-comment">/* unlink */</span><br>            unlink (av, victim, bck, fwd);<br><br>            <span class="hljs-comment">/* Exhaust */</span><br>            <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>              &#123;<br>                set_inuse_bit_at_offset (victim, size);<br>                <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                  victim-&gt;size |= NON_MAIN_ARENA;<br>              &#125;<br><br>            <span class="hljs-comment">/* Split */</span><br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                remainder = chunk_at_offset (victim, nb);<br><br>                <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>                bck = unsorted_chunks (av);<br>                fwd = bck-&gt;fd;<br>                <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                &#123;<br>                    errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                    <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>                remainder-&gt;bk = bck;<br>                remainder-&gt;fd = fwd;<br>                bck-&gt;fd = remainder;<br>                fwd-&gt;bk = remainder;<br><br>                <span class="hljs-comment">/* advertise as last remainder */</span><br>                <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                  av-&gt;last_remainder = remainder;<br>                <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                  &#123;<br>                    remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                    remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                  &#125;<br>                set_head (victim, nb | PREV_INUSE |<br>                          (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                set_head (remainder, remainder_size | PREV_INUSE);<br>                set_foot (remainder, remainder_size);<br>              &#125;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="usetop"><a href="#usetop" class="headerlink" title="usetop"></a>usetop</h5><p>下面就是尝试使用top chunk了，</p>
<p>如果top能够进行分配，那么就会直接分配；</p>
<p>如果top空间不足会触发一次合并fast chunk操作，然后从头再进行尝试分配一次；</p>
<p>如果top空间不足且无fast chunk可合并，就只能尝试向系统进行申请了</p>
<p>这部分值得提出的是，if ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb + MINSIZE))，为什么要限制top chunk至少能保留MINSIZE呢？因为这个MINSIZE用来标记前面的chunk的使用状态，仅此而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C">use_top:<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">     less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">     be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">     limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">     MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">     exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">     reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">     to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">   */</span><br><br>  victim = av-&gt;top;<br>  size = chunksize (victim);<br>  <span class="hljs-comment">//top chunk能直接分配所需的大小，这里要始终让top chunk至少能剩MINSIZE，为了标记前面的chunk</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>    &#123;<br>      remainder_size = size - nb;<br>      remainder = chunk_at_offset (victim, nb);<br>      av-&gt;top = remainder;<br>      set_head (victim, nb | PREV_INUSE |<br>                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      set_head (remainder, remainder_size | PREV_INUSE);<br><br>      check_malloced_chunk (av, victim, nb);<br>      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>  <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">     here for all block sizes.  */</span><br>  <span class="hljs-comment">//如果top chunk空间不足，就会触发尝试合并fast chunk，然后从头再来一次</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>    &#123;<br>      malloc_consolidate (av);<br>      <span class="hljs-comment">/* restore original bin index */</span><br>      <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>        idx = smallbin_index (nb);<br>      <span class="hljs-keyword">else</span><br>        idx = largebin_index (nb);<br>    &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">//如果也没有fast chunk可以进行合并，那么就会尝试向系统申请</span><br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h4><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>下面判断是否达到使用mmap分配的条件：1.av为空时；2.申请的大小能达到mmap的门槛</p>
<p>这里主要提几个注意点：</p>
<p>1.在调用mmap之前，ALIGN_UP (nb + SIZE_SZ：加个SIZE_SZ是因为正常的chunk是有相邻的chunk的，而且有一个共用部分pre_size字段。所以在使用mmap分配时，需要提前将这部分加上</p>
<p>2.通过mmap分配后，有可能会进行内存没对齐，又通过front_misalign来进行记录，最后将返回的地址向下移动差值即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C">mchunkptr old_top;              <span class="hljs-comment">/* incoming value of av-&gt;top */</span><br>INTERNAL_SIZE_T old_size;       <span class="hljs-comment">/* its size */</span><br><span class="hljs-type">char</span> *old_end;                  <span class="hljs-comment">/* its end address */</span><br><br><span class="hljs-type">long</span> size;                      <span class="hljs-comment">/* arg to first MORECORE or mmap call */</span><br><span class="hljs-type">char</span> *brk;                      <span class="hljs-comment">/* return value from MORECORE */</span><br><br><span class="hljs-type">long</span> correction;                <span class="hljs-comment">/* arg to 2nd MORECORE call */</span><br><span class="hljs-type">char</span> *snd_brk;                  <span class="hljs-comment">/* 2nd return val */</span><br><br>INTERNAL_SIZE_T front_misalign; <span class="hljs-comment">/* unusable bytes at front of new space */</span><br>INTERNAL_SIZE_T end_misalign;   <span class="hljs-comment">/* partial page left at end of new space */</span><br><span class="hljs-type">char</span> *aligned_brk;              <span class="hljs-comment">/* aligned offset into brk */</span><br><br>mchunkptr p;                    <span class="hljs-comment">/* the allocated/returned chunk */</span><br>mchunkptr remainder;            <span class="hljs-comment">/* remainder from allocation */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;   <span class="hljs-comment">/* its size */</span><br><br><br><span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);<br><span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If have mmap, and the request size meets the mmap threshold, and</span><br><span class="hljs-comment">  the system supports mmap, and there are few enough currently</span><br><span class="hljs-comment">  allocated mmapped regions, try to directly map this request</span><br><span class="hljs-comment">  rather than expanding top.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//主要是两种情况下会选择使用mmap：1.av为空；2.申请的大小已经达到使用mmap的门槛了</span><br><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)<br>  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<br>  &#123;<br>        <span class="hljs-type">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br><br>      try_mmap:<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          Round up size to nearest page.  For mmapped chunks, the overhead</span><br><span class="hljs-comment">          is one SIZE_SZ unit larger than for normal chunks, because there</span><br><span class="hljs-comment">          is no following chunk whose prev_size field could be used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          See the front_misalign handling below, for glibc there is no</span><br><span class="hljs-comment">          need for further alignments unless we have have high alignment.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-comment">//下面多一个size，是因为对于mapped chunk没有相邻的下一个chunk头部presize字段可用</span><br>        <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>          size = ALIGN_UP (nb + SIZE_SZ, pagesize);<br>        <span class="hljs-keyword">else</span><br>          size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);<br>        tried_mmap = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>          &#123;<br>            mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>            <span class="hljs-keyword">if</span> (mm != MAP_FAILED)<br>              &#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  The offset to the start of the mmapped region is stored</span><br><span class="hljs-comment">                  in the prev_size field of the chunk. This allows us to adjust</span><br><span class="hljs-comment">                  returned start address to meet alignment requirements here</span><br><span class="hljs-comment">                  and in memalign(), and still be able to compute proper</span><br><span class="hljs-comment">                  address argument for later munmap in free() and realloc().</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">//下面这个是申请后，检查是否有没对齐的内存部分，用frot_misalign来记录</span><br>                <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                  &#123;<br>                    <span class="hljs-comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span><br><span class="hljs-comment">                      MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span><br><span class="hljs-comment">                      aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span><br>                    assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                    front_misalign = <span class="hljs-number">0</span>;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;<br>                <br>                <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">//correction记录还差多少能对齐，这里选择将申请来的地址向下移动差的字节进行对齐</span><br>                    correction = MALLOC_ALIGNMENT - front_misalign;<br>                    p = (mchunkptr) (mm + correction);<br>                    p-&gt;prev_size = correction;<br>                    set_head (p, (size - correction) | IS_MMAPPED);<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    p = (mchunkptr) mm;<br>                    set_head (p, size | IS_MMAPPED);<br>                  &#125;<br><br>                <span class="hljs-comment">/* update statistics */</span><br>                <span class="hljs-comment">//下面这个部分就是更新mmap分配的数量，还有mmap分配的内存大小</span><br>                <span class="hljs-type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);<br><br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;<br>                sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;<br>                <span class="hljs-type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);<br><br>                check_chunk (av, p);<br><br>                <span class="hljs-keyword">return</span> chunk2mem (p);<br>              &#125;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="一些中间操作"><a href="#一些中间操作" class="headerlink" title="一些中间操作"></a>一些中间操作</h5><p>主要是一些获取操作和一些判断条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* There are no usable arenas and mmap also failed.  */</span><br><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Record incoming configuration of top */</span><br><br>old_top = av-&gt;top;<br>old_size = chunksize (old_top);<br>old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<br><br>brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  If not the first time through, we require old_size to be</span><br><span class="hljs-comment">  at least MINSIZE and to have prev_inuse set.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//这里就是两个条件，一个是没有初始化时，将unsorted当作假top，此时top_chunk size为0；</span><br><span class="hljs-comment">//正常后，要保证top chunk至少有MINSIZE并且前面的chunk在使用</span><br>assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>        prev_inuse (old_top) &amp;&amp;<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">/* Precondition: not enough current space to satisfy nb request */</span><br>assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br></code></pre></td></tr></table></figure>

<h5 id="非主分配区分配"><a href="#非主分配区分配" class="headerlink" title="非主分配区分配"></a>非主分配区分配</h5><p>注意点：下面根据top chunk指针计算其heap头的地址，是因为heap本身是页对齐的，所以可以直接通过逻辑运算进行求得。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">heap_for_ptr</span>(ptr) <br>((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure>

<p>下面是if-else分支的if分支，这个主要是用来处理非主分配区的分配</p>
<p>先看下大致流程：</p>
<p>首先就是尝试增长原heap</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>  &#123;<br>    <span class="hljs-comment">//非主分配区</span><br>    heap_info *old_heap, *heap;<br>    <span class="hljs-type">size_t</span> old_heap_size;<br><br>    <span class="hljs-comment">/* First try to extend the current heap. */</span><br>    old_heap = heap_for_ptr (old_top);<br>    old_heap_size = old_heap-&gt;size;<br>    <span class="hljs-comment">//如果heap空间不足，尝试增长heap</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span><br>        &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>)<br>      &#123;<br>        av-&gt;system_mem += old_heap-&gt;size - old_heap_size;<br>        arena_mem += old_heap-&gt;size - old_heap_size;<br>        set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)<br>                  | PREV_INUSE);<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="hljs-keyword">sizeof</span> (*heap)), mp_.top_pad)))<br>      &#123;<br>        <span class="hljs-comment">//这里是使用新创建的一个heap</span><br>        <span class="hljs-comment">/* Use a newly allocated heap.  */</span><br>        heap-&gt;ar_ptr = av;<br>        heap-&gt;prev = old_heap;<br>        av-&gt;system_mem += heap-&gt;size;<br>        arena_mem += heap-&gt;size;<br>        <span class="hljs-comment">/* Set up the new top.  */</span><br>        <span class="hljs-comment">//新申请的堆的结构：</span><br>        <span class="hljs-comment">//heap：struct heap...| top chunk...</span><br>        top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span> (*heap));<br>        set_head (top (av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span> (*heap)) | PREV_INUSE);<br><br>        <span class="hljs-comment">/* Setup fencepost and free the old top chunk with a multiple of</span><br><span class="hljs-comment">          MALLOC_ALIGNMENT in size. */</span><br>        <span class="hljs-comment">/* The fencepost takes at least MINSIZE bytes, because it might</span><br><span class="hljs-comment">          become the top chunk again later.  Note that a footer is set</span><br><span class="hljs-comment">          up, too, although the chunk is marked in use. */</span><br>        old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;<br>        set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);<br>        <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>          &#123;<br>            set_head (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>            set_foot (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));<br>            set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);<br>            _int_free (av, old_top, <span class="hljs-number">1</span>);<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>            set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));<br>          &#125;<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)<br>      <span class="hljs-comment">/* We can at least try to use to mmap memory.  */</span><br>      <span class="hljs-keyword">goto</span> try_mmap;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="主分配区分配"><a href="#主分配区分配" class="headerlink" title="主分配区分配"></a>主分配区分配</h5><h6 id="关于sbrk"><a href="#关于sbrk" class="headerlink" title="关于sbrk"></a>关于sbrk</h6><p>这里插入一个关于sbrk的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C">sbrk(<span class="hljs-number">0</span>)返回当前段结束地址#<span class="hljs-number">1</span><br>sbrk(<span class="hljs-number">4096</span>)返回增加后的起始地址#<span class="hljs-number">2</span><br>sbrk(<span class="hljs-number">0</span>)返回当前段结束地址#<span class="hljs-number">3</span><br>#<span class="hljs-number">1</span>的结果是原来的结束地址<br>#<span class="hljs-number">2</span>执行的结果是和#<span class="hljs-number">1</span>一致的，因为返回的是初始地址<br>#<span class="hljs-number">3</span>这个就是增加后的结束地址了<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">void</span> *p = sbrk(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before:%p\n&quot;</span>, p);<br>    <br>    p = sbrk(<span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(4096):%p\n&quot;</span>, p);<br><br>    p = sbrk(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(0)%p\n&quot;</span>, p);<br><br>    p = sbrk(<span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sbrk(4096)%p\n&quot;</span>, p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">else</span>     <span class="hljs-comment">/* av == main_arena */</span><br><br><br>    &#123; <span class="hljs-comment">/* Request enough space for nb + pad + overhead */</span><br>      size = nb + mp_.top_pad + MINSIZE;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If contiguous, we can subtract out existing space that we hope to</span><br><span class="hljs-comment">         combine with new space. We add it back later only if</span><br><span class="hljs-comment">         we don&#x27;t actually get contiguous space.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (contiguous (av))<br>        size -= old_size;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Round to a multiple of page size.</span><br><span class="hljs-comment">         If MORECORE is not contiguous, this ensures that we only call it</span><br><span class="hljs-comment">         with whole-page arguments.  And if MORECORE is contiguous and</span><br><span class="hljs-comment">         this is not first time through, this preserves page-alignment of</span><br><span class="hljs-comment">         previous calls. Otherwise, we correct to page-align below.</span><br><span class="hljs-comment">       */</span><br><br>      size = ALIGN_UP (size, pagesize);<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear</span><br><span class="hljs-comment">         negative. Note that since mmap takes size_t arg, it may succeed</span><br><span class="hljs-comment">         below even if we cannot call MORECORE.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>          brk = (<span class="hljs-type">char</span> *) (MORECORE (size));<br>          LIBC_PROBE (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>          <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>          <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>            (*hook)();<br>        &#125;<br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If have mmap, try using it as a backup when MORECORE fails or</span><br><span class="hljs-comment">             cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span><br><span class="hljs-comment">             address space, so sbrk cannot extend to give contiguous space, but</span><br><span class="hljs-comment">             space is available elsewhere.  Note that we ignore mmap max count</span><br><span class="hljs-comment">             and threshold limits, since the space will not be used as a</span><br><span class="hljs-comment">             segregated mmap region.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-comment">/* Cannot merge with old top, so add its size back in */</span><br>          <span class="hljs-keyword">if</span> (contiguous (av))<br>            size = ALIGN_UP (size + old_size, pagesize);<br><br>          <span class="hljs-comment">/* If we are relying on mmap as backup, then use larger units */</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))<br>            size = MMAP_AS_MORECORE_SIZE;<br><br>          <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>              <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));<br><br>              <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)<br>                &#123;<br>                  <span class="hljs-comment">/* We do not need, and cannot use, another sbrk call to find end */</span><br>                  brk = mbrk;<br>                  snd_brk = brk + size;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     Record that we no longer have a contiguous sbrk region.</span><br><span class="hljs-comment">                     After the first time mmap is used as backup, we do not</span><br><span class="hljs-comment">                     ever rely on contiguous space since this could incorrectly</span><br><span class="hljs-comment">                     bridge regions.</span><br><span class="hljs-comment">                   */</span><br>                  set_noncontiguous (av);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)<br>            mp_.sbrk_base = brk;<br>          av-&gt;system_mem += size;<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If MORECORE extends previous space, we can likewise extend top size.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>            set_head (old_top, (size + old_size) | PREV_INUSE);<br><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)<br>            &#123;<br>              <span class="hljs-comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span><br>              malloc_printerr (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>, brk,<br>			       av);<br>            &#125;<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             Otherwise, make adjustments:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * If the first time through or noncontiguous, we need to call sbrk</span><br><span class="hljs-comment">              just to find out where the end of memory lies.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * We need to ensure that all returned chunks from malloc will meet</span><br><span class="hljs-comment">              MALLOC_ALIGNMENT</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk</span><br><span class="hljs-comment">              request size to account for fact that we will not be able to</span><br><span class="hljs-comment">              combine new space with existing space in old_top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           * Almost all systems internally allocate whole pages at a time, in</span><br><span class="hljs-comment">              which case we might as well use the whole last page of request.</span><br><span class="hljs-comment">              So we allocate enough more memory to hit a page boundary now,</span><br><span class="hljs-comment">              which in turn causes future contiguous calls to page-align.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              front_misalign = <span class="hljs-number">0</span>;<br>              end_misalign = <span class="hljs-number">0</span>;<br>              correction = <span class="hljs-number">0</span>;<br>              aligned_brk = brk;<br><br>              <span class="hljs-comment">/* handle contiguous cases */</span><br>              <span class="hljs-keyword">if</span> (contiguous (av))<br>                &#123;<br>                  <span class="hljs-comment">/* Count foreign sbrk as system_mem.  */</span><br>                  <span class="hljs-keyword">if</span> (old_size)<br>                    av-&gt;system_mem += brk - old_end;<br><br>                  <span class="hljs-comment">/* Guarantee alignment of first new chunk made from this space */</span><br><br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                  <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                         We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                         They will never be accessed anyway because</span><br><span class="hljs-comment">                         prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                         is always true after initialization.</span><br><span class="hljs-comment">                       */</span><br><br>                      correction = MALLOC_ALIGNMENT - front_misalign;<br>                      aligned_brk += correction;<br>                    &#125;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If this isn&#x27;t adjacent to existing space, then we will not</span><br><span class="hljs-comment">                     be able to merge with old_top space, so must add to 2nd request.</span><br><span class="hljs-comment">                   */</span><br><br>                  correction += old_size;<br><br>                  <span class="hljs-comment">/* Extend the end address to hit a page boundary */</span><br>                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);<br>                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;<br><br>                  assert (correction &gt;= <span class="hljs-number">0</span>);<br>                  snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (correction));<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If can&#x27;t allocate correction, try to at least find out current</span><br><span class="hljs-comment">                     brk.  It might be enough to proceed without failing.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                     Note that if second sbrk did NOT fail, we assume that space</span><br><span class="hljs-comment">                     is contiguous with first sbrk. This is a safe assumption unless</span><br><span class="hljs-comment">                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span><br><span class="hljs-comment">                     occurred between our first and second calls.</span><br><span class="hljs-comment">                   */</span><br><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      correction = <span class="hljs-number">0</span>;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span><br>                      <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>                      <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>                        (*hook)();<br>                    &#125;<br>                &#125;<br><br>              <span class="hljs-comment">/* handle non-contiguous cases */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)<br>                    <span class="hljs-comment">/* MORECORE/mmap must correctly align */</span><br>                    assert (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;<br>                      <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)<br>                        &#123;<br>                          <span class="hljs-comment">/*</span><br><span class="hljs-comment">                             Skip over some bytes to arrive at an aligned position.</span><br><span class="hljs-comment">                             We don&#x27;t need to specially mark these wasted front bytes.</span><br><span class="hljs-comment">                             They will never be accessed anyway because</span><br><span class="hljs-comment">                             prev_inuse of av-&gt;top (and any chunk created from its start)</span><br><span class="hljs-comment">                             is always true after initialization.</span><br><span class="hljs-comment">                           */</span><br><br>                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;<br>                        &#125;<br>                    &#125;<br><br>                  <span class="hljs-comment">/* Find out current end of memory */</span><br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                    &#123;<br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>                    &#125;<br>                &#125;<br><br>              <span class="hljs-comment">/* Adjust top based on results of second sbrk */</span><br>              <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))<br>                &#123;<br>                  av-&gt;top = (mchunkptr) aligned_brk;<br>                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);<br>                  av-&gt;system_mem += correction;<br><br>                  <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     If not the first time through, we either have a</span><br><span class="hljs-comment">                     gap due to foreign sbrk or a non-contiguous region.  Insert a</span><br><span class="hljs-comment">                     double fencepost at old_top to prevent consolidation with space</span><br><span class="hljs-comment">                     we don&#x27;t own. These fenceposts are artificial chunks that are</span><br><span class="hljs-comment">                     marked as inuse and are in any case too small to use.  We need</span><br><span class="hljs-comment">                     two to make sizes and alignments work out.</span><br><span class="hljs-comment">                   */</span><br><br>                  <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                    &#123;<br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                         multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                         enough space in old_top to do this.</span><br><span class="hljs-comment">                       */</span><br>                      old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                      set_head (old_top, old_size | PREV_INUSE);<br><br>                      <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         Note that the following assignments completely overwrite</span><br><span class="hljs-comment">                         old_top when old_size was previously MINSIZE.  This is</span><br><span class="hljs-comment">                         intentional. We need the fencepost, even if old_top otherwise gets</span><br><span class="hljs-comment">                         lost.</span><br><span class="hljs-comment">                       */</span><br>		      set_head (chunk_at_offset (old_top, old_size),<br>				(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>		      set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>				(<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br><br>                      <span class="hljs-comment">/* If possible, release the rest. */</span><br>                      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                        &#123;<br>                          _int_free (av, old_top, <span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/* if (av !=  &amp;main_arena) */</span><br></code></pre></td></tr></table></figure>

<p>最后做一些关于arena的设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))<br>  av-&gt;max_system_mem = av-&gt;system_mem;<br>check_malloc_state (av);<br><br><span class="hljs-comment">/* finally, do the allocation */</span><br>p = av-&gt;top;<br>size = chunksize (p);<br><br><span class="hljs-comment">/* check that one of the above allocation paths succeeded */</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>  &#123;<br>    remainder_size = size - nb;<br>    remainder = chunk_at_offset (p, nb);<br>    av-&gt;top = remainder;<br>    set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head (remainder, remainder_size | PREV_INUSE);<br>    check_malloced_chunk (av, p, nb);<br>    <span class="hljs-keyword">return</span> chunk2mem (p);<br>  &#125;<br><br><span class="hljs-comment">/* catch all failure paths */</span><br>__set_errno (ENOMEM);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%A0%86/" class="print-no-link">#堆</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>malloc源码分析</div>
      <div>https://binpwn.github.io/2023/11/26/malloc源码分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>DingJiayu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/27/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="free源码分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">free源码分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/25/geacon-macos/" title="geacon_macos">
                        <span class="hidden-mobile">geacon_macos</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/dkjiayu" target="_blank" rel="nofollow noopener"><span>DJY</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/binpwn" target="_blank" rel="nofollow noopener"><span>ZJL</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
